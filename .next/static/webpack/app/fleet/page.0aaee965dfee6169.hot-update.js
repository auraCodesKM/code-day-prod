"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/fleet/page",{

/***/ "(app-pages-browser)/./components/AlchemyService.tsx":
/*!***************************************!*\
  !*** ./components/AlchemyService.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlchemyNFTService: function() { return /* binding */ AlchemyNFTService; },\n/* harmony export */   SHIP_TYPES: function() { return /* binding */ SHIP_TYPES; },\n/* harmony export */   alchemyNFTService: function() { return /* binding */ alchemyNFTService; }\n/* harmony export */ });\n/* harmony import */ var alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alchemy-sdk */ \"(app-pages-browser)/./node_modules/alchemy-sdk/dist/esm/index-f73a5f29.js\");\n/* __next_internal_client_entry_do_not_use__ SHIP_TYPES,AlchemyNFTService,alchemyNFTService auto */ \n// Alchemy configuration - support multiple networks\nconst getAlchemyConfig = ()=>{\n    const apiKey = \"mKSXhkHH4QGGKApSV9bmVUoFwuetHWWw\" || 0;\n    const chainId = \"11155111\" || 0;\n    // Map chain IDs to Alchemy networks\n    const networkMap = {\n        \"1\": alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__.N.ETH_MAINNET,\n        \"11155111\": alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__.N.ETH_SEPOLIA,\n        \"137\": alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__.N.MATIC_MAINNET,\n        \"80001\": alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__.N.MATIC_MUMBAI\n    };\n    const network = networkMap[chainId] || alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__.N.ETH_SEPOLIA;\n    console.log(\"Alchemy Config:\", {\n        apiKey: apiKey.substring(0, 10) + \"...\",\n        network,\n        chainId\n    });\n    return {\n        apiKey,\n        network\n    };\n};\nconst alchemy = new alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__.m(getAlchemyConfig());\n// NFT Ship Types mapping\nconst SHIP_TYPES = {\n    \"STELLAR VOYAGER\": {\n        id: \"stellar-voyager\",\n        name: \"STELLAR VOYAGER\",\n        rarity: \"COMMON\",\n        color: \"neon-blue\",\n        stats: {\n            speed: 65,\n            armor: 45,\n            luck: 30\n        },\n        description: \"A reliable starter ship for cosmic adventures\"\n    },\n    \"NEBULA HUNTER\": {\n        id: \"nebula-hunter\",\n        name: \"NEBULA HUNTER\",\n        rarity: \"RARE\",\n        color: \"neon-green\",\n        stats: {\n            speed: 80,\n            armor: 60,\n            luck: 35\n        },\n        description: \"Enhanced propulsion for deep space missions\"\n    },\n    \"QUANTUM DESTROYER\": {\n        id: \"quantum-destroyer\",\n        name: \"QUANTUM DESTROYER\",\n        rarity: \"EPIC\",\n        color: \"neon-purple\",\n        stats: {\n            speed: 95,\n            armor: 85,\n            luck: 75\n        },\n        description: \"Elite warship with quantum-enhanced capabilities\"\n    }\n};\n// Map NFT metadata to ship type based on name or attributes\nconst mapNFTToShipType = (nft)=>{\n    var _nft_name, _nft_description;\n    const name = ((_nft_name = nft.name) === null || _nft_name === void 0 ? void 0 : _nft_name.toUpperCase()) || \"\";\n    const description = ((_nft_description = nft.description) === null || _nft_description === void 0 ? void 0 : _nft_description.toUpperCase()) || \"\";\n    if (name.includes(\"STELLAR\") || name.includes(\"VOYAGER\")) {\n        return \"STELLAR VOYAGER\";\n    } else if (name.includes(\"NEBULA\") || name.includes(\"HUNTER\")) {\n        return \"NEBULA HUNTER\";\n    } else if (name.includes(\"QUANTUM\") || name.includes(\"DESTROYER\")) {\n        return \"QUANTUM DESTROYER\";\n    }\n    // Default to STELLAR VOYAGER if can't determine\n    return \"STELLAR VOYAGER\";\n};\n// Generate mock game data for NFTs (in real app, this would come from game backend)\nconst generateGameData = (tokenId)=>{\n    const seed = parseInt(tokenId) || 1;\n    return {\n        level: Math.max(1, Math.floor(seed % 10) + 1),\n        experience: seed % 10 * 250 + Math.floor(seed / 10) * 100,\n        missions: Math.floor(seed % 50) + Math.floor(seed / 100) * 5,\n        earnings: parseFloat((seed % 100 / 1000 + seed % 10 / 100).toFixed(3))\n    };\n};\nclass AlchemyNFTService {\n    // Test different networks to find where NFTs are located\n    async testNetworksForNFTs(ownerAddress) {\n        const networks = [\n            {\n                name: \"Ethereum Mainnet\",\n                network: alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__.N.ETH_MAINNET,\n                chainId: \"1\"\n            },\n            {\n                name: \"Ethereum Sepolia\",\n                network: alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__.N.ETH_SEPOLIA,\n                chainId: \"11155111\"\n            },\n            {\n                name: \"Polygon Mainnet\",\n                network: alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__.N.MATIC_MAINNET,\n                chainId: \"137\"\n            },\n            {\n                name: \"Polygon Mumbai\",\n                network: alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__.N.MATIC_MUMBAI,\n                chainId: \"80001\"\n            }\n        ];\n        console.log(\"\\uD83D\\uDD0D Testing networks for NFTs...\");\n        for (const net of networks){\n            try {\n                var _response_ownedNfts;\n                console.log(\"\\n\\uD83C\\uDF10 Testing \".concat(net.name, \" (Chain ID: \").concat(net.chainId, \")...\"));\n                const testAlchemy = new alchemy_sdk__WEBPACK_IMPORTED_MODULE_0__.m({\n                    apiKey: \"mKSXhkHH4QGGKApSV9bmVUoFwuetHWWw\" || 0,\n                    network: net.network\n                });\n                const response = await testAlchemy.nft.getNftsForOwner(ownerAddress, {\n                    omitMetadata: false\n                });\n                console.log(\"\\uD83D\\uDCCA \".concat(net.name, \" results:\"), {\n                    totalCount: response.totalCount,\n                    ownedNftsCount: ((_response_ownedNfts = response.ownedNfts) === null || _response_ownedNfts === void 0 ? void 0 : _response_ownedNfts.length) || 0\n                });\n                if (response.ownedNfts && response.ownedNfts.length > 0) {\n                    console.log(\"\\uD83C\\uDFAF Found \".concat(response.ownedNfts.length, \" NFTs on \").concat(net.name, \"!\"));\n                    console.log(\"Sample NFTs:\", response.ownedNfts.slice(0, 3).map((nft)=>{\n                        var _nft_contract;\n                        return {\n                            tokenId: nft.tokenId,\n                            contract: (_nft_contract = nft.contract) === null || _nft_contract === void 0 ? void 0 : _nft_contract.address,\n                            title: nft.title || nft.name,\n                            tokenType: nft.tokenType\n                        };\n                    }));\n                }\n            } catch (error) {\n                console.log(\"❌ \".concat(net.name, \" failed:\"), error.message);\n            }\n        }\n    }\n    // Fetch NFTs for a specific owner\n    async getNFTsForOwner(ownerAddress, contractAddress) {\n        try {\n            var _nftsResponse_ownedNfts, _nftsResponse_ownedNfts1;\n            console.log(\"\\uD83D\\uDE80 Fetching NFTs for owner:\", ownerAddress);\n            console.log(\"\\uD83D\\uDD0D Contract filter:\", contractAddress || \"All contracts\");\n            console.log(\"\\uD83C\\uDF10 Current network:\", getAlchemyConfig().network);\n            console.log(\"\\uD83D\\uDD11 API Key (first 10 chars):\", getAlchemyConfig().apiKey.substring(0, 10) + \"...\");\n            // Try multiple approaches to fetch NFTs\n            const approaches = [\n                // Approach 1: With contract filter (if provided)\n                ...contractAddress ? [\n                    {\n                        contractAddresses: [\n                            contractAddress\n                        ],\n                        omitMetadata: false\n                    }\n                ] : [],\n                // Approach 2: Without contract filter (all NFTs)\n                {\n                    omitMetadata: false\n                },\n                // Approach 3: Minimal options\n                {}\n            ];\n            let nftsResponse = null;\n            let usedApproach = 0;\n            for(let i = 0; i < approaches.length; i++){\n                try {\n                    console.log(\"\\uD83D\\uDCE1 Trying approach \".concat(i + 1, \":\"), approaches[i]);\n                    nftsResponse = await alchemy.nft.getNftsForOwner(ownerAddress, approaches[i]);\n                    usedApproach = i + 1;\n                    console.log(\"✅ Approach \".concat(i + 1, \" successful!\"));\n                    break;\n                } catch (approachError) {\n                    console.log(\"❌ Approach \".concat(i + 1, \" failed:\"), approachError);\n                    continue;\n                }\n            }\n            if (!nftsResponse) {\n                throw new Error(\"All approaches failed\");\n            }\n            console.log(\"\\uD83D\\uDCCA Alchemy response (approach \" + usedApproach + \"):\", {\n                totalCount: nftsResponse.totalCount,\n                ownedNftsCount: ((_nftsResponse_ownedNfts = nftsResponse.ownedNfts) === null || _nftsResponse_ownedNfts === void 0 ? void 0 : _nftsResponse_ownedNfts.length) || 0,\n                pageKey: nftsResponse.pageKey,\n                validAt: nftsResponse.validAt\n            });\n            if (((_nftsResponse_ownedNfts1 = nftsResponse.ownedNfts) === null || _nftsResponse_ownedNfts1 === void 0 ? void 0 : _nftsResponse_ownedNfts1.length) > 0) {\n                var _nftsResponse_ownedNfts__contract;\n                console.log(\"\\uD83C\\uDFAF First NFT sample:\", {\n                    tokenId: nftsResponse.ownedNfts[0].tokenId,\n                    title: nftsResponse.ownedNfts[0].title,\n                    name: nftsResponse.ownedNfts[0].name,\n                    contract: (_nftsResponse_ownedNfts__contract = nftsResponse.ownedNfts[0].contract) === null || _nftsResponse_ownedNfts__contract === void 0 ? void 0 : _nftsResponse_ownedNfts__contract.address,\n                    tokenType: nftsResponse.ownedNfts[0].tokenType,\n                    description: nftsResponse.ownedNfts[0].description\n                });\n            }\n            const allNFTs = nftsResponse.ownedNfts || [];\n            console.log(\"\\uD83D\\uDCDD Processing\", allNFTs.length, \"NFTs...\");\n            // Process all NFTs (don't filter by title initially to see what we get)\n            const processedNFTs = allNFTs.map((nft, index)=>{\n                var _nft_contract, _nft_contract1, _nft_media_, _nft_media, _nft_media_1, _nft_media1, _nft_image;\n                console.log(\"\\uD83D\\uDD04 Processing NFT \".concat(index + 1, \":\"), {\n                    tokenId: nft.tokenId,\n                    title: nft.title,\n                    name: nft.name,\n                    contract: (_nft_contract = nft.contract) === null || _nft_contract === void 0 ? void 0 : _nft_contract.address,\n                    hasMetadata: !!nft.metadata\n                });\n                const shipType = mapNFTToShipType(nft);\n                const gameData = generateGameData(nft.tokenId);\n                return {\n                    tokenId: nft.tokenId,\n                    contractAddress: ((_nft_contract1 = nft.contract) === null || _nft_contract1 === void 0 ? void 0 : _nft_contract1.address) || \"\",\n                    shipType,\n                    name: nft.title || nft.name || \"Ship #\".concat(nft.tokenId),\n                    description: nft.description || SHIP_TYPES[shipType].description,\n                    image: ((_nft_media = nft.media) === null || _nft_media === void 0 ? void 0 : (_nft_media_ = _nft_media[0]) === null || _nft_media_ === void 0 ? void 0 : _nft_media_.gateway) || ((_nft_media1 = nft.media) === null || _nft_media1 === void 0 ? void 0 : (_nft_media_1 = _nft_media1[0]) === null || _nft_media_1 === void 0 ? void 0 : _nft_media_1.raw) || ((_nft_image = nft.image) === null || _nft_image === void 0 ? void 0 : _nft_image.originalUrl) || \"\",\n                    mintedAt: new Date().toISOString().split(\"T\")[0],\n                    ...gameData,\n                    metadata: nft.metadata || {}\n                };\n            });\n            console.log(\"✨ Final processed NFTs:\", processedNFTs.length);\n            console.log(\"\\uD83C\\uDFAE Processed NFTs details:\", processedNFTs.map((nft)=>({\n                    tokenId: nft.tokenId,\n                    name: nft.name,\n                    shipType: nft.shipType,\n                    contract: nft.contractAddress\n                })));\n            return processedNFTs;\n        } catch (error) {\n            console.error(\"\\uD83D\\uDCA5 Error fetching NFTs from Alchemy:\", error);\n            console.error(\"Error details:\", {\n                message: error.message,\n                stack: error.stack,\n                name: error.name\n            });\n            // Return empty array instead of throwing to prevent app crashes\n            return [];\n        }\n    }\n    // Fetch specific NFT details\n    async getNFTDetails(contractAddress, tokenId) {\n        try {\n            var _nft_image, _nft_image1, _nft_raw;\n            const nft = await alchemy.nft.getNftMetadata(contractAddress, tokenId);\n            if (!nft) return null;\n            const shipType = mapNFTToShipType(nft);\n            const gameData = generateGameData(tokenId);\n            return {\n                tokenId: nft.tokenId,\n                contractAddress: nft.contract.address,\n                shipType,\n                name: nft.name || \"Ship #\".concat(nft.tokenId),\n                description: nft.description || SHIP_TYPES[shipType].description,\n                image: ((_nft_image = nft.image) === null || _nft_image === void 0 ? void 0 : _nft_image.originalUrl) || ((_nft_image1 = nft.image) === null || _nft_image1 === void 0 ? void 0 : _nft_image1.cachedUrl) || \"\",\n                mintedAt: new Date().toISOString().split(\"T\")[0],\n                ...gameData,\n                metadata: ((_nft_raw = nft.raw) === null || _nft_raw === void 0 ? void 0 : _nft_raw.metadata) || {}\n            };\n        } catch (error) {\n            console.error(\"Error fetching NFT details from Alchemy:\", error);\n            return null;\n        }\n    }\n    // Get NFT collection info\n    async getCollectionInfo(contractAddress) {\n        try {\n            const metadata = await alchemy.nft.getContractMetadata(contractAddress);\n            return metadata;\n        } catch (error) {\n            console.error(\"Error fetching collection info:\", error);\n            return null;\n        }\n    }\n}\n// Export singleton instance\nconst alchemyNFTService = new AlchemyNFTService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQWxjaGVteVNlcnZpY2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7b0dBRThDO0FBRTlDLG9EQUFvRDtBQUNwRCxNQUFNRSxtQkFBbUI7SUFDdkIsTUFBTUMsU0FBU0Msa0NBQXVDLElBQUk7SUFDMUQsTUFBTUcsVUFBVUgsVUFBZ0MsSUFBSTtJQUVwRCxvQ0FBb0M7SUFDcEMsTUFBTUssYUFBeUM7UUFDN0MsS0FBS1IsMENBQU9BLENBQUNTLFdBQVc7UUFDeEIsWUFBWVQsMENBQU9BLENBQUNVLFdBQVc7UUFDL0IsT0FBT1YsMENBQU9BLENBQUNXLGFBQWE7UUFDNUIsU0FBU1gsMENBQU9BLENBQUNZLFlBQVk7SUFDL0I7SUFFQSxNQUFNQyxVQUFVTCxVQUFVLENBQUNGLFFBQVEsSUFBSU4sMENBQU9BLENBQUNVLFdBQVc7SUFFMURJLFFBQVFDLEdBQUcsQ0FBQyxtQkFBbUI7UUFBRWIsUUFBUUEsT0FBT2MsU0FBUyxDQUFDLEdBQUcsTUFBTTtRQUFPSDtRQUFTUDtJQUFRO0lBRTNGLE9BQU87UUFBRUo7UUFBUVc7SUFBUTtBQUMzQjtBQUVBLE1BQU1JLFVBQVUsSUFBSWxCLDBDQUFPQSxDQUFDRTtBQUU1Qix5QkFBeUI7QUFDbEIsTUFBTWlCLGFBQWE7SUFDeEIsbUJBQW1CO1FBQ2pCQyxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLE9BQU87WUFBRUMsT0FBTztZQUFJQyxPQUFPO1lBQUlDLE1BQU07UUFBRztRQUN4Q0MsYUFBYTtJQUNmO0lBQ0EsaUJBQWlCO1FBQ2ZSLElBQUk7UUFDSkMsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLE9BQU87UUFDUEMsT0FBTztZQUFFQyxPQUFPO1lBQUlDLE9BQU87WUFBSUMsTUFBTTtRQUFHO1FBQ3hDQyxhQUFhO0lBQ2Y7SUFDQSxxQkFBcUI7UUFDbkJSLElBQUk7UUFDSkMsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLE9BQU87UUFDUEMs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RUFBRSxPQUFPakIsT0FBTztZQUNkbEQsUUFBUWtELEtBQUssQ0FBQyxtQ0FBbUNBO1lBQ2pELE9BQU87UUFDVDtJQUNGO0FBQ0Y7QUFFQSw0QkFBNEI7QUFDckIsTUFBTW1DLG9CQUFvQixJQUFJdEQsb0JBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQWxjaGVteVNlcnZpY2UudHN4P2U2NDYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IEFsY2hlbXksIE5ldHdvcmsgfSBmcm9tICdhbGNoZW15LXNkaydcblxuLy8gQWxjaGVteSBjb25maWd1cmF0aW9uIC0gc3VwcG9ydCBtdWx0aXBsZSBuZXR3b3Jrc1xuY29uc3QgZ2V0QWxjaGVteUNvbmZpZyA9ICgpID0+IHtcbiAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQUxDSEVNWV9BUElfS0VZIHx8ICdkZW1vJ1xuICBjb25zdCBjaGFpbklkID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ0hBSU5fSUQgfHwgJzExMTU1MTExJ1xuICBcbiAgLy8gTWFwIGNoYWluIElEcyB0byBBbGNoZW15IG5ldHdvcmtzXG4gIGNvbnN0IG5ldHdvcmtNYXA6IHsgW2tleTogc3RyaW5nXTogTmV0d29yayB9ID0ge1xuICAgICcxJzogTmV0d29yay5FVEhfTUFJTk5FVCxcbiAgICAnMTExNTUxMTEnOiBOZXR3b3JrLkVUSF9TRVBPTElBLFxuICAgICcxMzcnOiBOZXR3b3JrLk1BVElDX01BSU5ORVQsXG4gICAgJzgwMDAxJzogTmV0d29yay5NQVRJQ19NVU1CQUksXG4gIH1cbiAgXG4gIGNvbnN0IG5ldHdvcmsgPSBuZXR3b3JrTWFwW2NoYWluSWRdIHx8IE5ldHdvcmsuRVRIX1NFUE9MSUFcbiAgXG4gIGNvbnNvbGUubG9nKCdBbGNoZW15IENvbmZpZzonLCB7IGFwaUtleTogYXBpS2V5LnN1YnN0cmluZygwLCAxMCkgKyAnLi4uJywgbmV0d29yaywgY2hhaW5JZCB9KVxuICBcbiAgcmV0dXJuIHsgYXBpS2V5LCBuZXR3b3JrIH1cbn1cblxuY29uc3QgYWxjaGVteSA9IG5ldyBBbGNoZW15KGdldEFsY2hlbXlDb25maWcoKSlcblxuLy8gTkZUIFNoaXAgVHlwZXMgbWFwcGluZ1xuZXhwb3J0IGNvbnN0IFNISVBfVFlQRVMgPSB7XG4gICdTVEVMTEFSIFZPWUFHRVInOiB7XG4gICAgaWQ6ICdzdGVsbGFyLXZveWFnZXInLFxuICAgIG5hbWU6ICdTVEVMTEFSIFZPWUFHRVInLFxuICAgIHJhcml0eTogJ0NPTU1PTicsXG4gICAgY29sb3I6ICduZW9uLWJsdWUnLFxuICAgIHN0YXRzOiB7IHNwZWVkOiA2NSwgYXJtb3I6IDQ1LCBsdWNrOiAzMCB9LFxuICAgIGRlc2NyaXB0aW9uOiAnQSByZWxpYWJsZSBzdGFydGVyIHNoaXAgZm9yIGNvc21pYyBhZHZlbnR1cmVzJ1xuICB9LFxuICAnTkVCVUxBIEhVTlRFUic6IHtcbiAgICBpZDogJ25lYnVsYS1odW50ZXInLCBcbiAgICBuYW1lOiAnTkVCVUxBIEhVTlRFUicsXG4gICAgcmFyaXR5OiAnUkFSRScsXG4gICAgY29sb3I6ICduZW9uLWdyZWVuJyxcbiAgICBzdGF0czogeyBzcGVlZDogODAsIGFybW9yOiA2MCwgbHVjazogMzUgfSxcbiAgICBkZXNjcmlwdGlvbjogJ0VuaGFuY2VkIHByb3B1bHNpb24gZm9yIGRlZXAgc3BhY2UgbWlzc2lvbnMnXG4gIH0sXG4gICdRVUFOVFVNIERFU1RST1lFUic6IHtcbiAgICBpZDogJ3F1YW50dW0tZGVzdHJveWVyJyxcbiAgICBuYW1lOiAnUVVBTlRVTSBERVNUUk9ZRVInLCBcbiAgICByYXJpdHk6ICdFUElDJyxcbiAgICBjb2xvcjogJ25lb24tcHVycGxlJyxcbiAgICBzdGF0czogeyBzcGVlZDogOTUsIGFybW9yOiA4NSwgbHVjazogNzUgfSxcbiAgICBkZXNjcmlwdGlvbjogJ0VsaXRlIHdhcnNoaXAgd2l0aCBxdWFudHVtLWVuaGFuY2VkIGNhcGFiaWxpdGllcydcbiAgfVxufVxuXG4vLyBFbmhhbmNlZCBORlQgaW50ZXJmYWNlIHdpdGggQWxjaGVteSBkYXRhXG5leHBvcnQgaW50ZXJmYWNlIEFsY2hlbXlORlQge1xuICB0b2tlbklkOiBzdHJpbmdcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmdcbiAgc2hpcFR5cGU6IGtleW9mIHR5cGVvZiBTSElQX1RZUEVTXG4gIG5hbWU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIGltYWdlOiBzdHJpbmdcbiAgbWludGVkQXQ6IHN0cmluZ1xuICBsZXZlbDogbnVtYmVyXG4gIGV4cGVyaWVuY2U6IG51bWJlclxuICBtaXNzaW9uczogbnVtYmVyXG4gIGVhcm5pbmdzOiBudW1iZXJcbiAgbWV0YWRhdGE6IGFueVxufVxuXG4vLyBNYXAgTkZUIG1ldGFkYXRhIHRvIHNoaXAgdHlwZSBiYXNlZCBvbiBuYW1lIG9yIGF0dHJpYnV0ZXNcbmNvbnN0IG1hcE5GVFRvU2hpcFR5cGUgPSAobmZ0OiBhbnkpOiBrZXlvZiB0eXBlb2YgU0hJUF9UWVBFUyA9PiB7XG4gIGNvbnN0IG5hbWUgPSBuZnQubmFtZT8udG9VcHBlckNhc2UoKSB8fCAnJ1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IG5mdC5kZXNjcmlwdGlvbj8udG9VcHBlckNhc2UoKSB8fCAnJ1xuICBcbiAgaWYgKG5hbWUuaW5jbHVkZXMoJ1NURUxMQVInKSB8fCBuYW1lLmluY2x1ZGVzKCdWT1lBR0VSJykpIHtcbiAgICByZXR1cm4gJ1NURUxMQVIgVk9ZQUdFUidcbiAgfSBlbHNlIGlmIChuYW1lLmluY2x1ZGVzKCdORUJVTEEnKSB8fCBuYW1lLmluY2x1ZGVzKCdIVU5URVInKSkge1xuICAgIHJldHVybiAnTkVCVUxBIEhVTlRFUidcbiAgfSBlbHNlIGlmIChuYW1lLmluY2x1ZGVzKCdRVUFOVFVNJykgfHwgbmFtZS5pbmNsdWRlcygnREVTVFJPWUVSJykpIHtcbiAgICByZXR1cm4gJ1FVQU5UVU0gREVTVFJPWUVSJ1xuICB9XG4gIFxuICAvLyBEZWZhdWx0IHRvIFNURUxMQVIgVk9ZQUdFUiBpZiBjYW4ndCBkZXRlcm1pbmVcbiAgcmV0dXJuICdTVEVMTEFSIFZPWUFHRVInXG59XG5cbi8vIEdlbmVyYXRlIG1vY2sgZ2FtZSBkYXRhIGZvciBORlRzIChpbiByZWFsIGFwcCwgdGhpcyB3b3VsZCBjb21lIGZyb20gZ2FtZSBiYWNrZW5kKVxuY29uc3QgZ2VuZXJhdGVHYW1lRGF0YSA9ICh0b2tlbklkOiBzdHJpbmcpID0+IHtcbiAgY29uc3Qgc2VlZCA9IHBhcnNlSW50KHRva2VuSWQpIHx8IDFcbiAgcmV0dXJuIHtcbiAgICBsZXZlbDogTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihzZWVkICUgMTApICsgMSksXG4gICAgZXhwZXJpZW5jZTogKHNlZWQgJSAxMCkgKiAyNTAgKyBNYXRoLmZsb29yKHNlZWQgLyAxMCkgKiAxMDAsXG4gICAgbWlzc2lvbnM6IE1hdGguZmxvb3Ioc2VlZCAlIDUwKSArIE1hdGguZmxvb3Ioc2VlZCAvIDEwMCkgKiA1LFxuICAgIGVhcm5pbmdzOiBwYXJzZUZsb2F0KCgoc2VlZCAlIDEwMCkgLyAxMDAwICsgKHNlZWQgJSAxMCkgLyAxMDApLnRvRml4ZWQoMykpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFsY2hlbXlORlRTZXJ2aWNlIHtcbiAgLy8gVGVzdCBkaWZmZXJlbnQgbmV0d29ya3MgdG8gZmluZCB3aGVyZSBORlRzIGFyZSBsb2NhdGVkXG4gIGFzeW5jIHRlc3ROZXR3b3Jrc0Zvck5GVHMob3duZXJBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBuZXR3b3JrcyA9IFtcbiAgICAgIHsgbmFtZTogJ0V0aGVyZXVtIE1haW5uZXQnLCBuZXR3b3JrOiBOZXR3b3JrLkVUSF9NQUlOTkVULCBjaGFpbklkOiAnMScgfSxcbiAgICAgIHsgbmFtZTogJ0V0aGVyZXVtIFNlcG9saWEnLCBuZXR3b3JrOiBOZXR3b3JrLkVUSF9TRVBPTElBLCBjaGFpbklkOiAnMTExNTUxMTEnIH0sXG4gICAgICB7IG5hbWU6ICdQb2x5Z29uIE1haW5uZXQnLCBuZXR3b3JrOiBOZXR3b3JrLk1BVElDX01BSU5ORVQsIGNoYWluSWQ6ICcxMzcnIH0sXG4gICAgICB7IG5hbWU6ICdQb2x5Z29uIE11bWJhaScsIG5ldHdvcms6IE5ldHdvcmsuTUFUSUNfTVVNQkFJLCBjaGFpbklkOiAnODAwMDEnIH0sXG4gICAgXVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn5SNIFRlc3RpbmcgbmV0d29ya3MgZm9yIE5GVHMuLi4nKVxuICAgIFxuICAgIGZvciAoY29uc3QgbmV0IG9mIG5ldHdvcmtzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhgXFxu8J+MkCBUZXN0aW5nICR7bmV0Lm5hbWV9IChDaGFpbiBJRDogJHtuZXQuY2hhaW5JZH0pLi4uYClcbiAgICAgICAgY29uc3QgdGVzdEFsY2hlbXkgPSBuZXcgQWxjaGVteSh7XG4gICAgICAgICAgYXBpS2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BTENIRU1ZX0FQSV9LRVkgfHwgJ2RlbW8nLFxuICAgICAgICAgIG5ldHdvcms6IG5ldC5uZXR3b3JrXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRlc3RBbGNoZW15Lm5mdC5nZXROZnRzRm9yT3duZXIob3duZXJBZGRyZXNzLCB7IG9taXRNZXRhZGF0YTogZmFsc2UgfSlcbiAgICAgICAgY29uc29sZS5sb2coYPCfk4ogJHtuZXQubmFtZX0gcmVzdWx0czpgLCB7XG4gICAgICAgICAgdG90YWxDb3VudDogcmVzcG9uc2UudG90YWxDb3VudCxcbiAgICAgICAgICBvd25lZE5mdHNDb3VudDogcmVzcG9uc2Uub3duZWROZnRzPy5sZW5ndGggfHwgMFxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgaWYgKHJlc3BvbnNlLm93bmVkTmZ0cyAmJiByZXNwb25zZS5vd25lZE5mdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46vIEZvdW5kICR7cmVzcG9uc2Uub3duZWROZnRzLmxlbmd0aH0gTkZUcyBvbiAke25ldC5uYW1lfSFgKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdTYW1wbGUgTkZUczonLCByZXNwb25zZS5vd25lZE5mdHMuc2xpY2UoMCwgMykubWFwKChuZnQ6IGFueSkgPT4gKHtcbiAgICAgICAgICAgIHRva2VuSWQ6IG5mdC50b2tlbklkLFxuICAgICAgICAgICAgY29udHJhY3Q6IG5mdC5jb250cmFjdD8uYWRkcmVzcyxcbiAgICAgICAgICAgIHRpdGxlOiBuZnQudGl0bGUgfHwgbmZ0Lm5hbWUsXG4gICAgICAgICAgICB0b2tlblR5cGU6IG5mdC50b2tlblR5cGVcbiAgICAgICAgICB9KSkpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhg4p2MICR7bmV0Lm5hbWV9IGZhaWxlZDpgLCAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBGZXRjaCBORlRzIGZvciBhIHNwZWNpZmljIG93bmVyXG4gIGFzeW5jIGdldE5GVHNGb3JPd25lcihvd25lckFkZHJlc3M6IHN0cmluZywgY29udHJhY3RBZGRyZXNzPzogc3RyaW5nKTogUHJvbWlzZTxBbGNoZW15TkZUW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CfmoAgRmV0Y2hpbmcgTkZUcyBmb3Igb3duZXI6Jywgb3duZXJBZGRyZXNzKVxuICAgICAgY29uc29sZS5sb2coJ/CflI0gQ29udHJhY3QgZmlsdGVyOicsIGNvbnRyYWN0QWRkcmVzcyB8fCAnQWxsIGNvbnRyYWN0cycpXG4gICAgICBjb25zb2xlLmxvZygn8J+MkCBDdXJyZW50IG5ldHdvcms6JywgZ2V0QWxjaGVteUNvbmZpZygpLm5ldHdvcmspXG4gICAgICBjb25zb2xlLmxvZygn8J+UkSBBUEkgS2V5IChmaXJzdCAxMCBjaGFycyk6JywgZ2V0QWxjaGVteUNvbmZpZygpLmFwaUtleS5zdWJzdHJpbmcoMCwgMTApICsgJy4uLicpXG4gICAgICBcbiAgICAgIC8vIFRyeSBtdWx0aXBsZSBhcHByb2FjaGVzIHRvIGZldGNoIE5GVHNcbiAgICAgIGNvbnN0IGFwcHJvYWNoZXMgPSBbXG4gICAgICAgIC8vIEFwcHJvYWNoIDE6IFdpdGggY29udHJhY3QgZmlsdGVyIChpZiBwcm92aWRlZClcbiAgICAgICAgLi4uKGNvbnRyYWN0QWRkcmVzcyA/IFt7XG4gICAgICAgICAgY29udHJhY3RBZGRyZXNzZXM6IFtjb250cmFjdEFkZHJlc3NdLFxuICAgICAgICAgIG9taXRNZXRhZGF0YTogZmFsc2UsXG4gICAgICAgIH1dIDogW10pLFxuICAgICAgICBcbiAgICAgICAgLy8gQXBwcm9hY2ggMjogV2l0aG91dCBjb250cmFjdCBmaWx0ZXIgKGFsbCBORlRzKVxuICAgICAgICB7XG4gICAgICAgICAgb21pdE1ldGFkYXRhOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcHJvYWNoIDM6IE1pbmltYWwgb3B0aW9uc1xuICAgICAgICB7fVxuICAgICAgXVxuICAgICAgXG4gICAgICBsZXQgbmZ0c1Jlc3BvbnNlOiBhbnkgPSBudWxsXG4gICAgICBsZXQgdXNlZEFwcHJvYWNoID0gMFxuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFwcHJvYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+ToSBUcnlpbmcgYXBwcm9hY2ggJHtpICsgMX06YCwgYXBwcm9hY2hlc1tpXSlcbiAgICAgICAgICBuZnRzUmVzcG9uc2UgPSBhd2FpdCBhbGNoZW15Lm5mdC5nZXROZnRzRm9yT3duZXIob3duZXJBZGRyZXNzLCBhcHByb2FjaGVzW2ldKVxuICAgICAgICAgIHVzZWRBcHByb2FjaCA9IGkgKyAxXG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBBcHByb2FjaCAke2kgKyAxfSBzdWNjZXNzZnVsIWApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBjYXRjaCAoYXBwcm9hY2hFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinYwgQXBwcm9hY2ggJHtpICsgMX0gZmFpbGVkOmAsIGFwcHJvYWNoRXJyb3IpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIW5mdHNSZXNwb25zZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBhcHByb2FjaGVzIGZhaWxlZCcpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIEFsY2hlbXkgcmVzcG9uc2UgKGFwcHJvYWNoICcgKyB1c2VkQXBwcm9hY2ggKyAnKTonLCB7XG4gICAgICAgIHRvdGFsQ291bnQ6IG5mdHNSZXNwb25zZS50b3RhbENvdW50LFxuICAgICAgICBvd25lZE5mdHNDb3VudDogbmZ0c1Jlc3BvbnNlLm93bmVkTmZ0cz8ubGVuZ3RoIHx8IDAsXG4gICAgICAgIHBhZ2VLZXk6IG5mdHNSZXNwb25zZS5wYWdlS2V5LFxuICAgICAgICB2YWxpZEF0OiBuZnRzUmVzcG9uc2UudmFsaWRBdFxuICAgICAgfSlcbiAgICAgIFxuICAgICAgaWYgKG5mdHNSZXNwb25zZS5vd25lZE5mdHM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfjq8gRmlyc3QgTkZUIHNhbXBsZTonLCB7XG4gICAgICAgICAgdG9rZW5JZDogbmZ0c1Jlc3BvbnNlLm93bmVkTmZ0c1swXS50b2tlbklkLFxuICAgICAgICAgIHRpdGxlOiBuZnRzUmVzcG9uc2Uub3duZWROZnRzWzBdLnRpdGxlLFxuICAgICAgICAgIG5hbWU6IG5mdHNSZXNwb25zZS5vd25lZE5mdHNbMF0ubmFtZSxcbiAgICAgICAgICBjb250cmFjdDogbmZ0c1Jlc3BvbnNlLm93bmVkTmZ0c1swXS5jb250cmFjdD8uYWRkcmVzcyxcbiAgICAgICAgICB0b2tlblR5cGU6IG5mdHNSZXNwb25zZS5vd25lZE5mdHNbMF0udG9rZW5UeXBlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBuZnRzUmVzcG9uc2Uub3duZWROZnRzWzBdLmRlc2NyaXB0aW9uXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGFsbE5GVHMgPSBuZnRzUmVzcG9uc2Uub3duZWROZnRzIHx8IFtdXG4gICAgICBjb25zb2xlLmxvZygn8J+TnSBQcm9jZXNzaW5nJywgYWxsTkZUcy5sZW5ndGgsICdORlRzLi4uJylcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBhbGwgTkZUcyAoZG9uJ3QgZmlsdGVyIGJ5IHRpdGxlIGluaXRpYWxseSB0byBzZWUgd2hhdCB3ZSBnZXQpXG4gICAgICBjb25zdCBwcm9jZXNzZWRORlRzOiBBbGNoZW15TkZUW10gPSBhbGxORlRzXG4gICAgICAgIC5tYXAoKG5mdDogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCflIQgUHJvY2Vzc2luZyBORlQgJHtpbmRleCArIDF9OmAsIHtcbiAgICAgICAgICAgIHRva2VuSWQ6IG5mdC50b2tlbklkLFxuICAgICAgICAgICAgdGl0bGU6IG5mdC50aXRsZSxcbiAgICAgICAgICAgIG5hbWU6IG5mdC5uYW1lLFxuICAgICAgICAgICAgY29udHJhY3Q6IG5mdC5jb250cmFjdD8uYWRkcmVzcyxcbiAgICAgICAgICAgIGhhc01ldGFkYXRhOiAhIW5mdC5tZXRhZGF0YVxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3Qgc2hpcFR5cGUgPSBtYXBORlRUb1NoaXBUeXBlKG5mdClcbiAgICAgICAgICBjb25zdCBnYW1lRGF0YSA9IGdlbmVyYXRlR2FtZURhdGEobmZ0LnRva2VuSWQpXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuSWQ6IG5mdC50b2tlbklkLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBuZnQuY29udHJhY3Q/LmFkZHJlc3MgfHwgJycsXG4gICAgICAgICAgICBzaGlwVHlwZSxcbiAgICAgICAgICAgIG5hbWU6IG5mdC50aXRsZSB8fCBuZnQubmFtZSB8fCBgU2hpcCAjJHtuZnQudG9rZW5JZH1gLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IG5mdC5kZXNjcmlwdGlvbiB8fCBTSElQX1RZUEVTW3NoaXBUeXBlXS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGltYWdlOiBuZnQubWVkaWE/LlswXT8uZ2F0ZXdheSB8fCBuZnQubWVkaWE/LlswXT8ucmF3IHx8IG5mdC5pbWFnZT8ub3JpZ2luYWxVcmwgfHwgJycsXG4gICAgICAgICAgICBtaW50ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgICAgICAgICAuLi5nYW1lRGF0YSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBuZnQubWV0YWRhdGEgfHwge31cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinKggRmluYWwgcHJvY2Vzc2VkIE5GVHM6JywgcHJvY2Vzc2VkTkZUcy5sZW5ndGgpXG4gICAgICBjb25zb2xlLmxvZygn8J+OriBQcm9jZXNzZWQgTkZUcyBkZXRhaWxzOicsIHByb2Nlc3NlZE5GVHMubWFwKG5mdCA9PiAoe1xuICAgICAgICB0b2tlbklkOiBuZnQudG9rZW5JZCxcbiAgICAgICAgbmFtZTogbmZ0Lm5hbWUsXG4gICAgICAgIHNoaXBUeXBlOiBuZnQuc2hpcFR5cGUsXG4gICAgICAgIGNvbnRyYWN0OiBuZnQuY29udHJhY3RBZGRyZXNzXG4gICAgICB9KSkpXG4gICAgICBcbiAgICAgIHJldHVybiBwcm9jZXNzZWRORlRzXG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign8J+SpSBFcnJvciBmZXRjaGluZyBORlRzIGZyb20gQWxjaGVteTonLCBlcnJvcilcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6Jywge1xuICAgICAgICBtZXNzYWdlOiAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiAoZXJyb3IgYXMgRXJyb3IpLnN0YWNrLFxuICAgICAgICBuYW1lOiAoZXJyb3IgYXMgRXJyb3IpLm5hbWVcbiAgICAgIH0pXG4gICAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaW5zdGVhZCBvZiB0aHJvd2luZyB0byBwcmV2ZW50IGFwcCBjcmFzaGVzXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZldGNoIHNwZWNpZmljIE5GVCBkZXRhaWxzXG4gIGFzeW5jIGdldE5GVERldGFpbHMoY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsIHRva2VuSWQ6IHN0cmluZyk6IFByb21pc2U8QWxjaGVteU5GVCB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmZ0ID0gYXdhaXQgYWxjaGVteS5uZnQuZ2V0TmZ0TWV0YWRhdGEoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKVxuICAgICAgXG4gICAgICBpZiAoIW5mdCkgcmV0dXJuIG51bGxcbiAgICAgIFxuICAgICAgY29uc3Qgc2hpcFR5cGUgPSBtYXBORlRUb1NoaXBUeXBlKG5mdClcbiAgICAgIGNvbnN0IGdhbWVEYXRhID0gZ2VuZXJhdGVHYW1lRGF0YSh0b2tlbklkKVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbklkOiBuZnQudG9rZW5JZCxcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBuZnQuY29udHJhY3QuYWRkcmVzcyxcbiAgICAgICAgc2hpcFR5cGUsXG4gICAgICAgIG5hbWU6IG5mdC5uYW1lIHx8IGBTaGlwICMke25mdC50b2tlbklkfWAsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBuZnQuZGVzY3JpcHRpb24gfHwgU0hJUF9UWVBFU1tzaGlwVHlwZV0uZGVzY3JpcHRpb24sXG4gICAgICAgIGltYWdlOiBuZnQuaW1hZ2U/Lm9yaWdpbmFsVXJsIHx8IG5mdC5pbWFnZT8uY2FjaGVkVXJsIHx8ICcnLFxuICAgICAgICBtaW50ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgICAgIC4uLmdhbWVEYXRhLFxuICAgICAgICBtZXRhZGF0YTogbmZ0LnJhdz8ubWV0YWRhdGEgfHwge31cbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBORlQgZGV0YWlscyBmcm9tIEFsY2hlbXk6JywgZXJyb3IpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuICBcbiAgLy8gR2V0IE5GVCBjb2xsZWN0aW9uIGluZm9cbiAgYXN5bmMgZ2V0Q29sbGVjdGlvbkluZm8oY29udHJhY3RBZGRyZXNzOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBhbGNoZW15Lm5mdC5nZXRDb250cmFjdE1ldGFkYXRhKGNvbnRyYWN0QWRkcmVzcylcbiAgICAgIHJldHVybiBtZXRhZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjb2xsZWN0aW9uIGluZm86JywgZXJyb3IpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgYWxjaGVteU5GVFNlcnZpY2UgPSBuZXcgQWxjaGVteU5GVFNlcnZpY2UoKVxuIl0sIm5hbWVzIjpbIkFsY2hlbXkiLCJOZXR3b3JrIiwiZ2V0QWxjaGVteUNvbmZpZyIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BTENIRU1ZX0FQSV9LRVkiLCJjaGFpbklkIiwiTkVYVF9QVUJMSUNfQ0hBSU5fSUQiLCJuZXR3b3JrTWFwIiwiRVRIX01BSU5ORVQiLCJFVEhfU0VQT0xJQSIsIk1BVElDX01BSU5ORVQiLCJNQVRJQ19NVU1CQUkiLCJuZXR3b3JrIiwiY29uc29sZSIsImxvZyIsInN1YnN0cmluZyIsImFsY2hlbXkiLCJTSElQX1RZUEVTIiwiaWQiLCJuYW1lIiwicmFyaXR5IiwiY29sb3IiLCJzdGF0cyIsInNwZWVkIiwiYXJtb3IiLCJsdWNrIiwiZGVzY3JpcHRpb24iLCJtYXBORlRUb1NoaXBUeXBlIiwibmZ0IiwidG9VcHBlckNhc2UiLCJpbmNsdWRlcyIsImdlbmVyYXRlR2FtZURhdGEiLCJ0b2tlbklkIiwic2VlZCIsInBhcnNlSW50IiwibGV2ZWwiLCJNYXRoIiwibWF4IiwiZmxvb3IiLCJleHBlcmllbmNlIiwibWlzc2lvbnMiLCJlYXJuaW5ncyIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwiQWxjaGVteU5GVFNlcnZpY2UiLCJ0ZXN0TmV0d29ya3NGb3JORlRzIiwib3duZXJBZGRyZXNzIiwibmV0d29ya3MiLCJuZXQiLCJyZXNwb25zZSIsInRlc3RBbGNoZW15IiwiZ2V0TmZ0c0Zvck93bmVyIiwib21pdE1ldGFkYXRhIiwidG90YWxDb3VudCIsIm93bmVkTmZ0c0NvdW50Iiwib3duZWROZnRzIiwibGVuZ3RoIiwic2xpY2UiLCJtYXAiLCJjb250cmFjdCIsImFkZHJlc3MiLCJ0aXRsZSIsInRva2VuVHlwZSIsImVycm9yIiwibWVzc2FnZSIsImdldE5GVHNGb3JPd25lciIsImNvbnRyYWN0QWRkcmVzcyIsIm5mdHNSZXNwb25zZSIsImFwcHJvYWNoZXMiLCJjb250cmFjdEFkZHJlc3NlcyIsInVzZWRBcHByb2FjaCIsImkiLCJhcHByb2FjaEVycm9yIiwiRXJyb3IiLCJwYWdlS2V5IiwidmFsaWRBdCIsImFsbE5GVHMiLCJwcm9jZXNzZWRORlRzIiwiaW5kZXgiLCJoYXNNZXRhZGF0YSIsIm1ldGFkYXRhIiwic2hpcFR5cGUiLCJnYW1lRGF0YSIsImltYWdlIiwibWVkaWEiLCJnYXRld2F5IiwicmF3Iiwib3JpZ2luYWxVcmwiLCJtaW50ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNwbGl0Iiwic3RhY2siLCJnZXRORlREZXRhaWxzIiwiZ2V0TmZ0TWV0YWRhdGEiLCJjYWNoZWRVcmwiLCJnZXRDb2xsZWN0aW9uSW5mbyIsImdldENvbnRyYWN0TWV0YWRhdGEiLCJhbGNoZW15TkZUU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/AlchemyService.tsx\n"));

/***/ })

});