"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/alchemy-sdk";
exports.ids = ["vendor-chunks/alchemy-sdk"];
exports.modules = {

/***/ "(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-provider-b006a4bc.js":
/*!************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/cjs/alchemy-provider-b006a4bc.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar index = __webpack_require__(/*! ./index-3873e7b8.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/index-3873e7b8.js\");\nvar networks = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/./node_modules/@ethersproject/networks/lib.esm/index.js\");\nvar providers = __webpack_require__(/*! @ethersproject/providers */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/index.js\");\nvar web = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/@ethersproject/web/lib.esm/index.js\");\n__webpack_require__(/*! ./api/utils */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\n__webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\");\n__webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/./node_modules/@ethersproject/wallet/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/./node_modules/@ethersproject/contracts/lib.esm/index.js\");\n/** Maximum size of a batch on the rpc provider. */ const DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\n/** Timeout interval before the pending batch is sent. */ const DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */ class RequestBatcher {\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE){\n        this.sendBatchFn = sendBatchFn;\n        this.maxBatchSize = maxBatchSize;\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */ this.pendingBatch = [];\n    }\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */ enqueueRequest(request) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const inflightRequest = {\n                request,\n                resolve: undefined,\n                reject: undefined\n            };\n            const promise = new Promise((resolve, reject)=>{\n                inflightRequest.resolve = resolve;\n                inflightRequest.reject = reject;\n            });\n            this.pendingBatch.push(inflightRequest);\n            if (this.pendingBatch.length === this.maxBatchSize) {\n                // Send batch immediately if we are at the maximum batch size.\n                void this.sendBatchRequest();\n            } else if (!this.pendingBatchTimer) {\n                // Schedule batch for next event loop + short duration\n                this.pendingBatchTimer = setTimeout(()=>this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\n            }\n            return promise;\n        });\n    }\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */ sendBatchRequest() {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            // Get the current batch and clear it, so new requests\n            // go into the next batch\n            const batch = this.pendingBatch;\n            this.pendingBatch = [];\n            if (this.pendingBatchTimer) {\n                clearTimeout(this.pendingBatchTimer);\n                this.pendingBatchTimer = undefined;\n            }\n            // Get the request as an array of requests\n            const request = batch.map((inflight)=>inflight.request);\n            return this.sendBatchFn(request).then((result)=>{\n                // For each result, feed it to the correct Promise, depending\n                // on whether it was a success or error\n                batch.forEach((inflightRequest, index)=>{\n                    const payload = result[index];\n                    if (payload.error) {\n                        const error = new Error(payload.error.message);\n                        error.code = payload.error.code;\n                        error.data = payload.error.data;\n                        inflightRequest.reject(error);\n                    } else {\n                        inflightRequest.resolve(payload.result);\n                    }\n                });\n            }, (error)=>{\n                batch.forEach((inflightRequest)=>{\n                    inflightRequest.reject(error);\n                });\n            });\n        });\n    }\n}\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */ class AlchemyProvider extends providers.JsonRpcProvider {\n    /** @internal */ constructor(config){\n        // Normalize the API Key to a string.\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n        // Generate our own connection info with the correct endpoint URLs.\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n        let connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, \"http\");\n        // If a hardcoded url was specified in the config, use that instead of the\n        // provided apiKey or network.\n        if (config.url !== undefined) {\n            connection.url = config.url;\n        }\n        connection.throttleLimit = config.maxRetries;\n        // Add user provided overrides if they exist.\n        if (config.connectionInfoOverrides) {\n            connection = Object.assign(Object.assign({}, connection), config.connectionInfoOverrides);\n        }\n        // Normalize the Alchemy named network input to the network names used by\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\n        // correctly set the network.\n        const ethersNetwork = index.EthersNetwork[alchemyNetwork];\n        if (!ethersNetwork) {\n            throw new Error(`Unsupported network: ${alchemyNetwork}`);\n        }\n        super(connection, ethersNetwork);\n        this.apiKey = config.apiKey;\n        this.maxRetries = config.maxRetries;\n        this.batchRequests = config.batchRequests;\n        // TODO: support individual headers when calling batch\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), {\n            headers: Object.assign(Object.assign({}, this.connection.headers), {\n                \"Alchemy-Ethers-Sdk-Method\": \"batchSend\"\n            })\n        });\n        const sendBatchFn = (requests)=>{\n            return web.fetchJson(batcherConnection, JSON.stringify(requests));\n        };\n        this.batcher = new RequestBatcher(sendBatchFn);\n        this.modifyFormatter();\n    }\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return index.DEFAULT_ALCHEMY_API_KEY;\n        }\n        if (apiKey && typeof apiKey !== \"string\") {\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\n        }\n        return apiKey;\n    }\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ static getNetwork(network) {\n        if (typeof network === \"string\" && network in index.CustomNetworks) {\n            return index.CustomNetworks[network];\n        }\n        // Call the standard ethers.js getNetwork method for other networks.\n        return networks.getNetwork(network);\n    }\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */ static getAlchemyNetwork(network) {\n        if (network === undefined) {\n            return index.DEFAULT_NETWORK;\n        }\n        if (typeof network === \"number\") {\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\n        }\n        // Guaranteed that `typeof network === 'string`.\n        const isValidNetwork = Object.values(index.Network).includes(network);\n        if (!isValidNetwork) {\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` + `${Object.values(index.Network).join(\", \")}.`);\n        }\n        return network;\n    }\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */ static getAlchemyConnectionInfo(network, apiKey, type) {\n        const url = type === \"http\" ? index.getAlchemyHttpUrl(network, apiKey) : index.getAlchemyWsUrl(network, apiKey);\n        return {\n            headers: index.IS_BROWSER ? {\n                \"Alchemy-Ethers-Sdk-Version\": index.VERSION\n            } : {\n                \"Alchemy-Ethers-Sdk-Version\": index.VERSION,\n                \"Accept-Encoding\": \"gzip\"\n            },\n            allowGzip: true,\n            url\n        };\n    }\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */ detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: {\n                get: ()=>super.detectNetwork\n            }\n        });\n        return index.__awaiter(this, void 0, void 0, function*() {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    throw new Error(\"No network detected\");\n                }\n            }\n            return network;\n        });\n    }\n    _startPending() {\n        index.logWarn(\"WARNING: Alchemy Provider does not support pending filters\");\n    }\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */ isCommunityResource() {\n        return this.apiKey === index.DEFAULT_ALCHEMY_API_KEY;\n    }\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */ // TODO: Add headers for `perform()` override.\n    send(method, params) {\n        return this._send(method, params, \"send\");\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */ _send(method, params, methodName) {\n        const request = {\n            method,\n            params,\n            id: this._nextId++,\n            jsonrpc: \"2.0\"\n        };\n        // START MODIFIED CODE\n        const connection = Object.assign({}, this.connection);\n        connection.headers[\"Alchemy-Ethers-Sdk-Method\"] = methodName;\n        if (this.batchRequests) {\n            return this.batcher.enqueueRequest(request);\n        }\n        // END MODIFIED CODE\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: index.deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = [\n            \"eth_chainId\",\n            \"eth_blockNumber\"\n        ].indexOf(method) >= 0;\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = web.fetchJson(this.connection, JSON.stringify(request), getResult).then((result)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                error,\n                request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(()=>{\n                // @ts-ignore - This is done by ethers.\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    /**\r\n     * Overrides the base `Formatter` class inherited from ethers to support\r\n     * returning custom fields in Ethers response types.\r\n     *\r\n     * For context, ethers has a `Formatter` class that is used to format the\r\n     * response from a JSON-RPC request. Any fields that are not defined in the\r\n     * `Formatter` class are removed from the returned response. By modifying the\r\n     * `Formatter` class in this method, we can add support for fields that are\r\n     * not defined in ethers.\r\n     */ modifyFormatter() {\n        this.formatter.formats[\"receiptLog\"][\"removed\"] = (val)=>{\n            if (typeof val === \"boolean\") {\n                return val;\n            }\n            return undefined;\n        };\n    }\n}\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */ function getResult(payload) {\n    if (payload.error) {\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nexports.AlchemyProvider = AlchemyProvider; //# sourceMappingURL=alchemy-provider-b006a4bc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvYWxjaGVteS1wcm92aWRlci1iMDA2YTRiYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlFLFlBQVlGLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlHLE1BQU1ILG1CQUFPQSxDQUFDO0FBQ2xCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLGlEQUFpRCxHQUNqRCxNQUFNSSxpQ0FBaUM7QUFDdkMsdURBQXVELEdBQ3ZELE1BQU1DLGlDQUFpQztBQUN2Qzs7Ozs7OztDQU9DLEdBQ0QsTUFBTUM7SUFDRkMsWUFBWUMsV0FBVyxFQUFFQyxlQUFlTCw4QkFBOEIsQ0FBRTtRQUNwRSxJQUFJLENBQUNJLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDQyxZQUFZLEdBQUdBO1FBQ3BCOzs7U0FHQyxHQUNELElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7SUFDMUI7SUFDQTs7Ozs7O0tBTUMsR0FDREMsZUFBZUMsT0FBTyxFQUFFO1FBQ3BCLE9BQU9iLE1BQU1jLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUN6QyxNQUFNQyxrQkFBa0I7Z0JBQ3BCRjtnQkFDQUcsU0FBU0M7Z0JBQ1RDLFFBQVFEO1lBQ1o7WUFDQSxNQUFNRSxVQUFVLElBQUlDLFFBQVEsQ0FBQ0osU0FBU0U7Z0JBQ2xDSCxnQkFBZ0JDLE9BQU8sR0FBR0E7Z0JBQzFCRCxnQkFBZ0JHLE1BQU0sR0FBR0E7WUFDN0I7WUFDQSxJQUFJLENBQUNQLFlBQVksQ0FBQ1UsSUFBSSxDQUFDTjtZQUN2QixJQUFJLElBQUks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O0lBQ3RCLElBQUlBLFFBQVFDLEtBQUssRUFBRTtRQUNmLE1BQU1BLFFBQVEsSUFBSUMsTUFBTUYsUUFBUUMsS0FBSyxDQUFDRSxPQUFPO1FBQzdDRixNQUFNRyxJQUFJLEdBQUdKLFFBQVFDLEtBQUssQ0FBQ0csSUFBSTtRQUMvQkgsTUFBTUksSUFBSSxHQUFHTCxRQUFRQyxLQUFLLENBQUNJLElBQUk7UUFDL0IsTUFBTUo7SUFDVjtJQUNBLE9BQU9ELFFBQVFGLE1BQU07QUFDekI7QUFFQThFLHVCQUF1QixHQUFHdEUsaUJBQzFCLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL21pc3Npb24tbGF1bmNoLWJ1cm4tb3ItZ2xvcnkvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvYWxjaGVteS1wcm92aWRlci1iMDA2YTRiYy5qcz9iYjc5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGluZGV4ID0gcmVxdWlyZSgnLi9pbmRleC0zODczZTdiOC5qcycpO1xudmFyIG5ldHdvcmtzID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvbmV0d29ya3MnKTtcbnZhciBwcm92aWRlcnMgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9wcm92aWRlcnMnKTtcbnZhciB3ZWIgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC93ZWInKTtcbnJlcXVpcmUoJy4vYXBpL3V0aWxzJyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9iaWdudW1iZXInKTtcbnJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2J5dGVzJyk7XG5yZXF1aXJlKCdheGlvcycpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXInKTtcbnJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L3dhbGxldCcpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJyk7XG5cbi8qKiBNYXhpbXVtIHNpemUgb2YgYSBiYXRjaCBvbiB0aGUgcnBjIHByb3ZpZGVyLiAqL1xyXG5jb25zdCBERUZBVUxUX01BWF9SRVFVRVNUX0JBVENIX1NJWkUgPSAxMDA7XHJcbi8qKiBUaW1lb3V0IGludGVydmFsIGJlZm9yZSB0aGUgcGVuZGluZyBiYXRjaCBpcyBzZW50LiAqL1xyXG5jb25zdCBERUZBVUxUX1JFUVVFU1RfQkFUQ0hfREVMQVlfTVMgPSAxMDtcclxuLyoqXHJcbiAqIEludGVybmFsIGNsYXNzIHRvIGVucXVldWUgcmVxdWVzdHMgYW5kIGF1dG9tYXRpY2FsbHkgc2VuZC9wcm9jZXNzIGJhdGNoZXMuXHJcbiAqXHJcbiAqIFRoZSB1bmRlcmx5aW5nIGJhdGNoaW5nIG1lY2hhbmlzbSBpcyBsb29zZWx5IGJhc2VkIG9uIGV0aGVycy5qcydzXHJcbiAqIGBKc29uUnBjQmF0Y2hQcm92aWRlcmAuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgUmVxdWVzdEJhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc2VuZEJhdGNoRm4sIG1heEJhdGNoU2l6ZSA9IERFRkFVTFRfTUFYX1JFUVVFU1RfQkFUQ0hfU0laRSkge1xyXG4gICAgICAgIHRoaXMuc2VuZEJhdGNoRm4gPSBzZW5kQmF0Y2hGbjtcclxuICAgICAgICB0aGlzLm1heEJhdGNoU2l6ZSA9IG1heEJhdGNoU2l6ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcnJheSBvZiBlbnF1ZXVlZCByZXF1ZXN0cyBhbG9uZyB3aXRoIHRoZSBjb25zdHJ1Y3RlZCBwcm9taXNlIGhhbmRsZXJzIGZvclxyXG4gICAgICAgICAqIGVhY2ggcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaCA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnF1ZXVlcyB0aGUgcHJvdmlkZWQgcmVxdWVzdC4gVGhlIGJhdGNoIGlzIGltbWVkaWF0ZWx5IHNlbnQgaWYgdGhlIG1heGltdW1cclxuICAgICAqIGJhdGNoIHNpemUgaXMgcmVhY2hlZC4gT3RoZXJ3aXNlLCB0aGUgcmVxdWVzdCBpcyBlbnF1ZXVlZCBvbnRvIGEgYmF0Y2ggdGhhdFxyXG4gICAgICogaXMgc2VudCBhZnRlciAxMG1zLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlUmVxdWVzdChyZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5mbGlnaHRSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHJlamVjdDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2gucHVzaChpbmZsaWdodFJlcXVlc3QpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQmF0Y2gubGVuZ3RoID09PSB0aGlzLm1heEJhdGNoU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VuZCBiYXRjaCBpbW1lZGlhdGVseSBpZiB3ZSBhcmUgYXQgdGhlIG1heGltdW0gYmF0Y2ggc2l6ZS5cclxuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5zZW5kQmF0Y2hSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMucGVuZGluZ0JhdGNoVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGJhdGNoIGZvciBuZXh0IGV2ZW50IGxvb3AgKyBzaG9ydCBkdXJhdGlvblxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2hUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kQmF0Y2hSZXF1ZXN0KCksIERFRkFVTFRfUkVRVUVTVF9CQVRDSF9ERUxBWV9NUyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIHRoZSBjdXJyZW50bHkgcXVldWVkIGJhdGNoZXMgYW5kIHJlc2V0cyB0aGUgYmF0Y2ggYW5kIHRpbWVyLiBQcm9jZXNzZXNcclxuICAgICAqIHRoZSBiYXRjaGVkIHJlc3BvbnNlIHJlc3VsdHMgYmFjayB0byB0aGUgb3JpZ2luYWwgcHJvbWlzZXMuXHJcbiAgICAgKi9cclxuICAgIHNlbmRCYXRjaFJlcXVlc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGJhdGNoIGFuZCBjbGVhciBpdCwgc28gbmV3IHJlcXVlc3RzXHJcbiAgICAgICAgICAgIC8vIGdvIGludG8gdGhlIG5leHQgYmF0Y2hcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLnBlbmRpbmdCYXRjaDtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2ggPSBbXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0JhdGNoVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdCYXRjaFRpbWVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoVGltZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByZXF1ZXN0IGFzIGFuIGFycmF5IG9mIHJlcXVlc3RzXHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBiYXRjaC5tYXAoaW5mbGlnaHQgPT4gaW5mbGlnaHQucmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRCYXRjaEZuKHJlcXVlc3QpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIHJlc3VsdCwgZmVlZCBpdCB0byB0aGUgY29ycmVjdCBQcm9taXNlLCBkZXBlbmRpbmdcclxuICAgICAgICAgICAgICAgIC8vIG9uIHdoZXRoZXIgaXQgd2FzIGEgc3VjY2VzcyBvciBlcnJvclxyXG4gICAgICAgICAgICAgICAgYmF0Y2guZm9yRWFjaCgoaW5mbGlnaHRSZXF1ZXN0LCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSByZXN1bHRbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBwYXlsb2FkLmVycm9yLmNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSBwYXlsb2FkLmVycm9yLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUocGF5bG9hZC5yZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5mb3JFYWNoKGluZmxpZ2h0UmVxdWVzdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFNESydzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBvZiBldGhlcnMuanMncyAnQWxjaGVteVByb3ZpZGVyJy5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgaW5zdGFudGlhdGUgYW4gaW5zdGFuY2Ugb2ZcclxuICoge0BsaW5rIEFsY2hlbXl9IGFuZCBjYWxsIHtAbGluayBBbGNoZW15LmNvbmZpZy5nZXRQcm92aWRlcigpfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQWxjaGVteVByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJzLkpzb25ScGNQcm92aWRlciB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFQSSBLZXkgdG8gYSBzdHJpbmcuXHJcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gQWxjaGVteVByb3ZpZGVyLmdldEFwaUtleShjb25maWcuYXBpS2V5KTtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBvdXIgb3duIGNvbm5lY3Rpb24gaW5mbyB3aXRoIHRoZSBjb3JyZWN0IGVuZHBvaW50IFVSTHMuXHJcbiAgICAgICAgY29uc3QgYWxjaGVteU5ldHdvcmsgPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteU5ldHdvcmsoY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgIGxldCBjb25uZWN0aW9uID0gQWxjaGVteVByb3ZpZGVyLmdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyhhbGNoZW15TmV0d29yaywgYXBpS2V5LCAnaHR0cCcpO1xyXG4gICAgICAgIC8vIElmIGEgaGFyZGNvZGVkIHVybCB3YXMgc3BlY2lmaWVkIGluIHRoZSBjb25maWcsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlXHJcbiAgICAgICAgLy8gcHJvdmlkZWQgYXBpS2V5IG9yIG5ldHdvcmsuXHJcbiAgICAgICAgaWYgKGNvbmZpZy51cmwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uLnVybCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdCA9IGNvbmZpZy5tYXhSZXRyaWVzO1xyXG4gICAgICAgIC8vIEFkZCB1c2VyIHByb3ZpZGVkIG92ZXJyaWRlcyBpZiB0aGV5IGV4aXN0LlxyXG4gICAgICAgIGlmIChjb25maWcuY29ubmVjdGlvbkluZm9PdmVycmlkZXMpIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdGlvbiksIGNvbmZpZy5jb25uZWN0aW9uSW5mb092ZXJyaWRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQWxjaGVteSBuYW1lZCBuZXR3b3JrIGlucHV0IHRvIHRoZSBuZXR3b3JrIG5hbWVzIHVzZWQgYnlcclxuICAgICAgICAvLyBldGhlcnMuIFRoaXMgYWxsb3dzIHRoZSBwYXJlbnQgc3VwZXIgY29uc3RydWN0b3IgaW4gSnNvblJwY1Byb3ZpZGVyIHRvXHJcbiAgICAgICAgLy8gY29ycmVjdGx5IHNldCB0aGUgbmV0d29yay5cclxuICAgICAgICBjb25zdCBldGhlcnNOZXR3b3JrID0gaW5kZXguRXRoZXJzTmV0d29ya1thbGNoZW15TmV0d29ya107XHJcbiAgICAgICAgaWYgKCFldGhlcnNOZXR3b3JrKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbmV0d29yazogJHthbGNoZW15TmV0d29ya31gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgZXRoZXJzTmV0d29yayk7XHJcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xyXG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IGNvbmZpZy5tYXhSZXRyaWVzO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hSZXF1ZXN0cyA9IGNvbmZpZy5iYXRjaFJlcXVlc3RzO1xyXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgaW5kaXZpZHVhbCBoZWFkZXJzIHdoZW4gY2FsbGluZyBiYXRjaFxyXG4gICAgICAgIGNvbnN0IGJhdGNoZXJDb25uZWN0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24pLCB7IGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uLmhlYWRlcnMpLCB7ICdBbGNoZW15LUV0aGVycy1TZGstTWV0aG9kJzogJ2JhdGNoU2VuZCcgfSkgfSk7XHJcbiAgICAgICAgY29uc3Qgc2VuZEJhdGNoRm4gPSAocmVxdWVzdHMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHdlYi5mZXRjaEpzb24oYmF0Y2hlckNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3RzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmJhdGNoZXIgPSBuZXcgUmVxdWVzdEJhdGNoZXIoc2VuZEJhdGNoRm4pO1xyXG4gICAgICAgIHRoaXMubW9kaWZ5Rm9ybWF0dGVyKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYFVybEpzb25ScGNQcm92aWRlci5nZXRBcGlLZXlgIG1ldGhvZCBhcyBpbXBsZW1lbnRlZCBieVxyXG4gICAgICogZXRoZXJzLmpzLiBSZXR1cm5zIHRoZSBBUEkga2V5IGZvciBhbiBBbGNoZW15IHByb3ZpZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KSB7XHJcbiAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleC5ERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwaUtleSAmJiB0eXBlb2YgYXBpS2V5ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXBpS2V5ICcke2FwaUtleX0nIHByb3ZpZGVkLiBhcGlLZXkgbXVzdCBiZSBhIHN0cmluZy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFwaUtleTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBgQmFzZVByb3ZpZGVyLmdldE5ldHdvcmtgIG1ldGhvZCBhcyBpbXBsZW1lbnRlZCBieSBldGhlcnMuanMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBvdmVycmlkZSBhbGxvd3MgdGhlIFNESyB0byBzZXQgdGhlIHByb3ZpZGVyJ3MgbmV0d29yayB0byB2YWx1ZXMgbm90XHJcbiAgICAgKiB5ZXQgc3VwcG9ydGVkIGJ5IGV0aGVycy5qcy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0TmV0d29yayhuZXR3b3JrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXR3b3JrID09PSAnc3RyaW5nJyAmJiBuZXR3b3JrIGluIGluZGV4LkN1c3RvbU5ldHdvcmtzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleC5DdXN0b21OZXR3b3Jrc1tuZXR3b3JrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgc3RhbmRhcmQgZXRoZXJzLmpzIGdldE5ldHdvcmsgbWV0aG9kIGZvciBvdGhlciBuZXR3b3Jrcy5cclxuICAgICAgICByZXR1cm4gbmV0d29ya3MuZ2V0TmV0d29yayhuZXR3b3JrKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGBOZXR3b3JraXNoYCBpbnB1dCB0byB0aGUgbmV0d29yayBlbnVtIHVzZWQgYnkgQWxjaGVteS5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEFsY2hlbXlOZXR3b3JrKG5ldHdvcmspIHtcclxuICAgICAgICBpZiAobmV0d29yayA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleC5ERUZBVUxUX05FVFdPUks7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgbmV0d29yayA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5ldHdvcmsgJyR7bmV0d29ya30nIHByb3ZpZGVkLiBOZXR3b3JrIG11c3QgYmUgYSBzdHJpbmcuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEd1YXJhbnRlZWQgdGhhdCBgdHlwZW9mIG5ldHdvcmsgPT09ICdzdHJpbmdgLlxyXG4gICAgICAgIGNvbnN0IGlzVmFsaWROZXR3b3JrID0gT2JqZWN0LnZhbHVlcyhpbmRleC5OZXR3b3JrKS5pbmNsdWRlcyhuZXR3b3JrKTtcclxuICAgICAgICBpZiAoIWlzVmFsaWROZXR3b3JrKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXR3b3JrICcke25ldHdvcmt9JyBwcm92aWRlZC4gTmV0d29yayBtdXN0IGJlIG9uZSBvZjogYCArXHJcbiAgICAgICAgICAgICAgICBgJHtPYmplY3QudmFsdWVzKGluZGV4Lk5ldHdvcmspLmpvaW4oJywgJyl9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV0d29yaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHtAbGluayBDb25uZWN0aW9uSW5mb30gb2JqZWN0IGNvbXBhdGlibGUgd2l0aCBldGhlcnMgdGhhdCBjb250YWluc1xyXG4gICAgICogdGhlIGNvcnJlY3QgVVJMcyBmb3IgQWxjaGVteS5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyhuZXR3b3JrLCBhcGlLZXksIHR5cGUpIHtcclxuICAgICAgICBjb25zdCB1cmwgPSB0eXBlID09PSAnaHR0cCdcclxuICAgICAgICAgICAgPyBpbmRleC5nZXRBbGNoZW15SHR0cFVybChuZXR3b3JrLCBhcGlLZXkpXHJcbiAgICAgICAgICAgIDogaW5kZXguZ2V0QWxjaGVteVdzVXJsKG5ldHdvcmssIGFwaUtleSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaGVhZGVyczogaW5kZXguSVNfQlJPV1NFUlxyXG4gICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ0FsY2hlbXktRXRoZXJzLVNkay1WZXJzaW9uJzogaW5kZXguVkVSU0lPTlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ0FsY2hlbXktRXRoZXJzLVNkay1WZXJzaW9uJzogaW5kZXguVkVSU0lPTixcclxuICAgICAgICAgICAgICAgICAgICAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhbGxvd0d6aXA6IHRydWUsXHJcbiAgICAgICAgICAgIHVybFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgbWV0aG9kIGluIGV0aGVycy5qcydzIGBTdGF0aWNKc29uUnBjUHJvdmlkZXJgIGNsYXNzLiBUaGlzXHJcbiAgICAgKiBtZXRob2QgaXMgY2FsbGVkIHdoZW4gY2FsbGluZyBtZXRob2RzIG9uIHRoZSBwYXJlbnQgY2xhc3MgYEJhc2VQcm92aWRlcmAuXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGRldGVjdE5ldHdvcmsoKSB7XHJcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgICAgICAgIGRldGVjdE5ldHdvcms6IHsgZ2V0OiAoKSA9PiBzdXBlci5kZXRlY3ROZXR3b3JrIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgbmV0d29yayA9IHRoaXMubmV0d29yaztcclxuICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbmV0d29yayA9IHlpZWxkIF9zdXBlci5kZXRlY3ROZXR3b3JrLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5ldHdvcmsgZGV0ZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9zdGFydFBlbmRpbmcoKSB7XHJcbiAgICAgICAgaW5kZXgubG9nV2FybignV0FSTklORzogQWxjaGVteSBQcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHBlbmRpbmcgZmlsdGVycycpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGV0aGVyJ3MgYGlzQ29tbXVuaXR5UmVzb3VyY2UoKWAgbWV0aG9kLiBSZXR1cm5zIHRydWUgaWYgdGhlXHJcbiAgICAgKiBjdXJyZW50IGFwaSBrZXkgaXMgdGhlIGRlZmF1bHQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwaUtleSA9PT0gaW5kZXguREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYmFzZSB7QGxpbmsgSnNvblJwY1Byb3ZpZGVyLnNlbmR9IG1ldGhvZCB0byBpbXBsZW1lbnQgY3VzdG9tXHJcbiAgICAgKiBsb2dpYyBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byBBbGNoZW15LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIG1ldGhvZCBuYW1lIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogQWRkIGhlYWRlcnMgZm9yIGBwZXJmb3JtKClgIG92ZXJyaWRlLlxyXG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kKG1ldGhvZCwgcGFyYW1zLCAnc2VuZCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBKc29uUnBjUHJvdmlkZXIuc2VuZCgpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgY3VzdG9tIGhlYWRlcnNcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3NlbmQobWV0aG9kLCBwYXJhbXMsIG1ldGhvZE5hbWUpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRJZCsrLFxyXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gU1RBUlQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24pO1xyXG4gICAgICAgIGNvbm5lY3Rpb24uaGVhZGVyc1snQWxjaGVteS1FdGhlcnMtU2RrLU1ldGhvZCddID0gbWV0aG9kTmFtZTtcclxuICAgICAgICBpZiAodGhpcy5iYXRjaFJlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhdGNoZXIuZW5xdWV1ZVJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVORCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgdGhpcy5lbWl0KCdkZWJ1ZycsIHtcclxuICAgICAgICAgICAgYWN0aW9uOiAncmVxdWVzdCcsXHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IGluZGV4LmRlZXBDb3B5KHJlcXVlc3QpLFxyXG4gICAgICAgICAgICBwcm92aWRlcjogdGhpc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdlIGNhbiBleHBhbmQgdGhpcyBpbiB0aGUgZnV0dXJlIHRvIGFueSBjYWxsLCBidXQgZm9yIG5vdyB0aGVzZVxyXG4gICAgICAgIC8vIGFyZSB0aGUgYmlnZ2VzdCB3aW5zIGFuZCBkbyBub3QgcmVxdWlyZSBhbnkgc2VyaWFsaXppbmcgcGFyYW1ldGVycy5cclxuICAgICAgICBjb25zdCBjYWNoZSA9IFsnZXRoX2NoYWluSWQnLCAnZXRoX2Jsb2NrTnVtYmVyJ10uaW5kZXhPZihtZXRob2QpID49IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlICYmIHRoaXMuX2NhY2hlW21ldGhvZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW21ldGhvZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHdlYi5mZXRjaEpzb24odGhpcy5jb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSwgZ2V0UmVzdWx0KS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVidWcnLCB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdyZXNwb25zZScsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcclxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sIGVycm9yID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkZWJ1ZycsIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3Jlc3BvbnNlJyxcclxuICAgICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBDYWNoZSB0aGUgZmV0Y2gsIGJ1dCBjbGVhciBpdCBvbiB0aGUgbmV4dCBldmVudCBsb29wXHJcbiAgICAgICAgaWYgKGNhY2hlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlW21ldGhvZF0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIFRoaXMgaXMgZG9uZSBieSBldGhlcnMuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gbnVsbDtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYmFzZSBgRm9ybWF0dGVyYCBjbGFzcyBpbmhlcml0ZWQgZnJvbSBldGhlcnMgdG8gc3VwcG9ydFxyXG4gICAgICogcmV0dXJuaW5nIGN1c3RvbSBmaWVsZHMgaW4gRXRoZXJzIHJlc3BvbnNlIHR5cGVzLlxyXG4gICAgICpcclxuICAgICAqIEZvciBjb250ZXh0LCBldGhlcnMgaGFzIGEgYEZvcm1hdHRlcmAgY2xhc3MgdGhhdCBpcyB1c2VkIHRvIGZvcm1hdCB0aGVcclxuICAgICAqIHJlc3BvbnNlIGZyb20gYSBKU09OLVJQQyByZXF1ZXN0LiBBbnkgZmllbGRzIHRoYXQgYXJlIG5vdCBkZWZpbmVkIGluIHRoZVxyXG4gICAgICogYEZvcm1hdHRlcmAgY2xhc3MgYXJlIHJlbW92ZWQgZnJvbSB0aGUgcmV0dXJuZWQgcmVzcG9uc2UuIEJ5IG1vZGlmeWluZyB0aGVcclxuICAgICAqIGBGb3JtYXR0ZXJgIGNsYXNzIGluIHRoaXMgbWV0aG9kLCB3ZSBjYW4gYWRkIHN1cHBvcnQgZm9yIGZpZWxkcyB0aGF0IGFyZVxyXG4gICAgICogbm90IGRlZmluZWQgaW4gZXRoZXJzLlxyXG4gICAgICovXHJcbiAgICBtb2RpZnlGb3JtYXR0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0c1sncmVjZWlwdExvZyddWydyZW1vdmVkJ10gPSB2YWwgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRE8gTk9UIE1PRElGWS5cclxuICpcclxuICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3NcclxuICogYEBldGhlcnNwcm9qZWN0L3dlYi9zcmMudHMvaW5kZXgudHNgLiBVc2VkIHRvIHN1cHBvcnRcclxuICoge0BsaW5rIEFsY2hlbXlQcm92aWRlci5fc2VuZH0sIHdoaWNoIGlzIGFsc28gY29waWVkIG92ZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZXN1bHQocGF5bG9hZCkge1xyXG4gICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIGVycm9yLmNvZGUgPSBwYXlsb2FkLmVycm9yLmNvZGU7XHJcbiAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXlsb2FkLnJlc3VsdDtcclxufVxuXG5leHBvcnRzLkFsY2hlbXlQcm92aWRlciA9IEFsY2hlbXlQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsY2hlbXktcHJvdmlkZXItYjAwNmE0YmMuanMubWFwXG4iXSwibmFtZXMiOlsiaW5kZXgiLCJyZXF1aXJlIiwibmV0d29ya3MiLCJwcm92aWRlcnMiLCJ3ZWIiLCJERUZBVUxUX01BWF9SRVFVRVNUX0JBVENIX1NJWkUiLCJERUZBVUxUX1JFUVVFU1RfQkFUQ0hfREVMQVlfTVMiLCJSZXF1ZXN0QmF0Y2hlciIsImNvbnN0cnVjdG9yIiwic2VuZEJhdGNoRm4iLCJtYXhCYXRjaFNpemUiLCJwZW5kaW5nQmF0Y2giLCJlbnF1ZXVlUmVxdWVzdCIsInJlcXVlc3QiLCJfX2F3YWl0ZXIiLCJpbmZsaWdodFJlcXVlc3QiLCJyZXNvbHZlIiwidW5kZWZpbmVkIiwicmVqZWN0IiwicHJvbWlzZSIsIlByb21pc2UiLCJwdXNoIiwibGVuZ3RoIiwic2VuZEJhdGNoUmVxdWVzdCIsInBlbmRpbmdCYXRjaFRpbWVyIiwic2V0VGltZW91dCIsImJhdGNoIiwiY2xlYXJUaW1lb3V0IiwibWFwIiwiaW5mbGlnaHQiLCJ0aGVuIiwicmVzdWx0IiwiZm9yRWFjaCIsInBheWxvYWQiLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsImNvZGUiLCJkYXRhIiwiQWxjaGVteVByb3ZpZGVyIiwiSnNvblJwY1Byb3ZpZGVyIiwiY29uZmlnIiwiYXBpS2V5IiwiZ2V0QXBpS2V5IiwiYWxjaGVteU5ldHdvcmsiLCJnZXRBbGNoZW15TmV0d29yayIsIm5ldHdvcmsiLCJjb25uZWN0aW9uIiwiZ2V0QWxjaGVteUNvbm5lY3Rpb25JbmZvIiwidXJsIiwidGhyb3R0bGVMaW1pdCIsIm1heFJldHJpZXMiLCJjb25uZWN0aW9uSW5mb092ZXJyaWRlcyIsIk9iamVjdCIsImFzc2lnbiIsImV0aGVyc05ldHdvcmsiLCJFdGhlcnNOZXR3b3JrIiwiYmF0Y2hSZXF1ZXN0cyIsImJhdGNoZXJDb25uZWN0aW9uIiwiaGVhZGVycyIsInJlcXVlc3RzIiwiZmV0Y2hKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsImJhdGNoZXIiLCJtb2RpZnlGb3JtYXR0ZXIiLCJERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSIsImdldE5ldHdvcmsiLCJDdXN0b21OZXR3b3JrcyIsIkRFRkFVTFRfTkVUV09SSyIsImlzVmFsaWROZXR3b3JrIiwidmFsdWVzIiwiTmV0d29yayIsImluY2x1ZGVzIiwiam9pbiIsInR5cGUiLCJnZXRBbGNoZW15SHR0cFVybCIsImdldEFsY2hlbXlXc1VybCIsIklTX0JST1dTRVIiLCJWRVJTSU9OIiwiYWxsb3dHemlwIiwiZGV0ZWN0TmV0d29yayIsIl9zdXBlciIsImNyZWF0ZSIsImdldCIsImNhbGwiLCJfc3RhcnRQZW5kaW5nIiwibG9nV2FybiIsImlzQ29tbXVuaXR5UmVzb3VyY2UiLCJzZW5kIiwibWV0aG9kIiwicGFyYW1zIiwiX3NlbmQiLCJtZXRob2ROYW1lIiwiaWQiLCJfbmV4dElkIiwianNvbnJwYyIsImVtaXQiLCJhY3Rpb24iLCJkZWVwQ29weSIsInByb3ZpZGVyIiwiY2FjaGUiLCJpbmRleE9mIiwiX2NhY2hlIiwiZ2V0UmVzdWx0IiwicmVzcG9uc2UiLCJmb3JtYXR0ZXIiLCJmb3JtYXRzIiwidmFsIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-provider-b006a4bc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-2dafa9e4.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-2dafa9e4.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar index = __webpack_require__(/*! ./index-3873e7b8.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/index-3873e7b8.js\");\nvar SturdyWebSocket = __webpack_require__(/*! sturdy-websocket */ \"(ssr)/./node_modules/sturdy-websocket/dist/index.js\");\nvar bignumber = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\nvar networks = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/./node_modules/@ethersproject/networks/lib.esm/index.js\");\nvar providers = __webpack_require__(/*! @ethersproject/providers */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/index.js\");\nvar alchemyProvider = __webpack_require__(/*! ./alchemy-provider-b006a4bc.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-provider-b006a4bc.js\");\n__webpack_require__(/*! ./api/utils */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\n__webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\");\n__webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/./node_modules/@ethersproject/wallet/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/./node_modules/@ethersproject/contracts/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/@ethersproject/web/lib.esm/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar SturdyWebSocket__default = /*#__PURE__*/ _interopDefaultLegacy(SturdyWebSocket);\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */ const MAX_BACKFILL_BLOCKS = 120;\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */ class WebsocketBackfiller {\n    constructor(provider){\n        this.provider = provider;\n        // TODO: Use HTTP provider to do backfill.\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n    }\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */ getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            throwIfCancelled(isCancelled);\n            const toBlockNumber = yield this.getBlockNumber();\n            throwIfCancelled(isCancelled);\n            // If there are no previous heads to fetch, return new heads since\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n            if (previousHeads.length === 0) {\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n            }\n            // If the last emitted event is too far back in the past, there's no need\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n            // new heads.\n            const lastSeenBlockNumber = index.fromHex(previousHeads[previousHeads.length - 1].number);\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n            if (lastSeenBlockNumber <= minBlockNumber) {\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n            }\n            // To capture all `newHeads` events, return all head events from the last\n            // seen block number to current + any of the previous heads that were re-orged.\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\n            throwIfCancelled(isCancelled);\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\n            throwIfCancelled(isCancelled);\n            return [\n                ...reorgHeads,\n                ...intermediateHeads\n            ];\n        });\n    }\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */ getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            throwIfCancelled(isCancelled);\n            const toBlockNumber = yield this.getBlockNumber();\n            throwIfCancelled(isCancelled);\n            // If there are no previous logs to fetch, return new logs since\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n            if (previousLogs.length === 0) {\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n            }\n            // If the last emitted log is too far back in the past, there's no need\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n            // worth of logs.\n            const lastSeenBlockNumber = index.fromHex(previousLogs[previousLogs.length - 1].blockNumber);\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n            if (lastSeenBlockNumber < minBlockNumber) {\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n            }\n            // Return all log events that have happened along with log events that have\n            // been removed due to a chain reorg.\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\n            throwIfCancelled(isCancelled);\n            // All previous logs with a block number greater than the common ancestor\n            // were part of a re-org, so mark them as such.\n            const removedLogs = previousLogs.filter((log)=>index.fromHex(log.blockNumber) > commonAncestor.blockNumber).map((log)=>Object.assign(Object.assign({}, log), {\n                    removed: true\n                }));\n            // If no common ancestor was found, start backfill from the oldest log's\n            // block number.\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY ? index.fromHex(previousLogs[0].blockNumber) : commonAncestor.blockNumber;\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\n            // De-dupe any logs that were already emitted.\n            addedLogs = addedLogs.filter((log)=>log && (index.fromHex(log.blockNumber) > commonAncestor.blockNumber || index.fromHex(log.logIndex) > commonAncestor.logIndex));\n            throwIfCancelled(isCancelled);\n            return [\n                ...removedLogs,\n                ...addedLogs\n            ];\n        });\n    }\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */ setMaxBackfillBlock(newMax) {\n        this.maxBackfillBlocks = newMax;\n    }\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */ getBlockNumber() {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const blockNumberHex = yield this.provider.send(\"eth_blockNumber\");\n            return index.fromHex(blockNumberHex);\n        });\n    }\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */ getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            if (fromBlockInclusive >= toBlockExclusive) {\n                return [];\n            }\n            const batchParts = [];\n            for(let i = fromBlockInclusive; i < toBlockExclusive; i++){\n                batchParts.push({\n                    method: \"eth_getBlockByNumber\",\n                    params: [\n                        index.toHex(i),\n                        false\n                    ]\n                });\n            }\n            // TODO: handle errors\n            const blockHeads = yield this.provider.sendBatch(batchParts);\n            return blockHeads.map(toNewHeadsEvent);\n        });\n    }\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */ getReorgHeads(isCancelled, previousHeads) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const result = [];\n            // Iterate from the most recent head backwards in order to find the first\n            // block that was part of a re-org.\n            for(let i = previousHeads.length - 1; i >= 0; i--){\n                const oldEvent = previousHeads[i];\n                const blockHead = yield this.getBlockByNumber(index.fromHex(oldEvent.number));\n                throwIfCancelled(isCancelled);\n                // If the hashes match, then current head in the iteration was not re-orged.\n                if (oldEvent.hash === blockHead.hash) {\n                    break;\n                }\n                result.push(toNewHeadsEvent(blockHead));\n            }\n            return result.reverse();\n        });\n    }\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */ getBlockByNumber(blockNumber) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            return this.provider.send(\"eth_getBlockByNumber\", [\n                index.toHex(blockNumber),\n                false\n            ]);\n        });\n    }\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */ getCommonAncestor(isCancelled, previousLogs) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            // Iterate from the most recent head backwards in order to find the first\n            // block that was part of a re-org.\n            let blockHead = yield this.getBlockByNumber(index.fromHex(previousLogs[previousLogs.length - 1].blockNumber));\n            throwIfCancelled(isCancelled);\n            for(let i = previousLogs.length - 1; i >= 0; i--){\n                const oldLog = previousLogs[i];\n                // Ensure that updated blocks are fetched every time the log's block number\n                // changes.\n                if (oldLog.blockNumber !== blockHead.number) {\n                    blockHead = yield this.getBlockByNumber(index.fromHex(oldLog.blockNumber));\n                }\n                // Since logs are ordered in ascending order, the first log that matches\n                // the hash should be the largest logIndex.\n                if (oldLog.blockHash === blockHead.hash) {\n                    return {\n                        blockNumber: index.fromHex(oldLog.blockNumber),\n                        logIndex: index.fromHex(oldLog.logIndex)\n                    };\n                }\n            }\n            return {\n                blockNumber: Number.NEGATIVE_INFINITY,\n                logIndex: Number.NEGATIVE_INFINITY\n            };\n        });\n    }\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            if (fromBlockInclusive >= toBlockExclusive) {\n                return [];\n            }\n            const rangeFilter = Object.assign(Object.assign({}, filter), {\n                fromBlock: index.toHex(fromBlockInclusive),\n                toBlock: index.toHex(toBlockExclusive - 1)\n            });\n            return this.provider.send(\"eth_getLogs\", [\n                rangeFilter\n            ]);\n        });\n    }\n}\nfunction toNewHeadsEvent(head) {\n    const result = Object.assign({}, head);\n    delete result.totalDifficulty;\n    delete result.transactions;\n    delete result.uncles;\n    return result;\n}\nfunction dedupeNewHeads(events) {\n    return dedupe(events, (event)=>event.hash);\n}\nfunction dedupeLogs(events) {\n    return dedupe(events, (event)=>`${event.blockHash}/${event.logIndex}`);\n}\nfunction dedupe(items, getKey) {\n    const keysSeen = new Set();\n    const result = [];\n    items.forEach((item)=>{\n        const key = getKey(item);\n        if (!keysSeen.has(key)) {\n            keysSeen.add(key);\n            result.push(item);\n        }\n    });\n    return result;\n}\nconst CANCELLED = new Error(\"Cancelled\");\nfunction throwIfCancelled(isCancelled) {\n    if (isCancelled()) {\n        throw CANCELLED;\n    }\n}\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */ const RETAINED_EVENT_BLOCK_COUNT = 10;\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */ class AlchemyWebSocketProvider extends providers.WebSocketProvider {\n    /** @internal */ constructor(config, wsConstructor){\n        var _a;\n        // Normalize the API Key to a string.\n        const apiKey = alchemyProvider.AlchemyProvider.getApiKey(config.apiKey);\n        // Generate our own connection info with the correct endpoint URLs.\n        const alchemyNetwork = alchemyProvider.AlchemyProvider.getAlchemyNetwork(config.network);\n        const connection = alchemyProvider.AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, \"wss\");\n        const protocol = `alchemy-sdk-${index.VERSION}`;\n        // Use the provided config URL override if it exists, otherwise use the created one.\n        const ws = new SturdyWebSocket__default[\"default\"]((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\n        });\n        // Normalize the Alchemy named network input to the network names used by\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\n        // correctly set the network.\n        const ethersNetwork = index.EthersNetwork[alchemyNetwork];\n        super(ws, ethersNetwork !== null && ethersNetwork !== void 0 ? ethersNetwork : undefined);\n        this._events = [];\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\n        // create new ones to replace them, but we want to create the illusion that\n        // the original subscriptions persist. Thus, maintain a mapping from the\n        // \"virtual\" subscription ids which are visible to the consumer to the\n        // \"physical\" subscription ids of the actual connections. This terminology is\n        // borrowed from virtual and physical memory, which has a similar mapping.\n        /** @internal */ this.virtualSubscriptionsById = new Map();\n        /** @internal */ this.virtualIdsByPhysicalId = new Map();\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.handleMessage = (event)=>{\n            const message = JSON.parse(event.data);\n            if (!isSubscriptionEvent(message)) {\n                return;\n            }\n            const physicalId = message.params.subscription;\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n            if (!virtualId) {\n                return;\n            }\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\n            if (subscription.method !== \"eth_subscribe\") {\n                return;\n            }\n            switch(subscription.params[0]){\n                case \"newHeads\":\n                    {\n                        const newHeadsSubscription = subscription;\n                        const newHeadsMessage = message;\n                        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n                        const { result } = newHeadsMessage.params;\n                        if (isBackfilling) {\n                            addToNewHeadsEventsBuffer(backfillBuffer, result);\n                        } else if (physicalId !== virtualId) {\n                            // In the case of a re-opened subscription, ethers will not emit the\n                            // event, so the SDK has to.\n                            this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n                        } else {\n                            // Ethers subscription mapping will emit the event, just store it.\n                            this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n                        }\n                        break;\n                    }\n                case \"logs\":\n                    {\n                        const logsSubscription = subscription;\n                        const logsMessage = message;\n                        const { isBackfilling, backfillBuffer } = logsSubscription;\n                        const { result } = logsMessage.params;\n                        if (isBackfilling) {\n                            addToLogsEventsBuffer(backfillBuffer, result);\n                        } else if (virtualId !== physicalId) {\n                            this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n                        } else {\n                            this.rememberEvent(virtualId, result, getLogsBlockNumber);\n                        }\n                        break;\n                    }\n                default:\n                    if (physicalId !== virtualId) {\n                        // In the case of a re-opened subscription, ethers will not emit the\n                        // event, so the SDK has to.\n                        const { result } = message.params;\n                        this.emitEvent(virtualId, result);\n                    }\n            }\n        };\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.handleReopen = ()=>{\n            this.virtualIdsByPhysicalId.clear();\n            const { cancel, isCancelled } = makeCancelToken();\n            this.cancelBackfill = cancel;\n            for (const subscription of this.virtualSubscriptionsById.values()){\n                void (()=>index.__awaiter(this, void 0, void 0, function*() {\n                        try {\n                            yield this.resubscribeAndBackfill(isCancelled, subscription);\n                        } catch (error) {\n                            if (!isCancelled()) {\n                                console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\n                            }\n                        }\n                    }))();\n            }\n            this.startHeartbeat();\n        };\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.stopHeartbeatAndBackfill = ()=>{\n            if (this.heartbeatIntervalId != null) {\n                clearInterval(this.heartbeatIntervalId);\n                this.heartbeatIntervalId = undefined;\n            }\n            this.cancelBackfill();\n        };\n        this.apiKey = apiKey;\n        // Start heartbeat and backfiller for the websocket connection.\n        this.backfiller = new WebsocketBackfiller(this);\n        this.addSocketListeners();\n        this.startHeartbeat();\n        this.cancelBackfill = index.noop;\n    }\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ static getNetwork(network) {\n        if (typeof network === \"string\" && network in index.CustomNetworks) {\n            return index.CustomNetworks[network];\n        }\n        // Call the standard ethers.js getNetwork method for other networks.\n        return networks.getNetwork(network);\n    }\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */ // TODO: Override `Listener` type to get type autocompletions.\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */ // TODO: Override `Listener` type to get type autocompletions.\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */ off(eventName, listener) {\n        if (index.isAlchemyEvent(eventName)) {\n            return this._off(eventName, listener);\n        } else {\n            return super.off(eventName, listener);\n        }\n    }\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */ removeAllListeners(eventName) {\n        if (eventName !== undefined && index.isAlchemyEvent(eventName)) {\n            return this._removeAllListeners(eventName);\n        } else {\n            return super.removeAllListeners(eventName);\n        }\n    }\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */ listenerCount(eventName) {\n        if (eventName !== undefined && index.isAlchemyEvent(eventName)) {\n            return this._listenerCount(eventName);\n        } else {\n            return super.listenerCount(eventName);\n        }\n    }\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */ listeners(eventName) {\n        if (eventName !== undefined && index.isAlchemyEvent(eventName)) {\n            return this._listeners(eventName);\n        } else {\n            return super.listeners(eventName);\n        }\n    }\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ _addEventListener(eventName, listener, once) {\n        if (index.isAlchemyEvent(eventName)) {\n            index.verifyAlchemyEventName(eventName);\n            const event = new index.EthersEvent(index.getAlchemyEventTag(eventName), listener, once);\n            this._events.push(event);\n            this._startEvent(event);\n            return this;\n        } else {\n            return super._addEventListener(eventName, listener, once);\n        }\n    }\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */ _startEvent(event) {\n        // Check if the event type is a custom Alchemy subscription.\n        const customLogicTypes = [\n            ...index.ALCHEMY_EVENT_TYPES,\n            \"block\",\n            \"filter\"\n        ];\n        if (customLogicTypes.includes(event.type)) {\n            this.customStartEvent(event);\n        } else {\n            super._startEvent(event);\n        }\n    }\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ _subscribe(tag, param, processFunc, event) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            let subIdPromise = this._subIds[tag];\n            // BEGIN MODIFIED CODE\n            const startingBlockNumber = yield this.getBlockNumber();\n            // END MODIFIED CODE\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param)=>{\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            // BEGIN MODIFIED CODE\n            const resolvedParams = yield Promise.all(param);\n            this.virtualSubscriptionsById.set(subId, {\n                event: event,\n                method: \"eth_subscribe\",\n                params: resolvedParams,\n                startingBlockNumber,\n                virtualId: subId,\n                physicalId: subId,\n                sentEvents: [],\n                isBackfilling: false,\n                backfillBuffer: []\n            });\n            this.virtualIdsByPhysicalId.set(subId, subId);\n            // END MODIFIED CODE\n            this._subs[subId] = {\n                tag,\n                processFunc\n            };\n        });\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ emit(eventName, ...args) {\n        if (index.isAlchemyEvent(eventName)) {\n            let result = false;\n            const stopped = [];\n            // This line is the only modified line from the original method.\n            const eventTag = index.getAlchemyEventTag(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                setTimeout(()=>{\n                    event.listener.apply(this, args);\n                }, 0);\n                result = true;\n                if (event.once) {\n                    stopped.push(event);\n                    return false;\n                }\n                return true;\n            });\n            stopped.forEach((event)=>{\n                this._stopEvent(event);\n            });\n            return result;\n        } else {\n            return super.emit(eventName, ...args);\n        }\n    }\n    /** @internal */ sendBatch(parts) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            let nextId = 0;\n            const payload = parts.map(({ method, params })=>{\n                return {\n                    method,\n                    params,\n                    jsonrpc: \"2.0\",\n                    id: `alchemy-sdk:${nextId++}`\n                };\n            });\n            return this.sendBatchConcurrently(payload);\n        });\n    }\n    /** @override */ destroy() {\n        this.removeSocketListeners();\n        this.stopHeartbeatAndBackfill();\n        return super.destroy();\n    }\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */ isCommunityResource() {\n        return this.apiKey === index.DEFAULT_ALCHEMY_API_KEY;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */ _stopEvent(event) {\n        let tag = event.tag;\n        // START MODIFIED CODE\n        if (index.ALCHEMY_EVENT_TYPES.includes(event.type)) {\n            // There are remaining pending transaction listeners.\n            if (this._events.filter((e)=>index.ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\n                return;\n            }\n        // END MODIFIED CODE\n        } else if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e)=>e.type === \"tx\").length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        void subId.then((subId)=>{\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            void this.send(\"eth_unsubscribe\", [\n                subId\n            ]);\n        });\n    }\n    /** @internal */ addSocketListeners() {\n        this._websocket.addEventListener(\"message\", this.handleMessage);\n        this._websocket.addEventListener(\"reopen\", this.handleReopen);\n        this._websocket.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n    }\n    /** @internal */ removeSocketListeners() {\n        this._websocket.removeEventListener(\"message\", this.handleMessage);\n        this._websocket.removeEventListener(\"reopen\", this.handleReopen);\n        this._websocket.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n    }\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */ resubscribeAndBackfill(isCancelled, subscription) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\n            subscription.isBackfilling = true;\n            backfillBuffer.length = 0;\n            try {\n                const physicalId = yield this.send(method, params);\n                throwIfCancelled(isCancelled);\n                subscription.physicalId = physicalId;\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n                switch(params[0]){\n                    case \"newHeads\":\n                        {\n                            const backfillEvents = yield withBackoffRetries(()=>withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, ()=>!isCancelled());\n                            throwIfCancelled(isCancelled);\n                            const events = dedupeNewHeads([\n                                ...backfillEvents,\n                                ...backfillBuffer\n                            ]);\n                            events.forEach((event)=>this.emitNewHeadsEvent(virtualId, event));\n                            break;\n                        }\n                    case \"logs\":\n                        {\n                            const filter = params[1] || {};\n                            const backfillEvents = yield withBackoffRetries(()=>withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, ()=>!isCancelled());\n                            throwIfCancelled(isCancelled);\n                            const events = dedupeLogs([\n                                ...backfillEvents,\n                                ...backfillBuffer\n                            ]);\n                            events.forEach((event)=>this.emitLogsEvent(virtualId, event));\n                            break;\n                        }\n                    default:\n                        break;\n                }\n            } finally{\n                subscription.isBackfilling = false;\n                backfillBuffer.length = 0;\n            }\n        });\n    }\n    /** @internal */ emitNewHeadsEvent(virtualId, result) {\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n    }\n    /** @internal */ emitLogsEvent(virtualId, result) {\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n    }\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */ emitAndRememberEvent(virtualId, result, getBlockNumber) {\n        this.rememberEvent(virtualId, result, getBlockNumber);\n        this.emitEvent(virtualId, result);\n    }\n    emitEvent(virtualId, result) {\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\n        if (!subscription) {\n            return;\n        }\n        this.emitGenericEvent(subscription, result);\n    }\n    /** @internal */ rememberEvent(virtualId, result, getBlockNumber) {\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\n        if (!subscription) {\n            return;\n        }\n        // Web3 modifies these event objects once we pass them on (changing hex\n        // numbers to numbers). We want the original event, so make a defensive\n        // copy.\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\n    }\n    /** @internal */ emitGenericEvent(subscription, result) {\n        const emitFunction = this.emitProcessFn(subscription.event);\n        emitFunction(result);\n    }\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */ startHeartbeat() {\n        if (this.heartbeatIntervalId != null) {\n            return;\n        }\n        this.heartbeatIntervalId = setInterval(()=>index.__awaiter(this, void 0, void 0, function*() {\n                try {\n                    yield withTimeout(this.send(\"net_version\"), HEARTBEAT_WAIT_TIME);\n                } catch (_a) {\n                    this._websocket.reconnect();\n                }\n            }), HEARTBEAT_INTERVAL);\n    }\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */ // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n    // TODO(errors): Use allSettled() once we have more error handling.\n    sendBatchConcurrently(payload) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            return Promise.all(payload.map((req)=>this.send(req.method, req.params)));\n        });\n    }\n    /** @internal */ customStartEvent(event) {\n        if (event.type === index.ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n            const { fromAddress, toAddress, hashesOnly } = event;\n            void this._subscribe(event.tag, [\n                index.AlchemySubscription.PENDING_TRANSACTIONS,\n                {\n                    fromAddress,\n                    toAddress,\n                    hashesOnly\n                }\n            ], this.emitProcessFn(event), event);\n        } else if (event.type === index.ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n            const { addresses, includeRemoved, hashesOnly } = event;\n            void this._subscribe(event.tag, [\n                index.AlchemySubscription.MINED_TRANSACTIONS,\n                {\n                    addresses,\n                    includeRemoved,\n                    hashesOnly\n                }\n            ], this.emitProcessFn(event), event);\n        } else if (event.type === \"block\") {\n            void this._subscribe(\"block\", [\n                \"newHeads\"\n            ], this.emitProcessFn(event), event);\n        } else if (event.type === \"filter\") {\n            void this._subscribe(event.tag, [\n                \"logs\",\n                this._getFilter(event.filter)\n            ], this.emitProcessFn(event), event);\n        }\n    }\n    /** @internal */ emitProcessFn(event) {\n        switch(event.type){\n            case index.ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n                return (result)=>this.emit({\n                        method: index.AlchemySubscription.PENDING_TRANSACTIONS,\n                        fromAddress: event.fromAddress,\n                        toAddress: event.toAddress,\n                        hashesOnly: event.hashesOnly\n                    }, result);\n            case index.ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n                return (result)=>this.emit({\n                        method: index.AlchemySubscription.MINED_TRANSACTIONS,\n                        addresses: event.addresses,\n                        includeRemoved: event.includeRemoved,\n                        hashesOnly: event.hashesOnly\n                    }, result);\n            case \"block\":\n                return (result)=>{\n                    const blockNumber = bignumber.BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                };\n            case \"filter\":\n                return (result)=>{\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                };\n            default:\n                throw new Error(\"Invalid event type to `emitProcessFn()`\");\n        }\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        const eventTag = index.getAlchemyEventTag(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        } else {\n            const eventTag = index.getAlchemyEventTag(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        const eventTag = index.getAlchemyEventTag(eventName);\n        return this._events.filter((event)=>{\n            return event.tag === eventTag;\n        }).length;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event)=>event.listener);\n        }\n        const eventTag = index.getAlchemyEventTag(eventName);\n        return this._events.filter((event)=>event.tag === eventTag).map((event)=>event.listener);\n    }\n}\nfunction getWebsocketConstructor() {\n    return isNodeEnvironment() ? (__webpack_require__(/*! websocket */ \"(ssr)/./node_modules/websocket/index.js\").w3cwebsocket) : WebSocket;\n}\nfunction isNodeEnvironment() {\n    return typeof process !== \"undefined\" && process != null && process.versions != null && process.versions.node != null;\n}\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken() {\n    let cancelled = false;\n    return {\n        cancel: ()=>cancelled = true,\n        isCancelled: ()=>cancelled\n    };\n}\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\nfunction withBackoffRetries(f, retryCount, shouldRetry = ()=>true) {\n    return index.__awaiter(this, void 0, void 0, function*() {\n        let nextWaitTime = 0;\n        let i = 0;\n        while(true){\n            try {\n                return yield f();\n            } catch (error) {\n                i++;\n                if (i >= retryCount || !shouldRetry(error)) {\n                    throw error;\n                }\n                yield delay(nextWaitTime);\n                if (!shouldRetry(error)) {\n                    throw error;\n                }\n                nextWaitTime = nextWaitTime === 0 ? MIN_RETRY_DELAY : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n            }\n        }\n    });\n}\nfunction delay(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\nfunction withTimeout(promise, ms) {\n    return Promise.race([\n        promise,\n        new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Timeout\")), ms))\n    ]);\n}\nfunction getNewHeadsBlockNumber(event) {\n    return index.fromHex(event.number);\n}\nfunction getLogsBlockNumber(event) {\n    return index.fromHex(event.blockNumber);\n}\nfunction isResponse(message) {\n    return Array.isArray(message) || message.jsonrpc === \"2.0\" && message.id !== undefined;\n}\nfunction isSubscriptionEvent(message) {\n    return !isResponse(message);\n}\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\nfunction addToLogsEventsBuffer(pastEvents, event) {\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */ function addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n    const currentBlockNumber = getBlockNumber(event);\n    // Find first index of an event recent enough to retain, then drop everything\n    // at a lower index.\n    const firstGoodIndex = pastEvents.findIndex((e)=>getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\n    if (firstGoodIndex === -1) {\n        pastEvents.length = 0;\n    } else {\n        pastEvents.splice(0, firstGoodIndex);\n    }\n    pastEvents.push(event);\n}\nexports.AlchemyWebSocketProvider = AlchemyWebSocketProvider; //# sourceMappingURL=alchemy-websocket-provider-2dafa9e4.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvYWxjaGVteS13ZWJzb2NrZXQtcHJvdmlkZXItMmRhZmE5ZTQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxrQkFBa0JELG1CQUFPQSxDQUFDO0FBQzlCLElBQUlFLFlBQVlGLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlHLFdBQVdILG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlJLFlBQVlKLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlLLGtCQUFrQkwsbUJBQU9BLENBQUM7QUFDOUJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsU0FBU00sc0JBQXVCQyxDQUFDO0lBQUksT0FBT0EsS0FBSyxPQUFPQSxNQUFNLFlBQVksYUFBYUEsSUFBSUEsSUFBSTtRQUFFLFdBQVdBO0lBQUU7QUFBRztBQUVqSCxJQUFJQywyQkFBMkIsV0FBVyxHQUFFRixzQkFBc0JMO0FBRWxFOzs7O0NBSUMsR0FDRCxNQUFNUSxzQkFBc0I7QUFDNUI7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNQztJQUNGQyxZQUFZQyxRQUFRLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO1FBQ2hCLDBDQUEwQztRQUMxQyxJQUFJLENBQUNDLGlCQUFpQixHQUFHSjtJQUM3QjtJQUNBOzs7Ozs7O0tBT0MsR0FDREssb0JBQW9CQyxXQUFXLEVBQUVDLGFBQWEsRUFBRUMsZUFBZSxFQUFFO1FBQzdELE9BQU9sQixNQUFNbUIsU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3pDQyxpQkFBaUJKO1lBQ2pCLE1BQU1LLGdCQUFnQixNQUFNLElBQUksQ0FBQ0MsY0FBYztZ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Sy9GO0FBQ3JEO0FBQ0EsU0FBU1Usb0JBQW9CSixPQUFPO0lBQ2hDLE9BQU8sQ0FBQ3VKLFdBQVd2SjtBQUN2QjtBQUNBLFNBQVNhLDBCQUEwQjZJLFVBQVUsRUFBRXRNLEtBQUs7SUFDaERvSixzQkFBc0JrRCxZQUFZdE0sT0FBTzJEO0FBQzdDO0FBQ0EsU0FBU0ksc0JBQXNCdUksVUFBVSxFQUFFdE0sS0FBSztJQUM1Q29KLHNCQUFzQmtELFlBQVl0TSxPQUFPZ0U7QUFDN0M7QUFDQTs7O0NBR0MsR0FDRCxTQUFTb0Ysc0JBQXNCa0QsVUFBVSxFQUFFdE0sS0FBSyxFQUFFOUQsY0FBYztJQUM1RCxNQUFNcVEscUJBQXFCclEsZUFBZThEO0lBQzFDLDZFQUE2RTtJQUM3RSxvQkFBb0I7SUFDcEIsTUFBTXdNLGlCQUFpQkYsV0FBV0csU0FBUyxDQUFDclIsQ0FBQUEsSUFBS2MsZUFBZWQsS0FBS21SLHFCQUFxQnRMO0lBQzFGLElBQUl1TCxtQkFBbUIsQ0FBQyxHQUFHO1FBQ3ZCRixXQUFXblEsTUFBTSxHQUFHO0lBQ3hCLE9BQ0s7UUFDRG1RLFdBQVdJLE1BQU0sQ0FBQyxHQUFHRjtJQUN6QjtJQUNBRixXQUFXL04sSUFBSSxDQUFDeUI7QUFDcEI7QUFFQTJNLGdDQUFnQyxHQUFHekwsMEJBQ25DLCtEQUErRCIsInNvdXJjZXMiOlsid2VicGFjazovL21pc3Npb24tbGF1bmNoLWJ1cm4tb3ItZ2xvcnkvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvYWxjaGVteS13ZWJzb2NrZXQtcHJvdmlkZXItMmRhZmE5ZTQuanM/MTBlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpbmRleCA9IHJlcXVpcmUoJy4vaW5kZXgtMzg3M2U3YjguanMnKTtcbnZhciBTdHVyZHlXZWJTb2NrZXQgPSByZXF1aXJlKCdzdHVyZHktd2Vic29ja2V0Jyk7XG52YXIgYmlnbnVtYmVyID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyJyk7XG52YXIgbmV0d29ya3MgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9uZXR3b3JrcycpO1xudmFyIHByb3ZpZGVycyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycycpO1xudmFyIGFsY2hlbXlQcm92aWRlciA9IHJlcXVpcmUoJy4vYWxjaGVteS1wcm92aWRlci1iMDA2YTRiYy5qcycpO1xucmVxdWlyZSgnLi9hcGkvdXRpbHMnKTtcbnJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2J5dGVzJyk7XG5yZXF1aXJlKCdheGlvcycpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXInKTtcbnJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L3dhbGxldCcpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC93ZWInKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBTdHVyZHlXZWJTb2NrZXRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KFN0dXJkeVdlYlNvY2tldCk7XG5cbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYmxvY2tzIHRvIGJhY2tmaWxsLiBJZiBtb3JlIHRoYW4gdGhpcyBtYW55IGJsb2NrcyBoYXZlXHJcbiAqIGJlZW4gbWlzc2VkLCB0aGVuIHdlJ2xsIHNhZGx5IG1pc3MgZGF0YSwgYnV0IHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGRvbid0XHJcbiAqIGVuZCB1cCByZXF1ZXN0aW5nIHRob3VzYW5kcyBvZiBibG9ja3MgaWYgc29tZWJvZHkgbGVmdCB0aGVpciBsYXB0b3AgY2xvc2VkIGZvciBhIHdlZWsuXHJcbiAqL1xyXG5jb25zdCBNQVhfQkFDS0ZJTExfQkxPQ0tTID0gMTIwO1xyXG4vKipcclxuICogVGhlIFdlYnNvY2tldEJhY2tmaWxsZXIgZmV0Y2hlcyBldmVudHMgdGhhdCB3ZXJlIHNlbnQgc2luY2UgYSBwcm92aWRlZCBibG9ja1xyXG4gKiBudW1iZXIuIFRoaXMgaXMgdXNlZCBpbiB0aGUge0BsaW5rIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcn0gdG8gYmFja2ZpbGxcclxuICogZXZlbnRzIHRoYXQgd2VyZSB0cmFuc21pdHRlZCB3aGlsZSB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gd2FzIGRvd24uXHJcbiAqXHJcbiAqIFRoZSBiYWNrZmlsbGVyIGJhY2tmaWxscyB0d28gbWFpbiBldGhfc3Vic2NyaWJlIGV2ZW50czogYGxvZ3NgIGFuZCBgbmV3SGVhZHNgLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFdlYnNvY2tldEJhY2tmaWxsZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICAgICAgLy8gVE9ETzogVXNlIEhUVFAgcHJvdmlkZXIgdG8gZG8gYmFja2ZpbGwuXHJcbiAgICAgICAgdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyA9IE1BWF9CQUNLRklMTF9CTE9DS1M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYmFja2ZpbGwgZm9yIGBuZXdIZWFkc2AgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpc0NhbmNlbGxlZCBXaGV0aGVyIHRoZSBiYWNrZmlsbCByZXF1ZXN0IGlzIGNhbmNlbGxlZC5cclxuICAgICAqIEBwYXJhbSBwcmV2aW91c0hlYWRzIFByZXZpb3VzIGhlYWQgcmVxdWVzdHMgdGhhdCB3ZXJlIHNlbnQuXHJcbiAgICAgKiBAcGFyYW0gZnJvbUJsb2NrTnVtYmVyIFRoZSBibG9jayBudW1iZXIgdG8gc3RhcnQgYmFja2ZpbGxpbmcgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEEgbGlzdCBvZiBgbmV3SGVhZHNgIGV2ZW50cyB0aGF0IHdlcmUgc2VudCBzaW5jZSB0aGUgbGFzdCBiYWNrZmlsbC5cclxuICAgICAqL1xyXG4gICAgZ2V0TmV3SGVhZHNCYWNrZmlsbChpc0NhbmNlbGxlZCwgcHJldmlvdXNIZWFkcywgZnJvbUJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcHJldmlvdXMgaGVhZHMgdG8gZmV0Y2gsIHJldHVybiBuZXcgaGVhZHMgc2luY2VcclxuICAgICAgICAgICAgLy8gYGZyb21CbG9ja051bWJlcmAsIG9yIHVwIHRvIG1heEJhY2tmaWxsQmxvY2tzIGZyb20gdGhlIGN1cnJlbnQgaGVhZC5cclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzSGVhZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkRXZlbnRzSW5SYW5nZShNYXRoLm1heChmcm9tQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgLSB0aGlzLm1heEJhY2tmaWxsQmxvY2tzKSArIDEsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBlbWl0dGVkIGV2ZW50IGlzIHRvbyBmYXIgYmFjayBpbiB0aGUgcGFzdCwgdGhlcmUncyBubyBuZWVkXHJcbiAgICAgICAgICAgIC8vIHRvIGJhY2tmaWxsIGZvciByZW9yZ3MuIEp1c3QgZmV0Y2ggdGhlIGxhc3QgYG1heEJhY2tmaWxsQmxvY2tzYCB3b3J0aCBvZlxyXG4gICAgICAgICAgICAvLyBuZXcgaGVhZHMuXHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTZWVuQmxvY2tOdW1iZXIgPSBpbmRleC5mcm9tSGV4KHByZXZpb3VzSGVhZHNbcHJldmlvdXNIZWFkcy5sZW5ndGggLSAxXS5udW1iZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBtaW5CbG9ja051bWJlciA9IHRvQmxvY2tOdW1iZXIgLSB0aGlzLm1heEJhY2tmaWxsQmxvY2tzICsgMTtcclxuICAgICAgICAgICAgaWYgKGxhc3RTZWVuQmxvY2tOdW1iZXIgPD0gbWluQmxvY2tOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRFdmVudHNJblJhbmdlKG1pbkJsb2NrTnVtYmVyLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVG8gY2FwdHVyZSBhbGwgYG5ld0hlYWRzYCBldmVudHMsIHJldHVybiBhbGwgaGVhZCBldmVudHMgZnJvbSB0aGUgbGFzdFxyXG4gICAgICAgICAgICAvLyBzZWVuIGJsb2NrIG51bWJlciB0byBjdXJyZW50ICsgYW55IG9mIHRoZSBwcmV2aW91cyBoZWFkcyB0aGF0IHdlcmUgcmUtb3JnZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlb3JnSGVhZHMgPSB5aWVsZCB0aGlzLmdldFJlb3JnSGVhZHMoaXNDYW5jZWxsZWQsIHByZXZpb3VzSGVhZHMpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSGVhZHMgPSB5aWVsZCB0aGlzLmdldEhlYWRFdmVudHNJblJhbmdlKGxhc3RTZWVuQmxvY2tOdW1iZXIgKyAxLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gWy4uLnJlb3JnSGVhZHMsIC4uLmludGVybWVkaWF0ZUhlYWRzXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBiYWNrZmlsbCBmb3IgYGxvZ3NgIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXNDYW5jZWxsZWQgV2hldGhlciB0aGUgYmFja2ZpbGwgcmVxdWVzdCBpcyBjYW5jZWxsZWQuXHJcbiAgICAgKiBAcGFyYW0gZmlsdGVyIFRoZSBmaWx0ZXIgb2JqZWN0IHRoYXQgYWNjb21wYW5pZXMgYSBsb2dzIHN1YnNjcmlwdGlvbi5cclxuICAgICAqIEBwYXJhbSBwcmV2aW91c0xvZ3MgUHJldmlvdXMgbG9nIHJlcXVlc3RzIHRoYXQgd2VyZSBzZW50LlxyXG4gICAgICogQHBhcmFtIGZyb21CbG9ja051bWJlciBUaGUgYmxvY2sgbnVtYmVyIHRvIHN0YXJ0IGJhY2tmaWxsaW5nIGZyb20uXHJcbiAgICAgKi9cclxuICAgIGdldExvZ3NCYWNrZmlsbChpc0NhbmNlbGxlZCwgZmlsdGVyLCBwcmV2aW91c0xvZ3MsIGZyb21CbG9ja051bWJlcikge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICBjb25zdCB0b0Jsb2NrTnVtYmVyID0geWllbGQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHByZXZpb3VzIGxvZ3MgdG8gZmV0Y2gsIHJldHVybiBuZXcgbG9ncyBzaW5jZVxyXG4gICAgICAgICAgICAvLyBgZnJvbUJsb2NrTnVtYmVyYCwgb3IgdXAgdG8gYG1heEJhY2tmaWxsQmxvY2tzYCBmcm9tIHRoZSBjdXJyZW50IGhlYWQuXHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0xvZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb2dzSW5SYW5nZShmaWx0ZXIsIE1hdGgubWF4KGZyb21CbG9ja051bWJlciwgdG9CbG9ja051bWJlciAtIHRoaXMubWF4QmFja2ZpbGxCbG9ja3MpICsgMSwgdG9CbG9ja051bWJlciArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBsYXN0IGVtaXR0ZWQgbG9nIGlzIHRvbyBmYXIgYmFjayBpbiB0aGUgcGFzdCwgdGhlcmUncyBubyBuZWVkXHJcbiAgICAgICAgICAgIC8vIHRvIGJhY2tmaWxsIGZvciByZW1vdmVkIGxvZ3MuIEp1c3QgZmV0Y2ggdGhlIGxhc3QgYG1heEJhY2tmaWxsQmxvY2tzYFxyXG4gICAgICAgICAgICAvLyB3b3J0aCBvZiBsb2dzLlxyXG4gICAgICAgICAgICBjb25zdCBsYXN0U2VlbkJsb2NrTnVtYmVyID0gaW5kZXguZnJvbUhleChwcmV2aW91c0xvZ3NbcHJldmlvdXNMb2dzLmxlbmd0aCAtIDFdLmJsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgY29uc3QgbWluQmxvY2tOdW1iZXIgPSB0b0Jsb2NrTnVtYmVyIC0gdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyArIDE7XHJcbiAgICAgICAgICAgIGlmIChsYXN0U2VlbkJsb2NrTnVtYmVyIDwgbWluQmxvY2tOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvZ3NJblJhbmdlKGZpbHRlciwgbWluQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYWxsIGxvZyBldmVudHMgdGhhdCBoYXZlIGhhcHBlbmVkIGFsb25nIHdpdGggbG9nIGV2ZW50cyB0aGF0IGhhdmVcclxuICAgICAgICAgICAgLy8gYmVlbiByZW1vdmVkIGR1ZSB0byBhIGNoYWluIHJlb3JnLlxyXG4gICAgICAgICAgICBjb25zdCBjb21tb25BbmNlc3RvciA9IHlpZWxkIHRoaXMuZ2V0Q29tbW9uQW5jZXN0b3IoaXNDYW5jZWxsZWQsIHByZXZpb3VzTG9ncyk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAvLyBBbGwgcHJldmlvdXMgbG9ncyB3aXRoIGEgYmxvY2sgbnVtYmVyIGdyZWF0ZXIgdGhhbiB0aGUgY29tbW9uIGFuY2VzdG9yXHJcbiAgICAgICAgICAgIC8vIHdlcmUgcGFydCBvZiBhIHJlLW9yZywgc28gbWFyayB0aGVtIGFzIHN1Y2guXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRMb2dzID0gcHJldmlvdXNMb2dzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGxvZyA9PiBpbmRleC5mcm9tSGV4KGxvZy5ibG9ja051bWJlcikgPiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlcilcclxuICAgICAgICAgICAgICAgIC5tYXAobG9nID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvZyksIHsgcmVtb3ZlZDogdHJ1ZSB9KSkpO1xyXG4gICAgICAgICAgICAvLyBJZiBubyBjb21tb24gYW5jZXN0b3Igd2FzIGZvdW5kLCBzdGFydCBiYWNrZmlsbCBmcm9tIHRoZSBvbGRlc3QgbG9nJ3NcclxuICAgICAgICAgICAgLy8gYmxvY2sgbnVtYmVyLlxyXG4gICAgICAgICAgICBjb25zdCBmcm9tQmxvY2tJbmNsdXNpdmUgPSBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlciA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXHJcbiAgICAgICAgICAgICAgICA/IGluZGV4LmZyb21IZXgocHJldmlvdXNMb2dzWzBdLmJsb2NrTnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgOiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlcjtcclxuICAgICAgICAgICAgbGV0IGFkZGVkTG9ncyA9IHlpZWxkIHRoaXMuZ2V0TG9nc0luUmFuZ2UoZmlsdGVyLCBmcm9tQmxvY2tJbmNsdXNpdmUsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgLy8gRGUtZHVwZSBhbnkgbG9ncyB0aGF0IHdlcmUgYWxyZWFkeSBlbWl0dGVkLlxyXG4gICAgICAgICAgICBhZGRlZExvZ3MgPSBhZGRlZExvZ3MuZmlsdGVyKGxvZyA9PiBsb2cgJiZcclxuICAgICAgICAgICAgICAgIChpbmRleC5mcm9tSGV4KGxvZy5ibG9ja051bWJlcikgPiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlciB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LmZyb21IZXgobG9nLmxvZ0luZGV4KSA+IGNvbW1vbkFuY2VzdG9yLmxvZ0luZGV4KSk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gWy4uLnJlbW92ZWRMb2dzLCAuLi5hZGRlZExvZ3NdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgbmV3IG1heCBiYWNrZmlsbCBibG9ja3MuIFZJU0lCTEUgT05MWSBGT1IgVEVTVElORy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc2V0TWF4QmFja2ZpbGxCbG9jayhuZXdNYXgpIHtcclxuICAgICAgICB0aGlzLm1heEJhY2tmaWxsQmxvY2tzID0gbmV3TWF4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGJsb2NrIG51bWJlciBhcyBhIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRCbG9ja051bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlckhleCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZCgnZXRoX2Jsb2NrTnVtYmVyJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleC5mcm9tSGV4KGJsb2NrTnVtYmVySGV4KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgYG5ld0hlYWRgIGV2ZW50cyBpbiB0aGUgcHJvdmlkZWQgcmFuZ2UuIE5vdGUgdGhhdCB0aGUgcmV0dXJuZWRcclxuICAgICAqIGhlYWRzIGRvIG5vdCBpbmNsdWRlIHJlLW9yZ2VkIGhlYWRzLiBVc2Uge0BsaW5rIGdldFJlb3JnSGVhZHN9IHRvIGZpbmQgaGVhZHNcclxuICAgICAqIHRoYXQgd2VyZSBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldEhlYWRFdmVudHNJblJhbmdlKGZyb21CbG9ja0luY2x1c2l2ZSwgdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2tJbmNsdXNpdmUgPj0gdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUGFydHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZyb21CbG9ja0luY2x1c2l2ZTsgaSA8IHRvQmxvY2tFeGNsdXNpdmU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2hQYXJ0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbaW5kZXgudG9IZXgoaSksIGZhbHNlXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIGVycm9yc1xyXG4gICAgICAgICAgICBjb25zdCBibG9ja0hlYWRzID0geWllbGQgdGhpcy5wcm92aWRlci5zZW5kQmF0Y2goYmF0Y2hQYXJ0cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBibG9ja0hlYWRzLm1hcCh0b05ld0hlYWRzRXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBoZWFkcyB0aGF0IHdlcmUgcGFydCBvZiBhIHJlb3JnIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldFJlb3JnSGVhZHMoaXNDYW5jZWxsZWQsIHByZXZpb3VzSGVhZHMpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBmcm9tIHRoZSBtb3N0IHJlY2VudCBoZWFkIGJhY2t3YXJkcyBpbiBvcmRlciB0byBmaW5kIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAvLyBibG9jayB0aGF0IHdhcyBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcHJldmlvdXNIZWFkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkRXZlbnQgPSBwcmV2aW91c0hlYWRzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2tIZWFkID0geWllbGQgdGhpcy5nZXRCbG9ja0J5TnVtYmVyKGluZGV4LmZyb21IZXgob2xkRXZlbnQubnVtYmVyKSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBoYXNoZXMgbWF0Y2gsIHRoZW4gY3VycmVudCBoZWFkIGluIHRoZSBpdGVyYXRpb24gd2FzIG5vdCByZS1vcmdlZC5cclxuICAgICAgICAgICAgICAgIGlmIChvbGRFdmVudC5oYXNoID09PSBibG9ja0hlYWQuaGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9OZXdIZWFkc0V2ZW50KGJsb2NrSGVhZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1wbGUgd3JhcHBlciBhcm91bmQgYGV0aF9nZXRCbG9ja0J5TnVtYmVyYCB0aGF0IHJldHVybnMgdGhlIGNvbXBsZXRlXHJcbiAgICAgKiBibG9jayBpbmZvcm1hdGlvbiBmb3IgdGhlIHByb3ZpZGVkIGJsb2NrIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRCbG9ja0J5TnVtYmVyKGJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZCgnZXRoX2dldEJsb2NrQnlOdW1iZXInLCBbXHJcbiAgICAgICAgICAgICAgICBpbmRleC50b0hleChibG9ja051bWJlciksXHJcbiAgICAgICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIHByZXZpb3VzIGxvZyBldmVudHMsIGZpbmRzIHRoZSBjb21tb24gYmxvY2sgbnVtYmVyIGZyb20gdGhlXHJcbiAgICAgKiBsb2dzIHRoYXQgbWF0Y2hlcyB0aGUgYmxvY2sgaGVhZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHdoaWNoIGxvZ3MgYXJlIHBhcnQgb2YgYSByZS1vcmcuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyAxIGxlc3MgdGhhbiB0aGUgb2xkZXN0IGxvZydzIGJsb2NrIG51bWJlciBpZiBubyBjb21tb24gYW5jZXN0b3Igd2FzIGZvdW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldENvbW1vbkFuY2VzdG9yKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0xvZ3MpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIGZyb20gdGhlIG1vc3QgcmVjZW50IGhlYWQgYmFja3dhcmRzIGluIG9yZGVyIHRvIGZpbmQgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgIC8vIGJsb2NrIHRoYXQgd2FzIHBhcnQgb2YgYSByZS1vcmcuXHJcbiAgICAgICAgICAgIGxldCBibG9ja0hlYWQgPSB5aWVsZCB0aGlzLmdldEJsb2NrQnlOdW1iZXIoaW5kZXguZnJvbUhleChwcmV2aW91c0xvZ3NbcHJldmlvdXNMb2dzLmxlbmd0aCAtIDFdLmJsb2NrTnVtYmVyKSk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcHJldmlvdXNMb2dzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRMb2cgPSBwcmV2aW91c0xvZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB1cGRhdGVkIGJsb2NrcyBhcmUgZmV0Y2hlZCBldmVyeSB0aW1lIHRoZSBsb2cncyBibG9jayBudW1iZXJcclxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAob2xkTG9nLmJsb2NrTnVtYmVyICE9PSBibG9ja0hlYWQubnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tIZWFkID0geWllbGQgdGhpcy5nZXRCbG9ja0J5TnVtYmVyKGluZGV4LmZyb21IZXgob2xkTG9nLmJsb2NrTnVtYmVyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsb2dzIGFyZSBvcmRlcmVkIGluIGFzY2VuZGluZyBvcmRlciwgdGhlIGZpcnN0IGxvZyB0aGF0IG1hdGNoZXNcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBoYXNoIHNob3VsZCBiZSB0aGUgbGFyZ2VzdCBsb2dJbmRleC5cclxuICAgICAgICAgICAgICAgIGlmIChvbGRMb2cuYmxvY2tIYXNoID09PSBibG9ja0hlYWQuaGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBpbmRleC5mcm9tSGV4KG9sZExvZy5ibG9ja051bWJlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0luZGV4OiBpbmRleC5mcm9tSGV4KG9sZExvZy5sb2dJbmRleClcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxyXG4gICAgICAgICAgICAgICAgbG9nSW5kZXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBgbG9nc2AgZXZlbnRzIGluIHRoZSBwcm92aWRlZCByYW5nZS4gTm90ZSB0aGF0IHRoZSByZXR1cm5lZCBsb2dzXHJcbiAgICAgKiBkbyBub3QgaW5jbHVkZSByZW1vdmVkIGxvZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqLyBnZXRMb2dzSW5SYW5nZShmaWx0ZXIsIGZyb21CbG9ja0luY2x1c2l2ZSwgdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2tJbmNsdXNpdmUgPj0gdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlRmlsdGVyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWx0ZXIpLCB7IGZyb21CbG9jazogaW5kZXgudG9IZXgoZnJvbUJsb2NrSW5jbHVzaXZlKSwgdG9CbG9jazogaW5kZXgudG9IZXgodG9CbG9ja0V4Y2x1c2l2ZSAtIDEpIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKCdldGhfZ2V0TG9ncycsIFtyYW5nZUZpbHRlcl0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvTmV3SGVhZHNFdmVudChoZWFkKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBoZWFkKTtcclxuICAgIGRlbGV0ZSByZXN1bHQudG90YWxEaWZmaWN1bHR5O1xyXG4gICAgZGVsZXRlIHJlc3VsdC50cmFuc2FjdGlvbnM7XHJcbiAgICBkZWxldGUgcmVzdWx0LnVuY2xlcztcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZGVkdXBlTmV3SGVhZHMoZXZlbnRzKSB7XHJcbiAgICByZXR1cm4gZGVkdXBlKGV2ZW50cywgZXZlbnQgPT4gZXZlbnQuaGFzaCk7XHJcbn1cclxuZnVuY3Rpb24gZGVkdXBlTG9ncyhldmVudHMpIHtcclxuICAgIHJldHVybiBkZWR1cGUoZXZlbnRzLCBldmVudCA9PiBgJHtldmVudC5ibG9ja0hhc2h9LyR7ZXZlbnQubG9nSW5kZXh9YCk7XHJcbn1cclxuZnVuY3Rpb24gZGVkdXBlKGl0ZW1zLCBnZXRLZXkpIHtcclxuICAgIGNvbnN0IGtleXNTZWVuID0gbmV3IFNldCgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGdldEtleShpdGVtKTtcclxuICAgICAgICBpZiAoIWtleXNTZWVuLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIGtleXNTZWVuLmFkZChrZXkpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuY29uc3QgQ0FOQ0VMTEVEID0gbmV3IEVycm9yKCdDYW5jZWxsZWQnKTtcclxuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCkge1xyXG4gICAgaWYgKGlzQ2FuY2VsbGVkKCkpIHtcclxuICAgICAgICB0aHJvdyBDQU5DRUxMRUQ7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgSEVBUlRCRUFUX0lOVEVSVkFMID0gMzAwMDA7XHJcbmNvbnN0IEhFQVJUQkVBVF9XQUlUX1RJTUUgPSAxMDAwMDtcclxuY29uc3QgQkFDS0ZJTExfVElNRU9VVCA9IDYwMDAwO1xyXG5jb25zdCBCQUNLRklMTF9SRVRSSUVTID0gNTtcclxuLyoqXHJcbiAqIFN1YnNjcmlwdGlvbnMgaGF2ZSBhIG1lbW9yeSBvZiByZWNlbnQgZXZlbnRzIHRoZXkgaGF2ZSBzZW50IHNvIHRoYXQgaW4gdGhlXHJcbiAqIGV2ZW50IHRoYXQgdGhleSBkaXNjb25uZWN0IGFuZCBuZWVkIHRvIGJhY2tmaWxsLCB0aGV5IGNhbiBkZXRlY3QgcmUtb3Jncy5cclxuICogS2VlcCBhIGJ1ZmZlciB0aGF0IGdvZXMgYmFjayBhdCBsZWFzdCB0aGVzZSBtYW55IGJsb2NrcywgdGhlIG1heGltdW0gYW1vdW50XHJcbiAqIGF0IHdoaWNoIHdlIG1pZ2h0IGNvbmNlaXZhYmx5IHNlZSBhIHJlLW9yZy5cclxuICpcclxuICogTm90ZSB0aGF0IHdoaWxlIG91ciBidWZmZXIgZ29lcyBiYWNrIHRoaXMgbWFueSBibG9ja3MsIGl0IG1heSBjb250YWluIG1vcmVcclxuICogdGhhbiB0aGlzIG1hbnkgZWxlbWVudHMsIHNpbmNlIGluIHRoZSBjYXNlIG9mIGxvZ3Mgc3Vic2NyaXB0aW9ucyBtb3JlIHRoYW5cclxuICogb25lIGV2ZW50IG1heSBiZSBlbWl0dGVkIGZvciBhIGJsb2NrLlxyXG4gKi9cclxuY29uc3QgUkVUQUlORURfRVZFTlRfQkxPQ0tfQ09VTlQgPSAxMDtcclxuLyoqXHJcbiAqIFNESydzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBmbyB0aGUgZXRoZXJzLmpzJ3MgJ0FsY2hlbXlXZWJTb2NrZXRQcm92aWRlcicuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIGluc3RhbmNlIG9mXHJcbiAqIHtAbGluayBBbGNoZW15fSBhbmQgY2FsbCB7QGxpbmsgQWxjaGVteS5jb25maWcuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKX0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIHByb3ZpZGVycy5XZWJTb2NrZXRQcm92aWRlciB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHdzQ29uc3RydWN0b3IpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBBUEkgS2V5IHRvIGEgc3RyaW5nLlxyXG4gICAgICAgIGNvbnN0IGFwaUtleSA9IGFsY2hlbXlQcm92aWRlci5BbGNoZW15UHJvdmlkZXIuZ2V0QXBpS2V5KGNvbmZpZy5hcGlLZXkpO1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIG91ciBvd24gY29ubmVjdGlvbiBpbmZvIHdpdGggdGhlIGNvcnJlY3QgZW5kcG9pbnQgVVJMcy5cclxuICAgICAgICBjb25zdCBhbGNoZW15TmV0d29yayA9IGFsY2hlbXlQcm92aWRlci5BbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteU5ldHdvcmsoY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhbGNoZW15UHJvdmlkZXIuQWxjaGVteVByb3ZpZGVyLmdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyhhbGNoZW15TmV0d29yaywgYXBpS2V5LCAnd3NzJyk7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBgYWxjaGVteS1zZGstJHtpbmRleC5WRVJTSU9OfWA7XHJcbiAgICAgICAgLy8gVXNlIHRoZSBwcm92aWRlZCBjb25maWcgVVJMIG92ZXJyaWRlIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHVzZSB0aGUgY3JlYXRlZCBvbmUuXHJcbiAgICAgICAgY29uc3Qgd3MgPSBuZXcgU3R1cmR5V2ViU29ja2V0X19kZWZhdWx0W1wiZGVmYXVsdFwiXSgoX2EgPSBjb25maWcudXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25uZWN0aW9uLnVybCwgcHJvdG9jb2wsIHtcclxuICAgICAgICAgICAgd3NDb25zdHJ1Y3Rvcjogd3NDb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiB3c0NvbnN0cnVjdG9yICE9PSB2b2lkIDAgPyB3c0NvbnN0cnVjdG9yIDogZ2V0V2Vic29ja2V0Q29uc3RydWN0b3IoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQWxjaGVteSBuYW1lZCBuZXR3b3JrIGlucHV0IHRvIHRoZSBuZXR3b3JrIG5hbWVzIHVzZWQgYnlcclxuICAgICAgICAvLyBldGhlcnMuIFRoaXMgYWxsb3dzIHRoZSBwYXJlbnQgc3VwZXIgY29uc3RydWN0b3IgaW4gSnNvblJwY1Byb3ZpZGVyIHRvXHJcbiAgICAgICAgLy8gY29ycmVjdGx5IHNldCB0aGUgbmV0d29yay5cclxuICAgICAgICBjb25zdCBldGhlcnNOZXR3b3JrID0gaW5kZXguRXRoZXJzTmV0d29ya1thbGNoZW15TmV0d29ya107XHJcbiAgICAgICAgc3VwZXIod3MsIGV0aGVyc05ldHdvcmsgIT09IG51bGwgJiYgZXRoZXJzTmV0d29yayAhPT0gdm9pZCAwID8gZXRoZXJzTmV0d29yayA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XHJcbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBXZWJTb2NrZXQgcmVjb25uZWN0aW9uLCBhbGwgc3Vic2NyaXB0aW9ucyBhcmUgbG9zdCBhbmQgd2VcclxuICAgICAgICAvLyBjcmVhdGUgbmV3IG9uZXMgdG8gcmVwbGFjZSB0aGVtLCBidXQgd2Ugd2FudCB0byBjcmVhdGUgdGhlIGlsbHVzaW9uIHRoYXRcclxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgc3Vic2NyaXB0aW9ucyBwZXJzaXN0LiBUaHVzLCBtYWludGFpbiBhIG1hcHBpbmcgZnJvbSB0aGVcclxuICAgICAgICAvLyBcInZpcnR1YWxcIiBzdWJzY3JpcHRpb24gaWRzIHdoaWNoIGFyZSB2aXNpYmxlIHRvIHRoZSBjb25zdW1lciB0byB0aGVcclxuICAgICAgICAvLyBcInBoeXNpY2FsXCIgc3Vic2NyaXB0aW9uIGlkcyBvZiB0aGUgYWN0dWFsIGNvbm5lY3Rpb25zLiBUaGlzIHRlcm1pbm9sb2d5IGlzXHJcbiAgICAgICAgLy8gYm9ycm93ZWQgZnJvbSB2aXJ0dWFsIGFuZCBwaHlzaWNhbCBtZW1vcnksIHdoaWNoIGhhcyBhIHNpbWlsYXIgbWFwcGluZy5cclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdW5kZXJseWluZyBldGhlcnMge0BsaW5rIFdlYlNvY2tldFByb3ZpZGVyfSBhbHJlYWR5IGhhbmRsZXMgYW5kIGVtaXRzXHJcbiAgICAgICAgICogbWVzc2FnZXMuIFRvIGFsbG93IGJhY2tmaWxsaW5nLCB0cmFjayBhbGwgbWVzc2FnZXMgdGhhdCBhcmUgZW1pdHRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYSBmaWVsZCBhcnJvdyBmdW5jdGlvbiBpbiBvcmRlciB0byBwcmVzZXJ2ZSBgdGhpc2AgY29udGV4dCB3aGVuXHJcbiAgICAgICAgICogcGFzc2luZyB0aGUgbWV0aG9kIGFzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoIWlzU3Vic2NyaXB0aW9uRXZlbnQobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwaHlzaWNhbElkID0gbWVzc2FnZS5wYXJhbXMuc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCB2aXJ0dWFsSWQgPSB0aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQuZ2V0KHBoeXNpY2FsSWQpO1xyXG4gICAgICAgICAgICBpZiAoIXZpcnR1YWxJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLmdldCh2aXJ0dWFsSWQpO1xyXG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLm1ldGhvZCAhPT0gJ2V0aF9zdWJzY3JpYmUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChzdWJzY3JpcHRpb24ucGFyYW1zWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICduZXdIZWFkcyc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdIZWFkc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdIZWFkc01lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNCYWNrZmlsbGluZywgYmFja2ZpbGxCdWZmZXIgfSA9IG5ld0hlYWRzU3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBuZXdIZWFkc01lc3NhZ2UucGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0JhY2tmaWxsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvTmV3SGVhZHNFdmVudHNCdWZmZXIoYmFja2ZpbGxCdWZmZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBoeXNpY2FsSWQgIT09IHZpcnR1YWxJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIHJlLW9wZW5lZCBzdWJzY3JpcHRpb24sIGV0aGVycyB3aWxsIG5vdCBlbWl0IHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVudCwgc28gdGhlIFNESyBoYXMgdG8uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXRoZXJzIHN1YnNjcmlwdGlvbiBtYXBwaW5nIHdpbGwgZW1pdCB0aGUgZXZlbnQsIGp1c3Qgc3RvcmUgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TmV3SGVhZHNCbG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbG9ncyc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dzU3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ3NNZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGlzQmFja2ZpbGxpbmcsIGJhY2tmaWxsQnVmZmVyIH0gPSBsb2dzU3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBsb2dzTWVzc2FnZS5wYXJhbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmFja2ZpbGxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9Mb2dzRXZlbnRzQnVmZmVyKGJhY2tmaWxsQnVmZmVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2aXJ0dWFsSWQgIT09IHBoeXNpY2FsSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0QW5kUmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TG9nc0Jsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TG9nc0Jsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwaHlzaWNhbElkICE9PSB2aXJ0dWFsSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSByZS1vcGVuZWQgc3Vic2NyaXB0aW9uLCBldGhlcnMgd2lsbCBub3QgZW1pdCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQsIHNvIHRoZSBTREsgaGFzIHRvLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gbWVzc2FnZS5wYXJhbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZW4gdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIHJlb3BlbnM6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAxLiBSZXN1YnNjcmliZSB0byBhbGwgZXhpc3Rpbmcgc3Vic2NyaXB0aW9ucyBhbmQgc3RhcnQgYmFja2ZpbGxpbmdcclxuICAgICAgICAgKiAyLiBSZXN0YXJ0IGhlYXJ0IGJlYXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzIGEgZmllbGQgYXJyb3cgZnVuY3Rpb24gaW4gb3JkZXIgdG8gcHJlc2VydmUgYHRoaXNgIGNvbnRleHQgd2hlblxyXG4gICAgICAgICAqIHBhc3NpbmcgdGhlIG1ldGhvZCBhcyBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUmVvcGVuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQuY2xlYXIoKTtcclxuICAgICAgICAgICAgY29uc3QgeyBjYW5jZWwsIGlzQ2FuY2VsbGVkIH0gPSBtYWtlQ2FuY2VsVG9rZW4oKTtcclxuICAgICAgICAgICAgdGhpcy5jYW5jZWxCYWNrZmlsbCA9IGNhbmNlbDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBzdWJzY3JpcHRpb24gb2YgdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgKCgpID0+IGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3Vic2NyaWJlQW5kQmFja2ZpbGwoaXNDYW5jZWxsZWQsIHN1YnNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FuY2VsbGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoaWxlIGJhY2tmaWxsaW5nIFwiJHtzdWJzY3JpcHRpb24ucGFyYW1zWzBdfVwiIHN1YnNjcmlwdGlvbi4gU29tZSBldmVudHMgbWF5IGJlIG1pc3NpbmcuYCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkpKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGFydEhlYXJ0YmVhdCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FuY2VscyB0aGUgaGVhcnRiZWF0IGFuZCBhbnkgcGVuZGluZyBiYWNrZmlsbHMgYmVpbmcgcGVyZm9ybWVkLiBUaGlzIGlzXHJcbiAgICAgICAgICogY2FsbGVkIHdoZW4gdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIGdvZXMgZG93biBvciBpcyBkaXNjb25uZWN0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzIGEgZmllbGQgYXJyb3cgZnVuY3Rpb24gaW4gb3JkZXIgdG8gcHJlc2VydmUgYHRoaXNgIGNvbnRleHQgd2hlblxyXG4gICAgICAgICAqIHBhc3NpbmcgdGhlIG1ldGhvZCBhcyBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RvcEhlYXJ0YmVhdEFuZEJhY2tmaWxsID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFydGJlYXRJbnRlcnZhbElkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRJbnRlcnZhbElkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbEJhY2tmaWxsKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcclxuICAgICAgICAvLyBTdGFydCBoZWFydGJlYXQgYW5kIGJhY2tmaWxsZXIgZm9yIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbi5cclxuICAgICAgICB0aGlzLmJhY2tmaWxsZXIgPSBuZXcgV2Vic29ja2V0QmFja2ZpbGxlcih0aGlzKTtcclxuICAgICAgICB0aGlzLmFkZFNvY2tldExpc3RlbmVycygpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKTtcclxuICAgICAgICB0aGlzLmNhbmNlbEJhY2tmaWxsID0gaW5kZXgubm9vcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBgQmFzZVByb3ZpZGVyLmdldE5ldHdvcmtgIG1ldGhvZCBhcyBpbXBsZW1lbnRlZCBieSBldGhlcnMuanMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBvdmVycmlkZSBhbGxvd3MgdGhlIFNESyB0byBzZXQgdGhlIHByb3ZpZGVyJ3MgbmV0d29yayB0byB2YWx1ZXMgbm90XHJcbiAgICAgKiB5ZXQgc3VwcG9ydGVkIGJ5IGV0aGVycy5qcy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0TmV0d29yayhuZXR3b3JrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXR3b3JrID09PSAnc3RyaW5nJyAmJiBuZXR3b3JrIGluIGluZGV4LkN1c3RvbU5ldHdvcmtzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleC5DdXN0b21OZXR3b3Jrc1tuZXR3b3JrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgc3RhbmRhcmQgZXRoZXJzLmpzIGdldE5ldHdvcmsgbWV0aG9kIGZvciBvdGhlciBuZXR3b3Jrcy5cclxuICAgICAgICByZXR1cm4gbmV0d29ya3MuZ2V0TmV0d29yayhuZXR3b3JrKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGRlbiBpbXBsZW1lbnRhdGlvbiBvZiBldGhlcnMgdGhhdCBpbmNsdWRlcyBBbGNoZW15IGJhc2VkIHN1YnNjcmlwdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBFdmVudCB0byBzdWJzY3JpYmUgdG9cclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogT3ZlcnJpZGUgYExpc3RlbmVyYCB0eXBlIHRvIGdldCB0eXBlIGF1dG9jb21wbGV0aW9ucy5cclxuICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRkZW4gaW1wbGVtZW50YXRpb24gb2YgZXRoZXJzIHRoYXQgaW5jbHVkZXMgQWxjaGVteSBiYXNlZFxyXG4gICAgICogc3Vic2NyaXB0aW9ucy4gQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSB0cmlnZ2VyZWQgZm9yIG9ubHkgdGhlIG5leHRcclxuICAgICAqIHtAbGluayBldmVudE5hbWV9IGV2ZW50LCBhZnRlciB3aGljaCBpdCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBFdmVudCB0byBzdWJzY3JpYmUgdG9cclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogT3ZlcnJpZGUgYExpc3RlbmVyYCB0eXBlIHRvIGdldCB0eXBlIGF1dG9jb21wbGV0aW9ucy5cclxuICAgIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm92aWRlZCB7QGxpbmsgbGlzdGVuZXJ9IGZvciB0aGUge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmIG5vXHJcbiAgICAgKiBsaXN0ZW5lciBpcyBwcm92aWRlZCwgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIEV2ZW50IHRvIHVubGlzdGVuIHRvLlxyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAoaW5kZXguaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgcHJvdmlkZWQge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmIG5vIGV2ZW50XHJcbiAgICAgKiBpcyBwcm92aWRlZCwgYWxsIGV2ZW50cyBhbmQgdGhlaXIgbGlzdGVuZXJzIGFyZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvci5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gdW5kZWZpbmVkICYmIGluZGV4LmlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBmb3IgdGhlIHByb3ZpZGVkIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZlxyXG4gICAgICogbm8gZXZlbnQgaXMgcHJvdmlkZWQsIHRoZSB0b3RhbCBudW1iZXIgb2YgbGlzdGVuZXJzIGZvciBhbGwgZXZlbnRzIGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIGdldCB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoZXZlbnROYW1lICE9PSB1bmRlZmluZWQgJiYgaW5kZXguaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJDb3VudChldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIGZvciB0aGUgcHJvdmlkZWQge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmXHJcbiAgICAgKiBubyBldmVudCBpcyBwcm92aWRlZCwgYWxsIGxpc3RlbmVycyB3aWxsIGJlIGluY2x1ZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIGdldCB0aGUgbGlzdGVuZXJzIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gdW5kZWZpbmVkICYmIGluZGV4LmlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycyhldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVycyhldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBtZXRob2QgaW4gYEJhc2VQcm92aWRlcmAgaW4gb3JkZXIgdG8gcHJvcGVybHkgZm9ybWF0IHRoZVxyXG4gICAgICogQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIF9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9uY2UpIHtcclxuICAgICAgICBpZiAoaW5kZXguaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICBpbmRleC52ZXJpZnlBbGNoZW15RXZlbnROYW1lKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IGluZGV4LkV0aGVyc0V2ZW50KGluZGV4LmdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpLCBsaXN0ZW5lciwgb25jZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKGV2ZW50KTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9uY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBgX3N0YXJ0RXZlbnQoKWAgbWV0aG9kIGluIGV0aGVycy5qcydzXHJcbiAgICAgKiB7QGxpbmsgV2ViU29ja2V0UHJvdmlkZXJ9IHRvIGluY2x1ZGUgYWRkaXRpb25hbCBhbGNoZW15IG1ldGhvZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50XHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfc3RhcnRFdmVudChldmVudCkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBldmVudCB0eXBlIGlzIGEgY3VzdG9tIEFsY2hlbXkgc3Vic2NyaXB0aW9uLlxyXG4gICAgICAgIGNvbnN0IGN1c3RvbUxvZ2ljVHlwZXMgPSBbLi4uaW5kZXguQUxDSEVNWV9FVkVOVF9UWVBFUywgJ2Jsb2NrJywgJ2ZpbHRlciddO1xyXG4gICAgICAgIGlmIChjdXN0b21Mb2dpY1R5cGVzLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RhcnRFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdXBlci5fc3RhcnRFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZGVuIGZyb20gZXRoZXJzLmpzJ3Mge0BsaW5rIFdlYlNvY2tldFByb3ZpZGVyfVxyXG4gICAgICpcclxuICAgICAqIE1vZGlmaWVkIGluIG9yZGVyIHRvIGFkZCBtYXBwaW5ncyBmb3IgYmFja2ZpbGxpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgX3N1YnNjcmliZSh0YWcsIHBhcmFtLCBwcm9jZXNzRnVuYywgZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgc3ViSWRQcm9taXNlID0gdGhpcy5fc3ViSWRzW3RhZ107XHJcbiAgICAgICAgICAgIC8vIEJFR0lOIE1PRElGSUVEIENPREVcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRpbmdCbG9ja051bWJlciA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgICAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICAgICAgaWYgKHN1YklkUHJvbWlzZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJJZFByb21pc2UgPSBQcm9taXNlLmFsbChwYXJhbSkudGhlbihwYXJhbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCgnZXRoX3N1YnNjcmliZScsIHBhcmFtKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3ViSWRzW3RhZ10gPSBzdWJJZFByb21pc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3ViSWQgPSB5aWVsZCBzdWJJZFByb21pc2U7XHJcbiAgICAgICAgICAgIC8vIEJFR0lOIE1PRElGSUVEIENPREVcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXJhbXMgPSB5aWVsZCBQcm9taXNlLmFsbChwYXJhbSk7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLnNldChzdWJJZCwge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3N1YnNjcmliZScsXHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHJlc29sdmVkUGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRpbmdCbG9ja051bWJlcixcclxuICAgICAgICAgICAgICAgIHZpcnR1YWxJZDogc3ViSWQsXHJcbiAgICAgICAgICAgICAgICBwaHlzaWNhbElkOiBzdWJJZCxcclxuICAgICAgICAgICAgICAgIHNlbnRFdmVudHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgaXNCYWNrZmlsbGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiYWNrZmlsbEJ1ZmZlcjogW11cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5zZXQoc3ViSWQsIHN1YklkKTtcclxuICAgICAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICAgICAgdGhpcy5fc3Vic1tzdWJJZF0gPSB7IHRhZywgcHJvY2Vzc0Z1bmMgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgQmFzZVByb3ZpZGVyYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgQWxjaGVteSdzIHVuaXF1ZVxyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGVzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhpcyBtZXRob2QgY2FsbHNcclxuICAgICAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGBnZXRFdmVudFRhZygpYCBtZXRob2QgaW5cclxuICAgICAqIG9yZGVyIHRvIHBhcnNlIHRoZSBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xyXG4gICAgICAgIGlmIChpbmRleC5pc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3Qgc3RvcHBlZCA9IFtdO1xyXG4gICAgICAgICAgICAvLyBUaGlzIGxpbmUgaXMgdGhlIG9ubHkgbW9kaWZpZWQgbGluZSBmcm9tIHRoZSBvcmlnaW5hbCBtZXRob2QuXHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VGFnID0gaW5kZXguZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9uY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzZW5kQmF0Y2gocGFydHMpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgbmV4dElkID0gMDtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHBhcnRzLm1hcCgoeyBtZXRob2QsIHBhcmFtcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGBhbGNoZW15LXNkazoke25leHRJZCsrfWBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQmF0Y2hDb25jdXJyZW50bHkocGF5bG9hZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQG92ZXJyaWRlICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5zdG9wSGVhcnRiZWF0QW5kQmFja2ZpbGwoKTtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGV0aGVyJ3MgYGlzQ29tbXVuaXR5UmVzb3VyY2UoKWAgbWV0aG9kLiBSZXR1cm5zIHRydWUgaWYgdGhlXHJcbiAgICAgKiBjdXJyZW50IGFwaSBrZXkgaXMgdGhlIGRlZmF1bHQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwaUtleSA9PT0gaW5kZXguREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYFdlYlNvY2tldFByb3ZpZGVyLl9zdG9wRXZlbnQoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gc3VwcG9ydCBBbGNoZW15J3NcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlIGJ5IGFsbG93aW5nIHRoZSBwcm92aWRlciB0byBwcm9wZXJseSBzdG9wIEFsY2hlbXknc1xyXG4gICAgICogc3Vic2NyaXB0aW9uIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3N0b3BFdmVudChldmVudCkge1xyXG4gICAgICAgIGxldCB0YWcgPSBldmVudC50YWc7XHJcbiAgICAgICAgLy8gU1RBUlQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIGlmIChpbmRleC5BTENIRU1ZX0VWRU5UX1RZUEVTLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgcGVuZGluZyB0cmFuc2FjdGlvbiBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuZmlsdGVyKGUgPT4gaW5kZXguQUxDSEVNWV9FVkVOVF9UWVBFUy5pbmNsdWRlcyhlLnR5cGUpKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldmVudC50eXBlID09PSAndHgnKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgdHJhbnNhY3Rpb24gZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuZmlsdGVyKGUgPT4gZS50eXBlID09PSAndHgnKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YWcgPSAndHgnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnQuZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3ViSWQgPSB0aGlzLl9zdWJJZHNbdGFnXTtcclxuICAgICAgICBpZiAoIXN1YklkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N1Yklkc1t0YWddO1xyXG4gICAgICAgIHZvaWQgc3ViSWQudGhlbihzdWJJZCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3Vic1tzdWJJZF0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic1tzdWJJZF07XHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5zZW5kKCdldGhfdW5zdWJzY3JpYmUnLCBbc3ViSWRdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGFkZFNvY2tldExpc3RlbmVycygpIHtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuaGFuZGxlTWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlb3BlbicsIHRoaXMuaGFuZGxlUmVvcGVuKTtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZG93bicsIHRoaXMuc3RvcEhlYXJ0YmVhdEFuZEJhY2tmaWxsKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHJlbW92ZVNvY2tldExpc3RlbmVycygpIHtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuaGFuZGxlTWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlb3BlbicsIHRoaXMuaGFuZGxlUmVvcGVuKTtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZG93bicsIHRoaXMuc3RvcEhlYXJ0YmVhdEFuZEJhY2tmaWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVvcGVucyB0aGUgYmFja2ZpbGwgYmFzZWQgb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXNDYW5jZWxsZWRcclxuICAgICAqIEBwYXJhbSBzdWJzY3JpcHRpb25cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICByZXN1YnNjcmliZUFuZEJhY2tmaWxsKGlzQ2FuY2VsbGVkLCBzdWJzY3JpcHRpb24pIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHZpcnR1YWxJZCwgbWV0aG9kLCBwYXJhbXMsIHNlbnRFdmVudHMsIGJhY2tmaWxsQnVmZmVyLCBzdGFydGluZ0Jsb2NrTnVtYmVyIH0gPSBzdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5pc0JhY2tmaWxsaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgYmFja2ZpbGxCdWZmZXIubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBoeXNpY2FsSWQgPSB5aWVsZCB0aGlzLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24ucGh5c2ljYWxJZCA9IHBoeXNpY2FsSWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQuc2V0KHBoeXNpY2FsSWQsIHZpcnR1YWxJZCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmFtc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25ld0hlYWRzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWNrZmlsbEV2ZW50cyA9IHlpZWxkIHdpdGhCYWNrb2ZmUmV0cmllcygoKSA9PiB3aXRoVGltZW91dCh0aGlzLmJhY2tmaWxsZXIuZ2V0TmV3SGVhZHNCYWNrZmlsbChpc0NhbmNlbGxlZCwgc2VudEV2ZW50cywgc3RhcnRpbmdCbG9ja051bWJlciksIEJBQ0tGSUxMX1RJTUVPVVQpLCBCQUNLRklMTF9SRVRSSUVTLCAoKSA9PiAhaXNDYW5jZWxsZWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBkZWR1cGVOZXdIZWFkcyhbLi4uYmFja2ZpbGxFdmVudHMsIC4uLmJhY2tmaWxsQnVmZmVyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuZW1pdE5ld0hlYWRzRXZlbnQodmlydHVhbElkLCBldmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbG9ncyc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gcGFyYW1zWzFdIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWNrZmlsbEV2ZW50cyA9IHlpZWxkIHdpdGhCYWNrb2ZmUmV0cmllcygoKSA9PiB3aXRoVGltZW91dCh0aGlzLmJhY2tmaWxsZXIuZ2V0TG9nc0JhY2tmaWxsKGlzQ2FuY2VsbGVkLCBmaWx0ZXIsIHNlbnRFdmVudHMsIHN0YXJ0aW5nQmxvY2tOdW1iZXIpLCBCQUNLRklMTF9USU1FT1VUKSwgQkFDS0ZJTExfUkVUUklFUywgKCkgPT4gIWlzQ2FuY2VsbGVkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gZGVkdXBlTG9ncyhbLi4uYmFja2ZpbGxFdmVudHMsIC4uLmJhY2tmaWxsQnVmZmVyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuZW1pdExvZ3NFdmVudCh2aXJ0dWFsSWQsIGV2ZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5pc0JhY2tmaWxsaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBiYWNrZmlsbEJ1ZmZlci5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBlbWl0TmV3SGVhZHNFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMuZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgZW1pdExvZ3NFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMuZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldExvZ3NCbG9ja051bWJlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHRvIGNvbnN1bWVycywgYnV0IGFsc28gcmVtZW1iZXJzIGl0IGluIGl0cyBzdWJzY3JpcHRpb25zJ3NcclxuICAgICAqIGBzZW50RXZlbnRzYCBidWZmZXIgc28gdGhhdCB3ZSBjYW4gZGV0ZWN0IHJlLW9yZ3MgaWYgdGhlIGNvbm5lY3Rpb24gZHJvcHNcclxuICAgICAqIGFuZCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldEJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5yZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRCbG9ja051bWJlcik7XHJcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQodmlydHVhbElkLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgZW1pdEV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KSB7XHJcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuZ2V0KHZpcnR1YWxJZCk7XHJcbiAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVtaXRHZW5lcmljRXZlbnQoc3Vic2NyaXB0aW9uLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0QmxvY2tOdW1iZXIpIHtcclxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC5nZXQodmlydHVhbElkKTtcclxuICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlYjMgbW9kaWZpZXMgdGhlc2UgZXZlbnQgb2JqZWN0cyBvbmNlIHdlIHBhc3MgdGhlbSBvbiAoY2hhbmdpbmcgaGV4XHJcbiAgICAgICAgLy8gbnVtYmVycyB0byBudW1iZXJzKS4gV2Ugd2FudCB0aGUgb3JpZ2luYWwgZXZlbnQsIHNvIG1ha2UgYSBkZWZlbnNpdmVcclxuICAgICAgICAvLyBjb3B5LlxyXG4gICAgICAgIGFkZFRvUGFzdEV2ZW50c0J1ZmZlcihzdWJzY3JpcHRpb24uc2VudEV2ZW50cywgT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KSwgZ2V0QmxvY2tOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgZW1pdEdlbmVyaWNFdmVudChzdWJzY3JpcHRpb24sIHJlc3VsdCkge1xyXG4gICAgICAgIGNvbnN0IGVtaXRGdW5jdGlvbiA9IHRoaXMuZW1pdFByb2Nlc3NGbihzdWJzY3JpcHRpb24uZXZlbnQpO1xyXG4gICAgICAgIGVtaXRGdW5jdGlvbihyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBoZWFydGJlYXQgdGhhdCBwaW5ncyB0aGUgd2Vic29ja2V0IHNlcnZlciBwZXJpb2RpY2FsbHkgdG8gZW5zdXJlXHJcbiAgICAgKiB0aGF0IHRoZSBjb25uZWN0aW9uIHN0YXlzIG9wZW4uXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0SGVhcnRiZWF0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHdpdGhUaW1lb3V0KHRoaXMuc2VuZCgnbmV0X3ZlcnNpb24nKSwgSEVBUlRCRUFUX1dBSVRfVElNRSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWJzb2NrZXQucmVjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgSEVBUlRCRUFUX0lOVEVSVkFMKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgc2VuZHMgdGhlIGJhdGNoIGNvbmN1cnJlbnRseSBhcyBpbmRpdmlkdWFsIHJlcXVlc3RzIHJhdGhlciB0aGFuXHJcbiAgICAgKiBhcyBhIGJhdGNoLCB3aGljaCB3YXMgdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uLiBUaGUgb3JpZ2luYWwgYmF0Y2ggbG9naWNcclxuICAgICAqIGlzIHByZXNlcnZlZCBpbiB0aGlzIGltcGxlbWVudGF0aW9uIGluIG9yZGVyIGZvciBmYXN0ZXIgcG9ydGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF5bG9hZFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE8oY2xlYW51cCk6IFJlZmFjdG9yIGFuZCByZW1vdmUgdXNhZ2VzIG9mIGBzZW5kQmF0Y2goKWAuXHJcbiAgICAvLyBUT0RPKGVycm9ycyk6IFVzZSBhbGxTZXR0bGVkKCkgb25jZSB3ZSBoYXZlIG1vcmUgZXJyb3IgaGFuZGxpbmcuXHJcbiAgICBzZW5kQmF0Y2hDb25jdXJyZW50bHkocGF5bG9hZCkge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwYXlsb2FkLm1hcChyZXEgPT4gdGhpcy5zZW5kKHJlcS5tZXRob2QsIHJlcS5wYXJhbXMpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjdXN0b21TdGFydEV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IGluZGV4LkFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGZyb21BZGRyZXNzLCB0b0FkZHJlc3MsIGhhc2hlc09ubHkgfSA9IGV2ZW50O1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3N1YnNjcmliZShldmVudC50YWcsIFtcclxuICAgICAgICAgICAgICAgIGluZGV4LkFsY2hlbXlTdWJzY3JpcHRpb24uUEVORElOR19UUkFOU0FDVElPTlMsXHJcbiAgICAgICAgICAgICAgICB7IGZyb21BZGRyZXNzLCB0b0FkZHJlc3MsIGhhc2hlc09ubHkgfVxyXG4gICAgICAgICAgICBdLCB0aGlzLmVtaXRQcm9jZXNzRm4oZXZlbnQpLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IGluZGV4LkFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBhZGRyZXNzZXMsIGluY2x1ZGVSZW1vdmVkLCBoYXNoZXNPbmx5IH0gPSBldmVudDtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLCBbXHJcbiAgICAgICAgICAgICAgICBpbmRleC5BbGNoZW15U3Vic2NyaXB0aW9uLk1JTkVEX1RSQU5TQUNUSU9OUyxcclxuICAgICAgICAgICAgICAgIHsgYWRkcmVzc2VzLCBpbmNsdWRlUmVtb3ZlZCwgaGFzaGVzT25seSB9XHJcbiAgICAgICAgICAgIF0sIHRoaXMuZW1pdFByb2Nlc3NGbihldmVudCksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2Jsb2NrJykge1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3N1YnNjcmliZSgnYmxvY2snLCBbJ25ld0hlYWRzJ10sIHRoaXMuZW1pdFByb2Nlc3NGbihldmVudCksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2ZpbHRlcicpIHtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLCBbJ2xvZ3MnLCB0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0sIHRoaXMuZW1pdFByb2Nlc3NGbihldmVudCksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBlbWl0UHJvY2Vzc0ZuKGV2ZW50KSB7XHJcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgaW5kZXguQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PiB0aGlzLmVtaXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogaW5kZXguQWxjaGVteVN1YnNjcmlwdGlvbi5QRU5ESU5HX1RSQU5TQUNUSU9OUyxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tQWRkcmVzczogZXZlbnQuZnJvbUFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9BZGRyZXNzOiBldmVudC50b0FkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVzT25seTogZXZlbnQuaGFzaGVzT25seVxyXG4gICAgICAgICAgICAgICAgfSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgY2FzZSBpbmRleC5BTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PiB0aGlzLmVtaXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogaW5kZXguQWxjaGVteVN1YnNjcmlwdGlvbi5NSU5FRF9UUkFOU0FDVElPTlMsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBldmVudC5hZGRyZXNzZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZVJlbW92ZWQ6IGV2ZW50LmluY2x1ZGVSZW1vdmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc2hlc09ubHk6IGV2ZW50Lmhhc2hlc09ubHlcclxuICAgICAgICAgICAgICAgIH0sIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHJlc3VsdC5udW1iZXIpLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYmxvY2snLCBibG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlICdmaWx0ZXInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZW1vdmVkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LmZpbHRlciwgdGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nKHJlc3VsdCkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBldmVudCB0eXBlIHRvIGBlbWl0UHJvY2Vzc0ZuKClgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXIub2ZmKClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdG9wcGVkID0gW107XHJcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBpbmRleC5nZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcgfHwgZXZlbnQubGlzdGVuZXIgIT0gbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgQmFzZVByb3ZpZGVyLnJlbW92ZUFsbExpc3RlbmVycygpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgQWxjaGVteSdzIHVuaXF1ZVxyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGVzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhpcyBtZXRob2QgY2FsbHNcclxuICAgICAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGBnZXRFdmVudFRhZygpYCBtZXRob2QgaW5cclxuICAgICAqIG9yZGVyIHRvIHBhcnNlIHRoZSBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGxldCBzdG9wcGVkID0gW107XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0aGlzLl9ldmVudHM7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBpbmRleC5nZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaChldmVudCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BFdmVudChldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEJhc2VQcm92aWRlci5saXN0ZW5lckNvdW50KClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmICghZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBldmVudFRhZyA9IGluZGV4LmdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnRhZyA9PT0gZXZlbnRUYWc7XHJcbiAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXIubGlzdGVuZXJzKClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9saXN0ZW5lcnMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubWFwKGV2ZW50ID0+IGV2ZW50Lmxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBpbmRleC5nZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZXZlbnQgPT4gZXZlbnQudGFnID09PSBldmVudFRhZylcclxuICAgICAgICAgICAgLm1hcChldmVudCA9PiBldmVudC5saXN0ZW5lcik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2Vic29ja2V0Q29uc3RydWN0b3IoKSB7XHJcbiAgICByZXR1cm4gaXNOb2RlRW52aXJvbm1lbnQoKSA/IHJlcXVpcmUoJ3dlYnNvY2tldCcpLnczY3dlYnNvY2tldCA6IFdlYlNvY2tldDtcclxufVxyXG5mdW5jdGlvbiBpc05vZGVFbnZpcm9ubWVudCgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgcHJvY2VzcyAhPSBudWxsICYmXHJcbiAgICAgICAgcHJvY2Vzcy52ZXJzaW9ucyAhPSBudWxsICYmXHJcbiAgICAgICAgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9IG51bGwpO1xyXG59XHJcbi8vIFRPRE8oY2xlYW51cCk6IFVzZSBjbGFzcyB2YXJpYWJsZSByYXRoZXIgdGhhbiBwYXNzaW5nIGBpc0NhbmNlbGxlZGAgZXZlcnl3aGVyZS5cclxuZnVuY3Rpb24gbWFrZUNhbmNlbFRva2VuKCkge1xyXG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHsgY2FuY2VsOiAoKSA9PiAoY2FuY2VsbGVkID0gdHJ1ZSksIGlzQ2FuY2VsbGVkOiAoKSA9PiBjYW5jZWxsZWQgfTtcclxufVxyXG4vLyBUT0RPKGNsZWFudXApOiByZXBsYWNlIHdpdGggU0RLJ3MgYmFja29mZiBpbXBsZW1lbnRhdGlvblxyXG5jb25zdCBNSU5fUkVUUllfREVMQVkgPSAxMDAwO1xyXG5jb25zdCBSRVRSWV9CQUNLT0ZGX0ZBQ1RPUiA9IDI7XHJcbmNvbnN0IE1BWF9SRVRSWV9ERUxBWSA9IDMwMDAwO1xyXG5mdW5jdGlvbiB3aXRoQmFja29mZlJldHJpZXMoZiwgcmV0cnlDb3VudCwgc2hvdWxkUmV0cnkgPSAoKSA9PiB0cnVlKSB7XHJcbiAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGxldCBuZXh0V2FpdFRpbWUgPSAwO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGYoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIGlmIChpID49IHJldHJ5Q291bnQgfHwgIXNob3VsZFJldHJ5KGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeWllbGQgZGVsYXkobmV4dFdhaXRUaW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnkoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0V2FpdFRpbWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRXYWl0VGltZSA9PT0gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE1JTl9SRVRSWV9ERUxBWVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKE1BWF9SRVRSWV9ERUxBWSwgUkVUUllfQkFDS09GRl9GQUNUT1IgKiBuZXh0V2FpdFRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZGVsYXkobXMpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcclxufVxyXG5mdW5jdGlvbiB3aXRoVGltZW91dChwcm9taXNlLCBtcykge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbXHJcbiAgICAgICAgcHJvbWlzZSxcclxuICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQnKSksIG1zKSlcclxuICAgIF0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIoZXZlbnQpIHtcclxuICAgIHJldHVybiBpbmRleC5mcm9tSGV4KGV2ZW50Lm51bWJlcik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TG9nc0Jsb2NrTnVtYmVyKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gaW5kZXguZnJvbUhleChldmVudC5ibG9ja051bWJlcik7XHJcbn1cclxuZnVuY3Rpb24gaXNSZXNwb25zZShtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkobWVzc2FnZSkgfHxcclxuICAgICAgICAobWVzc2FnZS5qc29ucnBjID09PSAnMi4wJyAmJiBtZXNzYWdlLmlkICE9PSB1bmRlZmluZWQpKTtcclxufVxyXG5mdW5jdGlvbiBpc1N1YnNjcmlwdGlvbkV2ZW50KG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiAhaXNSZXNwb25zZShtZXNzYWdlKTtcclxufVxyXG5mdW5jdGlvbiBhZGRUb05ld0hlYWRzRXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50KSB7XHJcbiAgICBhZGRUb1Bhc3RFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQsIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFRvTG9nc0V2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCkge1xyXG4gICAgYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGEgbmV3IGV2ZW50IHRvIGFuIGFycmF5IG9mIGV2ZW50cywgZXZpY3RpbmcgYW55IGV2ZW50cyB3aGljaCBhcmUgc28gb2xkXHJcbiAqIHRoYXQgdGhleSB3aWxsIG5vIGxvbmdlciBmZWFzaWJseSBiZSBwYXJ0IG9mIGEgcmVvcmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRUb1Bhc3RFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQsIGdldEJsb2NrTnVtYmVyKSB7XHJcbiAgICBjb25zdCBjdXJyZW50QmxvY2tOdW1iZXIgPSBnZXRCbG9ja051bWJlcihldmVudCk7XHJcbiAgICAvLyBGaW5kIGZpcnN0IGluZGV4IG9mIGFuIGV2ZW50IHJlY2VudCBlbm91Z2ggdG8gcmV0YWluLCB0aGVuIGRyb3AgZXZlcnl0aGluZ1xyXG4gICAgLy8gYXQgYSBsb3dlciBpbmRleC5cclxuICAgIGNvbnN0IGZpcnN0R29vZEluZGV4ID0gcGFzdEV2ZW50cy5maW5kSW5kZXgoZSA9PiBnZXRCbG9ja051bWJlcihlKSA+IGN1cnJlbnRCbG9ja051bWJlciAtIFJFVEFJTkVEX0VWRU5UX0JMT0NLX0NPVU5UKTtcclxuICAgIGlmIChmaXJzdEdvb2RJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBwYXN0RXZlbnRzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYXN0RXZlbnRzLnNwbGljZSgwLCBmaXJzdEdvb2RJbmRleCk7XHJcbiAgICB9XHJcbiAgICBwYXN0RXZlbnRzLnB1c2goZXZlbnQpO1xyXG59XG5cbmV4cG9ydHMuQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyID0gQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxjaGVteS13ZWJzb2NrZXQtcHJvdmlkZXItMmRhZmE5ZTQuanMubWFwXG4iXSwibmFtZXMiOlsiaW5kZXgiLCJyZXF1aXJlIiwiU3R1cmR5V2ViU29ja2V0IiwiYmlnbnVtYmVyIiwibmV0d29ya3MiLCJwcm92aWRlcnMiLCJhbGNoZW15UHJvdmlkZXIiLCJfaW50ZXJvcERlZmF1bHRMZWdhY3kiLCJlIiwiU3R1cmR5V2ViU29ja2V0X19kZWZhdWx0IiwiTUFYX0JBQ0tGSUxMX0JMT0NLUyIsIldlYnNvY2tldEJhY2tmaWxsZXIiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVyIiwibWF4QmFja2ZpbGxCbG9ja3MiLCJnZXROZXdIZWFkc0JhY2tmaWxsIiwiaXNDYW5jZWxsZWQiLCJwcmV2aW91c0hlYWRzIiwiZnJvbUJsb2NrTnVtYmVyIiwiX19hd2FpdGVyIiwidGhyb3dJZkNhbmNlbGxlZCIsInRvQmxvY2tOdW1iZXIiLCJnZXRCbG9ja051bWJlciIsImxlbmd0aCIsImdldEhlYWRFdmVudHNJblJhbmdlIiwiTWF0aCIsIm1heCIsImxhc3RTZWVuQmxvY2tOdW1iZXIiLCJmcm9tSGV4IiwibnVtYmVyIiwibWluQmxvY2tOdW1iZXIiLCJyZW9yZ0hlYWRzIiwiZ2V0UmVvcmdIZWFkcyIsImludGVybWVkaWF0ZUhlYWRzIiwiZ2V0TG9nc0JhY2tmaWxsIiwiZmlsdGVyIiwicHJldmlvdXNMb2dzIiwiZ2V0TG9nc0luUmFuZ2UiLCJibG9ja051bWJlciIsImNvbW1vbkFuY2VzdG9yIiwiZ2V0Q29tbW9uQW5jZXN0b3IiLCJyZW1vdmVkTG9ncyIsImxvZyIsIm1hcCIsIk9iamVjdCIsImFzc2lnbiIsInJlbW92ZWQiLCJmcm9tQmxvY2tJbmNsdXNpdmUiLCJOdW1iZXIiLCJORUdBVElWRV9JTkZJTklUWSIsImFkZGVkTG9ncyIsImxvZ0luZGV4Iiwic2V0TWF4QmFja2ZpbGxCbG9jayIsIm5ld01heCIsImJsb2NrTnVtYmVySGV4Iiwic2VuZCIsInRvQmxvY2tFeGNsdXNpdmUiLCJiYXRjaFBhcnRzIiwiaSIsInB1c2giLCJtZXRob2QiLCJwYXJhbXMiLCJ0b0hleCIsImJsb2NrSGVhZHMiLCJzZW5kQmF0Y2giLCJ0b05ld0hlYWRzRXZlbnQiLCJyZXN1bHQiLCJvbGRFdmVudCIsImJsb2NrSGVhZCIsImdldEJsb2NrQnlOdW1iZXIiLCJoYXNoIiwicmV2ZXJzZSIsIm9sZExvZyIsImJsb2NrSGFzaCIsInJhbmdlRmlsdGVyIiwiZnJvbUJsb2NrIiwidG9CbG9jayIsImhlYWQiLCJ0b3RhbERpZmZpY3VsdHkiLCJ0cmFuc2FjdGlvbnMiLCJ1bmNsZXMiLCJkZWR1cGVOZXdIZWFkcyIsImV2ZW50cyIsImRlZHVwZSIsImV2ZW50IiwiZGVkdXBlTG9ncyIsIml0ZW1zIiwiZ2V0S2V5Iiwia2V5c1NlZW4iLCJTZXQiLCJmb3JFYWNoIiwiaXRlbSIsImtleSIsImhhcyIsImFkZCIsIkNBTkNFTExFRCIsIkVycm9yIiwiSEVBUlRCRUFUX0lOVEVSVkFMIiwiSEVBUlRCRUFUX1dBSVRfVElNRSIsIkJBQ0tGSUxMX1RJTUVPVVQiLCJCQUNLRklMTF9SRVRSSUVTIiwiUkVUQUlORURfRVZFTlRfQkxPQ0tfQ09VTlQiLCJBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIiLCJXZWJTb2NrZXRQcm92aWRlciIsImNvbmZpZyIsIndzQ29uc3RydWN0b3IiLCJfYSIsImFwaUtleSIsIkFsY2hlbXlQcm92aWRlciIsImdldEFwaUtleSIsImFsY2hlbXlOZXR3b3JrIiwiZ2V0QWxjaGVteU5ldHdvcmsiLCJuZXR3b3JrIiwiY29ubmVjdGlvbiIsImdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyIsInByb3RvY29sIiwiVkVSU0lPTiIsIndzIiwidXJsIiwiZ2V0V2Vic29ja2V0Q29uc3RydWN0b3IiLCJldGhlcnNOZXR3b3JrIiwiRXRoZXJzTmV0d29yayIsInVuZGVmaW5lZCIsIl9ldmVudHMiLCJ2aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQiLCJNYXAiLCJ2aXJ0dWFsSWRzQnlQaHlzaWNhbElkIiwiaGFuZGxlTWVzc2FnZSIsIm1lc3NhZ2UiLCJKU09OIiwicGFyc2UiLCJkYXRhIiwiaXNTdWJzY3JpcHRpb25FdmVudCIsInBoeXNpY2FsSWQiLCJzdWJzY3JpcHRpb24iLCJ2aXJ0dWFsSWQiLCJnZXQiLCJuZXdIZWFkc1N1YnNjcmlwdGlvbiIsIm5ld0hlYWRzTWVzc2FnZSIsImlzQmFja2ZpbGxpbmciLCJiYWNrZmlsbEJ1ZmZlciIsImFkZFRvTmV3SGVhZHNFdmVudHNCdWZmZXIiLCJlbWl0QW5kUmVtZW1iZXJFdmVudCIsImdldE5ld0hlYWRzQmxvY2tOdW1iZXIiLCJyZW1lbWJlckV2ZW50IiwibG9nc1N1YnNjcmlwdGlvbiIsImxvZ3NNZXNzYWdlIiwiYWRkVG9Mb2dzRXZlbnRzQnVmZmVyIiwiZ2V0TG9nc0Jsb2NrTnVtYmVyIiwiZW1pdEV2ZW50IiwiaGFuZGxlUmVvcGVuIiwiY2xlYXIiLCJjYW5jZWwiLCJtYWtlQ2FuY2VsVG9rZW4iLCJjYW5jZWxCYWNrZmlsbCIsInZhbHVlcyIsInJlc3Vic2NyaWJlQW5kQmFja2ZpbGwiLCJlcnJvciIsImNvbnNvbGUiLCJzdGFydEhlYXJ0YmVhdCIsInN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCIsImhlYXJ0YmVhdEludGVydmFsSWQiLCJjbGVhckludGVydmFsIiwiYmFja2ZpbGxlciIsImFkZFNvY2tldExpc3RlbmVycyIsIm5vb3AiLCJnZXROZXR3b3JrIiwiQ3VzdG9tTmV0d29ya3MiLCJvbiIsImV2ZW50TmFtZSIsImxpc3RlbmVyIiwiX2FkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwiaXNBbGNoZW15RXZlbnQiLCJfb2ZmIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiX3JlbW92ZUFsbExpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJfbGlzdGVuZXJDb3VudCIsImxpc3RlbmVycyIsIl9saXN0ZW5lcnMiLCJ2ZXJpZnlBbGNoZW15RXZlbnROYW1lIiwiRXRoZXJzRXZlbnQiLCJnZXRBbGNoZW15RXZlbnRUYWciLCJfc3RhcnRFdmVudCIsImN1c3RvbUxvZ2ljVHlwZXMiLCJBTENIRU1ZX0VWRU5UX1RZUEVTIiwiaW5jbHVkZXMiLCJ0eXBlIiwiY3VzdG9tU3RhcnRFdmVudCIsIl9zdWJzY3JpYmUiLCJ0YWciLCJwYXJhbSIsInByb2Nlc3NGdW5jIiwic3ViSWRQcm9taXNlIiwiX3N1YklkcyIsInN0YXJ0aW5nQmxvY2tOdW1iZXIiLCJQcm9taXNlIiwiYWxsIiwidGhlbiIsInN1YklkIiwicmVzb2x2ZWRQYXJhbXMiLCJzZXQiLCJzZW50RXZlbnRzIiwiX3N1YnMiLCJlbWl0IiwiYXJncyIsInN0b3BwZWQiLCJldmVudFRhZyIsInNldFRpbWVvdXQiLCJhcHBseSIsIl9zdG9wRXZlbnQiLCJwYXJ0cyIsIm5leHRJZCIsInBheWxvYWQiLCJqc29ucnBjIiwiaWQiLCJzZW5kQmF0Y2hDb25jdXJyZW50bHkiLCJkZXN0cm95IiwicmVtb3ZlU29ja2V0TGlzdGVuZXJzIiwiaXNDb21tdW5pdHlSZXNvdXJjZSIsIkRFRkFVTFRfQUxDSEVNWV9BUElfS0VZIiwiX3dlYnNvY2tldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYmFja2ZpbGxFdmVudHMiLCJ3aXRoQmFja29mZlJldHJpZXMiLCJ3aXRoVGltZW91dCIsImVtaXROZXdIZWFkc0V2ZW50IiwiZW1pdExvZ3NFdmVudCIsImVtaXRHZW5lcmljRXZlbnQiLCJhZGRUb1Bhc3RFdmVudHNCdWZmZXIiLCJlbWl0RnVuY3Rpb24iLCJlbWl0UHJvY2Vzc0ZuIiwic2V0SW50ZXJ2YWwiLCJyZWNvbm5lY3QiLCJyZXEiLCJBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUiLCJmcm9tQWRkcmVzcyIsInRvQWRkcmVzcyIsImhhc2hlc09ubHkiLCJBbGNoZW15U3Vic2NyaXB0aW9uIiwiUEVORElOR19UUkFOU0FDVElPTlMiLCJBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFIiwiYWRkcmVzc2VzIiwiaW5jbHVkZVJlbW92ZWQiLCJNSU5FRF9UUkFOU0FDVElPTlMiLCJfZ2V0RmlsdGVyIiwiQmlnTnVtYmVyIiwiZnJvbSIsInRvTnVtYmVyIiwiX2VtaXR0ZWQiLCJibG9jayIsImZvcm1hdHRlciIsImZpbHRlckxvZyIsImZvdW5kIiwiaXNOb2RlRW52aXJvbm1lbnQiLCJ3M2N3ZWJzb2NrZXQiLCJXZWJTb2NrZXQiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJub2RlIiwiY2FuY2VsbGVkIiwiTUlOX1JFVFJZX0RFTEFZIiwiUkVUUllfQkFDS09GRl9GQUNUT1IiLCJNQVhfUkVUUllfREVMQVkiLCJmIiwicmV0cnlDb3VudCIsInNob3VsZFJldHJ5IiwibmV4dFdhaXRUaW1lIiwiZGVsYXkiLCJtaW4iLCJtcyIsInJlc29sdmUiLCJwcm9taXNlIiwicmFjZSIsIl8iLCJyZWplY3QiLCJpc1Jlc3BvbnNlIiwiQXJyYXkiLCJpc0FycmF5IiwicGFzdEV2ZW50cyIsImN1cnJlbnRCbG9ja051bWJlciIsImZpcnN0R29vZEluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-2dafa9e4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/cjs/api/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar hash = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/index.js\");\nvar bytes = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\nvar units = __webpack_require__(/*! @ethersproject/units */ \"(ssr)/./node_modules/@ethersproject/units/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\nvar abi = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/@ethersproject/abi/lib.esm/index.js\");\nconst version$1 = \"logger/5.7.0\";\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = {\n    debug: 1,\n    \"default\": 2,\n    info: 2,\n    warning: 3,\n    error: 4,\n    off: 5\n};\nlet _logLevel = LogLevels[\"default\"];\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\n            \"NFD\",\n            \"NFC\",\n            \"NFKD\",\n            \"NFKC\"\n        ].forEach((form)=>{\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            } catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    } catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\nconst HEX = \"0123456789abcdef\";\nclass Logger {\n    constructor(version){\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key)=>{\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for(let i = 0; i < value.length; i++){\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch(code){\n            case ErrorCode.NUMERIC_FAULT:\n                {\n                    url = \"NUMERIC_FAULT\";\n                    const fault = message;\n                    switch(fault){\n                        case \"overflow\":\n                        case \"underflow\":\n                        case \"division-by-zero\":\n                            url += \"-\" + fault;\n                            break;\n                        case \"negative-power\":\n                        case \"negative-width\":\n                            url += \"-unsupported\";\n                            break;\n                        case \"unbound-bitwise-result\":\n                            url += \"-unbound-result\";\n                            break;\n                    }\n                    break;\n                }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https://links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\",\n                form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof value !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, {\n                name: target.name,\n                operation: \"new\"\n            });\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(version$1);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\nconst version = \"strings/5.7.0\";\nconst logger = new Logger(version);\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function(UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\nvar Utf8ErrorReason;\n(function(Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes);\n}\n// Common error handing strategies\nconst Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes$1, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    bytes$1 = bytes.arrayify(bytes$1);\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes$1.length){\n        const c = bytes$1[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes$1, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes$1, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes$1.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes$1, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes$1[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes$1, result);\n                res = null;\n                break;\n            }\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes$1, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes$1, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes$1, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return bytes.arrayify(result);\n}\nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nfunction bytes2(data) {\n    if (data.length % 4 !== 0) {\n        throw new Error(\"bad data\");\n    }\n    let result = [];\n    for(let i = 0; i < data.length; i += 4){\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\nfunction createTable(data, func) {\n    if (!func) {\n        func = function(value) {\n            return [\n                parseInt(value, 16)\n            ];\n        };\n    }\n    let lo = 0;\n    let result = {};\n    data.split(\",\").forEach((pair)=>{\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n    return result;\n}\nfunction createRangeTable(data) {\n    let hi = 0;\n    return data.split(\",\").map((v)=>{\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        } else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return {\n            l: lo,\n            h: hi\n        };\n    });\n}\ncreateRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n// @TODO: Make this relative...\n\"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v)=>parseInt(v, 16));\ncreateTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\ncreateTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\ncreateTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\ncreateRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\nObject.defineProperty(exports, \"dnsEncode\", ({\n    enumerable: true,\n    get: function() {\n        return hash.dnsEncode;\n    }\n}));\nObject.defineProperty(exports, \"hashMessage\", ({\n    enumerable: true,\n    get: function() {\n        return hash.hashMessage;\n    }\n}));\nObject.defineProperty(exports, \"id\", ({\n    enumerable: true,\n    get: function() {\n        return hash.id;\n    }\n}));\nObject.defineProperty(exports, \"isValidName\", ({\n    enumerable: true,\n    get: function() {\n        return hash.isValidName;\n    }\n}));\nObject.defineProperty(exports, \"namehash\", ({\n    enumerable: true,\n    get: function() {\n        return hash.namehash;\n    }\n}));\nObject.defineProperty(exports, \"arrayify\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.arrayify;\n    }\n}));\nObject.defineProperty(exports, \"concat\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.concat;\n    }\n}));\nObject.defineProperty(exports, \"hexConcat\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexConcat;\n    }\n}));\nObject.defineProperty(exports, \"hexDataLength\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexDataLength;\n    }\n}));\nObject.defineProperty(exports, \"hexDataSlice\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexDataSlice;\n    }\n}));\nObject.defineProperty(exports, \"hexStripZeros\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexStripZeros;\n    }\n}));\nObject.defineProperty(exports, \"hexValue\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexValue;\n    }\n}));\nObject.defineProperty(exports, \"hexZeroPad\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexZeroPad;\n    }\n}));\nObject.defineProperty(exports, \"hexlify\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexlify;\n    }\n}));\nObject.defineProperty(exports, \"isBytes\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.isBytes;\n    }\n}));\nObject.defineProperty(exports, \"isBytesLike\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.isBytesLike;\n    }\n}));\nObject.defineProperty(exports, \"isHexString\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.isHexString;\n    }\n}));\nObject.defineProperty(exports, \"joinSignature\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.joinSignature;\n    }\n}));\nObject.defineProperty(exports, \"splitSignature\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.splitSignature;\n    }\n}));\nObject.defineProperty(exports, \"stripZeros\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.stripZeros;\n    }\n}));\nObject.defineProperty(exports, \"zeroPad\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.zeroPad;\n    }\n}));\nObject.defineProperty(exports, \"formatEther\", ({\n    enumerable: true,\n    get: function() {\n        return units.formatEther;\n    }\n}));\nObject.defineProperty(exports, \"formatUnits\", ({\n    enumerable: true,\n    get: function() {\n        return units.formatUnits;\n    }\n}));\nObject.defineProperty(exports, \"parseEther\", ({\n    enumerable: true,\n    get: function() {\n        return units.parseEther;\n    }\n}));\nObject.defineProperty(exports, \"parseUnits\", ({\n    enumerable: true,\n    get: function() {\n        return units.parseUnits;\n    }\n}));\nObject.defineProperty(exports, \"Interface\", ({\n    enumerable: true,\n    get: function() {\n        return abi.Interface;\n    }\n}));\nexports.toUtf8Bytes = toUtf8Bytes;\nexports.toUtf8String = toUtf8String; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvYXBpL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUNSLElBQUlHLE1BQU1ILG1CQUFPQSxDQUFDO0FBRWxCLE1BQU1JLFlBQVk7QUFFbEIsSUFBSUMseUJBQXlCO0FBQzdCLElBQUlDLGdCQUFnQjtBQUNwQixNQUFNQyxZQUFZO0lBQUVDLE9BQU87SUFBRyxXQUFXO0lBQUdDLE1BQU07SUFBR0MsU0FBUztJQUFHQyxPQUFPO0lBQUdDLEtBQUs7QUFBRTtBQUNsRixJQUFJQyxZQUFZTixTQUFTLENBQUMsVUFBVTtBQUNwQyxJQUFJTyxnQkFBZ0I7QUFDcEIsU0FBU0M7SUFDTCxJQUFJO1FBQ0EsTUFBTUMsVUFBVSxFQUFFO1FBQ2xCLHFEQUFxRDtRQUNyRDtZQUFDO1lBQU87WUFBTztZQUFRO1NBQU8sQ0FBQ0MsT0FBTyxDQUFDLENBQUNDO1lBQ3BDLElBQUk7Z0JBQ0EsSUFBSSxPQUFPQyxTQUFTLENBQUNELFVBQVUsUUFBUTtvQkFDbkMsTUFBTSxJQUFJRSxNQUFNO2dCQUNwQjs7WUFFSixFQUNBLE9BQU9ULE9BQU87Z0JBQ1ZLLFFBQVFLLElBQUksQ0FBQ0g7WUFDakI7UUFDSjtRQUNBLElBQUlGLFFBQVFNLE1BQU0sRUFBRTtZQUNoQixNQUFNLElBQUlGLE1BQU0sYUFBYUosUUFBUU8sSUFBSSxDQUFDO1FBQzlDO1FBQ0EsSUFBSUMsT0FBT0MsWUFBWSxDQUFDLE1BQU1OLFNBQVMsQ0FBQyxXQUFXSyxPQUFPQyxZQUFZLENBQUMsTUFBTSxTQUFTO1lBQ2xGLE1BQU0sSUFBSUwsTUFBTTtRQUNwQjtJQUNKLEVBQ0Es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WjRILEtBQUs7UUFBYyxPQUFPN0osTUFBTWlMLE9BQU87SUFBRTtBQUM3QyxDQUFDLEVBQUM7QUFDRnZMLCtDQUE4QztJQUMxQ3VDLFlBQVk7SUFDWjRILEtBQUs7UUFBYyxPQUFPNUosTUFBTWlMLFdBQVc7SUFBRTtBQUNqRCxDQUFDLEVBQUM7QUFDRnhMLCtDQUE4QztJQUMxQ3VDLFlBQVk7SUFDWjRILEtBQUs7UUFBYyxPQUFPNUosTUFBTWtMLFdBQVc7SUFBRTtBQUNqRCxDQUFDLEVBQUM7QUFDRnpMLDhDQUE2QztJQUN6Q3VDLFlBQVk7SUFDWjRILEtBQUs7UUFBYyxPQUFPNUosTUFBTW1MLFVBQVU7SUFBRTtBQUNoRCxDQUFDLEVBQUM7QUFDRjFMLDhDQUE2QztJQUN6Q3VDLFlBQVk7SUFDWjRILEtBQUs7UUFBYyxPQUFPNUosTUFBTW9MLFVBQVU7SUFBRTtBQUNoRCxDQUFDLEVBQUM7QUFDRjNMLDZDQUE0QztJQUN4Q3VDLFlBQVk7SUFDWjRILEtBQUs7UUFBYyxPQUFPM0osSUFBSW9MLFNBQVM7SUFBRTtBQUM3QyxDQUFDLEVBQUM7QUFDRjFMLG1CQUFtQixHQUFHd0k7QUFDdEJ4SSxvQkFBb0IsR0FBR2tKLGNBQ3ZCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL21pc3Npb24tbGF1bmNoLWJ1cm4tb3ItZ2xvcnkvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvYXBpL3V0aWxzLmpzP2M4YjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2hhc2gnKTtcbnZhciBieXRlcyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2J5dGVzJyk7XG52YXIgdW5pdHMgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC91bml0cycpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyJyk7XG52YXIgYWJpID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYWJpJyk7XG5cbmNvbnN0IHZlcnNpb24kMSA9IFwibG9nZ2VyLzUuNy4wXCI7XG5cbmxldCBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gZmFsc2U7XG5sZXQgX2NlbnNvckVycm9ycyA9IGZhbHNlO1xuY29uc3QgTG9nTGV2ZWxzID0geyBkZWJ1ZzogMSwgXCJkZWZhdWx0XCI6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcbmxldCBfbG9nTGV2ZWwgPSBMb2dMZXZlbHNbXCJkZWZhdWx0XCJdO1xubGV0IF9nbG9iYWxMb2dnZXIgPSBudWxsO1xuZnVuY3Rpb24gX2NoZWNrTm9ybWFsaXplKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCBmb3JtcyBvZiBub3JtYWxpemF0aW9uIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0uZm9yRWFjaCgoZm9ybSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbm9ybWFsaXplXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWlzc2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgXCIgKyBtaXNzaW5nLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpICE9PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlbiBpbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgX25vcm1hbGl6ZUVycm9yID0gX2NoZWNrTm9ybWFsaXplKCk7XG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbXCJERUJVR1wiXSA9IFwiREVCVUdcIjtcbiAgICBMb2dMZXZlbFtcIklORk9cIl0gPSBcIklORk9cIjtcbiAgICBMb2dMZXZlbFtcIldBUk5JTkdcIl0gPSBcIldBUk5JTkdcIjtcbiAgICBMb2dMZXZlbFtcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xuICAgIExvZ0xldmVsW1wiT0ZGXCJdID0gXCJPRkZcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG52YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gR2VuZXJpYyBFcnJvcnNcbiAgICAvLyBVbmtub3duIEVycm9yXG4gICAgRXJyb3JDb2RlW1wiVU5LTk9XTl9FUlJPUlwiXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuICAgIC8vIE5vdCBJbXBsZW1lbnRlZFxuICAgIEVycm9yQ29kZVtcIk5PVF9JTVBMRU1FTlRFRFwiXSA9IFwiTk9UX0lNUExFTUVOVEVEXCI7XG4gICAgLy8gVW5zdXBwb3J0ZWQgT3BlcmF0aW9uXG4gICAgLy8gICAtIG9wZXJhdGlvblxuICAgIEVycm9yQ29kZVtcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiXSA9IFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCI7XG4gICAgLy8gTmV0d29yayBFcnJvciAoaS5lLiBFdGhlcmV1bSBOZXR3b3JrLCBzdWNoIGFzIGFuIGludmFsaWQgY2hhaW4gSUQpXG4gICAgLy8gICAtIGV2ZW50IChcIm5vTmV0d29ya1wiIGlzIG5vdCByZS10aHJvd24gaW4gcHJvdmlkZXIucmVhZHk7IG90aGVyd2lzZSB0aHJvd24pXG4gICAgRXJyb3JDb2RlW1wiTkVUV09SS19FUlJPUlwiXSA9IFwiTkVUV09SS19FUlJPUlwiO1xuICAgIC8vIFNvbWUgc29ydCBvZiBiYWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gICAgRXJyb3JDb2RlW1wiU0VSVkVSX0VSUk9SXCJdID0gXCJTRVJWRVJfRVJST1JcIjtcbiAgICAvLyBUaW1lb3V0XG4gICAgRXJyb3JDb2RlW1wiVElNRU9VVFwiXSA9IFwiVElNRU9VVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBPcGVyYXRpb25hbCAgRXJyb3JzXG4gICAgLy8gQnVmZmVyIE92ZXJydW5cbiAgICBFcnJvckNvZGVbXCJCVUZGRVJfT1ZFUlJVTlwiXSA9IFwiQlVGRkVSX09WRVJSVU5cIjtcbiAgICAvLyBOdW1lcmljIEZhdWx0XG4gICAgLy8gICAtIG9wZXJhdGlvbjogdGhlIG9wZXJhdGlvbiBiZWluZyBleGVjdXRlZFxuICAgIC8vICAgLSBmYXVsdDogdGhlIHJlYXNvbiB0aGlzIGZhdWx0ZWRcbiAgICBFcnJvckNvZGVbXCJOVU1FUklDX0ZBVUxUXCJdID0gXCJOVU1FUklDX0ZBVUxUXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEFyZ3VtZW50IEVycm9yc1xuICAgIC8vIE1pc3NpbmcgbmV3IG9wZXJhdG9yIHRvIGFuIG9iamVjdFxuICAgIC8vICAtIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfTkVXXCJdID0gXCJNSVNTSU5HX05FV1wiO1xuICAgIC8vIEludmFsaWQgYXJndW1lbnQgKGUuZy4gdmFsdWUgaXMgaW5jb21wYXRpYmxlIHdpdGggdHlwZSkgdG8gYSBmdW5jdGlvbjpcbiAgICAvLyAgIC0gYXJndW1lbnQ6IFRoZSBhcmd1bWVudCBuYW1lIHRoYXQgd2FzIGludmFsaWRcbiAgICAvLyAgIC0gdmFsdWU6IFRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnRcbiAgICBFcnJvckNvZGVbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XG4gICAgLy8gTWlzc2luZyBhcmd1bWVudCB0byBhIGZ1bmN0aW9uOlxuICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcbiAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcbiAgICBFcnJvckNvZGVbXCJNSVNTSU5HX0FSR1VNRU5UXCJdID0gXCJNSVNTSU5HX0FSR1VNRU5UXCI7XG4gICAgLy8gVG9vIG1hbnkgYXJndW1lbnRzXG4gICAgLy8gICAtIGNvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyByZWNlaXZlZFxuICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuICAgIEVycm9yQ29kZVtcIlVORVhQRUNURURfQVJHVU1FTlRcIl0gPSBcIlVORVhQRUNURURfQVJHVU1FTlRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQmxvY2tjaGFpbiBFcnJvcnNcbiAgICAvLyBDYWxsIGV4Y2VwdGlvblxuICAgIC8vICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb25cbiAgICAvLyAgLSBhZGRyZXNzPzogdGhlIGNvbnRyYWN0IGFkZHJlc3NcbiAgICAvLyAgLSBhcmdzPzogVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cbiAgICAvLyAgLSBtZXRob2Q/OiBUaGUgU29saWRpdHkgbWV0aG9kIHNpZ25hdHVyZVxuICAgIC8vICAtIGVycm9yU2lnbmF0dXJlPzogVGhlIEVJUDg0OCBlcnJvciBzaWduYXR1cmVcbiAgICAvLyAgLSBlcnJvckFyZ3M/OiBUaGUgRUlQODQ4IGVycm9yIHBhcmFtZXRlcnNcbiAgICAvLyAgLSByZWFzb246IFRoZSByZWFzb24gKG9ubHkgZm9yIEVJUDg0OCBcIkVycm9yKHN0cmluZylcIilcbiAgICBFcnJvckNvZGVbXCJDQUxMX0VYQ0VQVElPTlwiXSA9IFwiQ0FMTF9FWENFUFRJT05cIjtcbiAgICAvLyBJbnN1ZmZpY2llbnQgZnVuZHMgKDwgdmFsdWUgKyBnYXNMaW1pdCAqIGdhc1ByaWNlKVxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIklOU1VGRklDSUVOVF9GVU5EU1wiXSA9IFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCI7XG4gICAgLy8gTm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiTk9OQ0VfRVhQSVJFRFwiXSA9IFwiTk9OQ0VfRVhQSVJFRFwiO1xuICAgIC8vIFRoZSByZXBsYWNlbWVudCBmZWUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpcyB0b28gbG93XG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIl0gPSBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCI7XG4gICAgLy8gVGhlIGdhcyBsaW1pdCBjb3VsZCBub3QgYmUgZXN0aW1hdGVkXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gcGFzc2VkIHRvIGVzdGltYXRlR2FzXG4gICAgRXJyb3JDb2RlW1wiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIl0gPSBcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCI7XG4gICAgLy8gVGhlIHRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZCBieSBvbmUgd2l0aCBhIGhpZ2hlciBnYXMgcHJpY2VcbiAgICAvLyAgIC0gcmVhc29uOiBcImNhbmNlbGxlZFwiLCBcInJlcGxhY2VkXCIgb3IgXCJyZXByaWNlZFwiXG4gICAgLy8gICAtIGNhbmNlbGxlZDogdHJ1ZSBpZiByZWFzb24gPT0gXCJjYW5jZWxsZWRcIiBvciByZWFzb24gPT0gXCJyZXBsYWNlZFwiKVxuICAgIC8vICAgLSBoYXNoOiBvcmlnaW5hbCB0cmFuc2FjdGlvbiBoYXNoXG4gICAgLy8gICAtIHJlcGxhY2VtZW50OiB0aGUgZnVsbCBUcmFuc2FjdGlvbnNSZXNwb25zZSBmb3IgdGhlIHJlcGxhY2VtZW50XG4gICAgLy8gICAtIHJlY2VpcHQ6IHRoZSByZWNlaXB0IG9mIHRoZSByZXBsYWNlbWVudFxuICAgIEVycm9yQ29kZVtcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCJdID0gXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBJbnRlcmFjdGlvbiBFcnJvcnNcbiAgICAvLyBUaGUgdXNlciByZWplY3RlZCB0aGUgYWN0aW9uLCBzdWNoIGFzIHNpZ25pbmcgYSBtZXNzYWdlIG9yIHNlbmRpbmdcbiAgICAvLyBhIHRyYW5zYWN0aW9uXG4gICAgRXJyb3JDb2RlW1wiQUNUSU9OX1JFSkVDVEVEXCJdID0gXCJBQ1RJT05fUkVKRUNURURcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbmNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuY2xhc3MgTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2ZXJzaW9uLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbG9nKGxvZ0xldmVsLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbG9nTGV2ZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKExvZ0xldmVsc1tsZXZlbF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxvZyBsZXZlbCBuYW1lXCIsIFwibG9nTGV2ZWxcIiwgbG9nTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbG9nTGV2ZWwgPiBMb2dMZXZlbHNbbGV2ZWxdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfVxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuREVCVUcsIGFyZ3MpO1xuICAgIH1cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuSU5GTywgYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5XQVJOSU5HLCBhcmdzKTtcbiAgICB9XG4gICAgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICAvLyBFcnJvcnMgYXJlIGJlaW5nIGNlbnNvcmVkXG4gICAgICAgIGlmIChfY2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJjZW5zb3JlZCBlcnJvclwiLCBjb2RlLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlRGV0YWlscyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gJiAweDBmXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVVpbnQ4QXJyYXkoMHhcIiArIGhleCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbXNba2V5XS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgdmVyc2lvbj0ke3RoaXMudmVyc2lvbn1gKTtcbiAgICAgICAgY29uc3QgcmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgbGV0IHVybCA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTlVNRVJJQ19GQVVMVDoge1xuICAgICAgICAgICAgICAgIHVybCA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdmVyZmxvd1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5kZXJmbG93XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaXZpc2lvbi1ieS16ZXJvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItXCIgKyBmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtcG93ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXdpZHRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItdW5zdXBwb3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLXVuYm91bmQtcmVzdWx0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5DQUxMX0VYQ0VQVElPTjpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLklOU1VGRklDSUVOVF9GVU5EUzpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk1JU1NJTkdfTkVXOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTk9OQ0VfRVhQSVJFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuVFJBTlNBQ1RJT05fUkVQTEFDRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVDpcbiAgICAgICAgICAgICAgICB1cmwgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgWyBTZWU6IGh0dHBzOi9cXC9saW5rcy5ldGhlcnMub3JnL3Y1LWVycm9ycy1cIiArIHVybCArIFwiIF1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZURldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIG1lc3NhZ2VEZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBBbnk/P1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgZXJyb3IucmVhc29uID0gcmVhc29uO1xuICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGVycm9yW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5tYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgdGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICBhcmd1bWVudDogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb25kaXRpb24sIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgY2hlY2tOb3JtYWxpemUobWVzc2FnZSkge1xuICAgICAgICBpZiAoX25vcm1hbGl6ZUVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGZvcm06IF9ub3JtYWxpemVFcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTYWZlVWludDUzKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcInZhbHVlIG5vdCBzYWZlXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAweDFmZmZmZmZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcbiAgICAgICAgICAgICAgICBmYXVsdDogXCJvdXQtb2Ytc2FmZS1yYW5nZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICUgMSkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwibm9uLWludGVnZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPCBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID4gZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tOZXcodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBYnN0cmFjdCh0YXJnZXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0ga2luZCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiY2Fubm90IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIFwiICsgSlNPTi5zdHJpbmdpZnkoa2luZC5uYW1lKSArIFwiIGRpcmVjdGx5OyB1c2UgYSBzdWItY2xhc3NcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgbmFtZTogdGFyZ2V0Lm5hbWUsIG9wZXJhdGlvbjogXCJuZXdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdsb2JhbExvZ2dlcigpIHtcbiAgICAgICAgaWYgKCFfZ2xvYmFsTG9nZ2VyKSB7XG4gICAgICAgICAgICBfZ2xvYmFsTG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uJDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZ2xvYmFsTG9nZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0Q2Vuc29yc2hpcChjZW5zb3JzaGlwLCBwZXJtYW5lbnQpIHtcbiAgICAgICAgaWYgKCFjZW5zb3JzaGlwICYmIHBlcm1hbmVudCkge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiY2Fubm90IHBlcm1hbmVudGx5IGRpc2FibGUgY2Vuc29yc2hpcFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfcGVybWFuZW50Q2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAoIWNlbnNvcnNoaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZ2dlcigpLnRocm93RXJyb3IoXCJlcnJvciBjZW5zb3JzaGlwIHBlcm1hbmVudFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9jZW5zb3JFcnJvcnMgPSAhIWNlbnNvcnNoaXA7XG4gICAgICAgIF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSAhIXBlcm1hbmVudDtcbiAgICB9XG4gICAgc3RhdGljIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gTG9nTGV2ZWxzW2xvZ0xldmVsLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgTG9nZ2VyLmdsb2JhbExvZ2dlcigpLndhcm4oXCJpbnZhbGlkIGxvZyBsZXZlbCAtIFwiICsgbG9nTGV2ZWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9sb2dMZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuICAgIH1cbn1cbkxvZ2dlci5lcnJvcnMgPSBFcnJvckNvZGU7XG5Mb2dnZXIubGV2ZWxzID0gTG9nTGV2ZWw7XG5cbmNvbnN0IHZlcnNpb24gPSBcInN0cmluZ3MvNS43LjBcIjtcblxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbnZhciBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm07XG4oZnVuY3Rpb24gKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSkge1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcImN1cnJlbnRcIl0gPSBcIlwiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GQ1wiXSA9IFwiTkZDXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZEXCJdID0gXCJORkRcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktDXCJdID0gXCJORktDXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZLRFwiXSA9IFwiTkZLRFwiO1xufSkoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtIHx8IChVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gPSB7fSkpO1xudmFyIFV0ZjhFcnJvclJlYXNvbjtcbihmdW5jdGlvbiAoVXRmOEVycm9yUmVhc29uKSB7XG4gICAgLy8gQSBjb250aW51YXRpb24gYnl0ZSB3YXMgcHJlc2VudCB3aGVyZSB0aGVyZSB3YXMgbm90aGluZyB0byBjb250aW51ZVxuICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cbiAgICBVdGY4RXJyb3JSZWFzb25bXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCJdID0gXCJ1bmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBieXRlXCI7XG4gICAgLy8gQW4gaW52YWxpZCAobm9uLWNvbnRpbnVhdGlvbikgYnl0ZSB0byBzdGFydCBhIFVURi04IGNvZGVwb2ludCB3YXMgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiQkFEX1BSRUZJWFwiXSA9IFwiYmFkIGNvZGVwb2ludCBwcmVmaXhcIjtcbiAgICAvLyBUaGUgc3RyaW5nIGlzIHRvbyBzaG9ydCB0byBwcm9jZXNzIHRoZSBleHBlY3RlZCBjb2RlcG9pbnRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1ZFUlJVTlwiXSA9IFwic3RyaW5nIG92ZXJydW5cIjtcbiAgICAvLyBBIG1pc3NpbmcgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGJ1dCBub3QgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGF0XG4gICAgVXRmOEVycm9yUmVhc29uW1wiTUlTU0lOR19DT05USU5VRVwiXSA9IFwibWlzc2luZyBjb250aW51YXRpb24gYnl0ZVwiO1xuICAgIC8vIFRoZSBjb21wdXRlZCBjb2RlIHBvaW50IGlzIG91dHNpZGUgdGhlIHJhbmdlIGZvciBVVEYtOFxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IG91dHNpZGUgdGhlIFVURi04IHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1VUX09GX1JBTkdFXCJdID0gXCJvdXQgb2YgVVRGLTggcmFuZ2VcIjtcbiAgICAvLyBVVEYtOCBzdHJpbmdzIG1heSBub3QgY29udGFpbiBVVEYtMTYgc3Vycm9nYXRlIHBhaXJzXG4gICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgaW5zaWRlIHRoZSBVVEYtMTYgc3Vycm9nYXRlIHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiVVRGMTZfU1VSUk9HQVRFXCJdID0gXCJVVEYtMTYgc3Vycm9nYXRlXCI7XG4gICAgLy8gVGhlIHN0cmluZyBpcyBhbiBvdmVybG9uZyByZXByZXNlbnRhdGlvblxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGFscmVhZHkgYm91bmRzIGNoZWNrZWRcbiAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSTE9OR1wiXSA9IFwib3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cIjtcbn0pKFV0ZjhFcnJvclJlYXNvbiB8fCAoVXRmOEVycm9yUmVhc29uID0ge30pKTtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYIHx8IHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLlVORVhQRUNURURfQ09OVElOVUUpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLk9WRVJSVU4pIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYmFkQ29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFB1dCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGludG8gdGhlIG91dHB1dFxuICAgIG91dHB1dC5wdXNoKDB4ZmZmZCk7XG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xuICAgIHJldHVybiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcyk7XG59XG4vLyBDb21tb24gZXJyb3IgaGFuZGluZyBzdHJhdGVnaWVzXG5jb25zdCBVdGY4RXJyb3JGdW5jcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGVycm9yOiBlcnJvckZ1bmMsXG4gICAgaWdub3JlOiBpZ25vcmVGdW5jLFxuICAgIHJlcGxhY2U6IHJlcGxhY2VGdW5jXG59KTtcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMzNTY0OTMvZGVjb2RlLXV0Zi04LXdpdGgtamF2YXNjcmlwdCMxMzY5MTQ5OVxuZnVuY3Rpb24gZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMkMSwgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBieXRlcyQxID0gYnl0ZXMuYXJyYXlpZnkoYnl0ZXMkMSk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzJDEubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlcyQxW2krK107XG4gICAgICAgIC8vIDB4eHggeHh4eFxuICAgICAgICBpZiAoYyA+PiA3ID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpYnl0ZTsgaG93IG1hbnkgYnl0ZXMgbGVmdCBmb3IgdGhpcyBjaGFyYWN0ZXI/XG4gICAgICAgIGxldCBleHRyYUxlbmd0aCA9IG51bGw7XG4gICAgICAgIGxldCBvdmVybG9uZ01hc2sgPSBudWxsO1xuICAgICAgICAvLyAxMTB4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIGlmICgoYyAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDE7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmO1xuICAgICAgICAgICAgLy8gMTExMCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDI7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmZjtcbiAgICAgICAgICAgIC8vIDExMTEgMHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMztcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4ZmZmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgoYyAmIDB4YzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFLCBpIC0gMSwgYnl0ZXMkMSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWCwgaSAtIDEsIGJ5dGVzJDEsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMkMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUlJVTiwgaSAtIDEsIGJ5dGVzJDEsIHJlc3VsdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgICBsZXQgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXMkMVtpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5NSVNTSU5HX0NPTlRJTlVFLCBpLCBieXRlcyQxLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSAocmVzIDw8IDYpIHwgKG5leHRDaGFyICYgMHgzZik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGFib3ZlIGxvb3AgZm9yIGludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF4aW11bSBjb2RlIHBvaW50XG4gICAgICAgIGlmIChyZXMgPiAweDEwZmZmZikge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVVRfT0ZfUkFOR0UsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzJDEsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLlVURjE2X1NVUlJPR0FURSwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMkMSwgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzJDEsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NzI5NDA1L2hvdy10by1jb252ZXJ0LXV0Zjgtc3RyaW5nLXRvLWJ5dGUtYXJyYXlcbmZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSA9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50KSB7XG4gICAgaWYgKGZvcm0gIT0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTm9ybWFsaXplKCk7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiA2KSB8IDB4YzApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PSAweGQ4MDApIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnN0IGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoaSA+PSBzdHIubGVuZ3RoIHx8IChjMiAmIDB4ZmMwMCkgIT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXRmLTggc3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLmFycmF5aWZ5KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpIHtcbiAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoKGNvZGVQb2ludCkgPT4ge1xuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCksICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSk7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzMihkYXRhKSB7XG4gICAgaWYgKChkYXRhLmxlbmd0aCAlIDQpICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBkYXRhXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KGRhdGEuc3Vic3RyaW5nKGksIGkgKyA0KSwgMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKGRhdGEsIGZ1bmMpIHtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gW3BhcnNlSW50KHZhbHVlLCAxNildOyB9O1xuICAgIH1cbiAgICBsZXQgbG8gPSAwO1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBkYXRhLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChwYWlyKSA9PiB7XG4gICAgICAgIGxldCBjb21wcyA9IHBhaXIuc3BsaXQoXCI6XCIpO1xuICAgICAgICBsbyArPSBwYXJzZUludChjb21wc1swXSwgMTYpO1xuICAgICAgICByZXN1bHRbbG9dID0gZnVuYyhjb21wc1sxXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlVGFibGUoZGF0YSkge1xuICAgIGxldCBoaSA9IDA7XG4gICAgcmV0dXJuIGRhdGEuc3BsaXQoXCIsXCIpLm1hcCgodikgPT4ge1xuICAgICAgICBsZXQgY29tcHMgPSB2LnNwbGl0KFwiLVwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29tcHNbMV0gPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wc1sxXSA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29tcHNbMV0gPSBcIjFcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbG8gPSBoaSArIHBhcnNlSW50KGNvbXBzWzBdLCAxNik7XG4gICAgICAgIGhpID0gcGFyc2VJbnQoY29tcHNbMV0sIDE2KTtcbiAgICAgICAgcmV0dXJuIHsgbDogbG8sIGg6IGhpIH07XG4gICAgfSk7XG59XG5jcmVhdGVSYW5nZVRhYmxlKFwiMjIxLDEzLTFiLDVmLSw0MC0xMCw1MS1mLDExLTMsMy0zLDItMiwyLTQsOCwyLDE1LDJkLDI4LTgsODgsNDgsMjctLDMtNSwxMS0yMCwyNy0sOCwyOCwzLTUsMTIsMTgsYi1hLDFjLTQsNi0xNiwyLWQsMi0yLDIsMWItNCwxNy05LDhmLSwxMCxmLDFmLTIsMWMtMzQsMzMtMTRlLDQsMzYtLDEzLSw2LTIsMWEtZiw0LDktLDMtLDE3LDgsMi0yLDUtLDIsOC0sMy0sNC04LDItMywzLDYtLDE2LTYsMi0sNy0zLDMtLDE3LDgsMywzLDMtLDIsNi0zLDMtLDQtYSw1LDItNiwxMC1iLDQsOCwyLDQsMTcsOCwzLDYtLGIsNCw0LSwyLWUsMi00LGItMTAsNCw5LSwzLSwxNyw4LDMtLDUtLDktMiwzLSw0LTcsMy0zLDMsNC0zLGMtMTAsMyw3LTIsNCw1LTIsMywyLDMtMiwzLTIsNC0yLDksNC0zLDYtMiw0LDUtOCwyLWUsZC1kLDQsOSw0LDE4LGIsNi0zLDgsNCw1LTYsMy04LDMtMyxiLTExLDMsOSw0LDE4LGIsNi0zLDgsNCw1LTYsMy02LDIsMy0zLGItMTEsMyw5LDQsMTgsMTEtMyw3LSw0LDUtOCwyLTcsMy0zLGItMTEsMywxMy0yLDE5LGEsMi0sOC0yLDItMyw3LDIsOS0xMSw0LWIsM2ItMywxZS0yNCwzLDItLDMsMi0sMi01LDUsOCw0LDIsMi0sMyxlLDQtLDYsMiw3LSxiLSwzLTIxLDQ5LDIzLTUsMWMtMyw5LDI1LDEwLSwyLTJmLDIzLDYsMyw4LTIsNS01LDFiLTQ1LDI3LTksMmEtLDItMyw1Yi00LDQ1LTQsNTMtNSw4LDQwLDIsNS0sOCwyLDUtLDI4LDIsNS0sMjAsMiw1LSw4LDIsNS0sOCw4LDE4LDIwLDIsNS0sOCwyOCwxNC01LDFkLTIyLDU2LWIsMjc3LTgsMWUtMiw1Mi1lLGUsOC1hLDE4LTgsMTUtYixlLDQsMy1iLDVlLTIsYi0xNSwxMCxiLTUsNTktNywyYi01NTUsOWQtMyw1Yi01LDE3LSw3LSwyNy0sNy0sOSwyLDIsMiwyMC0sMzYsMTAsZi0sNywxNC0sNCxhLDU0LTMsMi02LDYtNSw5LSwxYy0xMCwxMy0xZCwxYy0xNCwzYy0sMTAtNiwzMi1iLDI0MC0zMCwyOC0xOCxjLTE0LGEwLDExNS0sMyw2Ni0sYi03Niw1LDUtLDFkLDI0LDIsNS0yLDIsOC0sMzUtMiwxOSxmLTEwLDFkLTMsMzExLTM3ZiwxYiw1YS1iLGQ3LTE5LGQtMyw0MSw1Ny0sNjgtNCwyOS0zLDVmLDI5LTM3LDJlLTIsMjUtYywyYy0yLDRlLTMsMzAsNzgtMyw2NC0sMjAsMTliNy00OSw1MWE3LTU5LDQ4ZS0yLDM4LTczOCwyYmE1LTViLDIyMmYtLDNjLTk0LDgtYiw2LTQsMWIsNiwyLDMsMyw2ZC0yMCwxNmUtZiw0MS0sMzctNywyZS0yLDExLWYsNS1iLDE4LSxiLDE0LDUtMyw2LDg4LSwyLGJmLTIsNy0sNy0sNy0sNC0yLDgsOC05LDgtMmZmLDIwLDUtYiwxYy1iNCwyNy0sMjctY2JiMSxmNy05LDI4LTIsYjUtMjIxLDU2LDQ4LDMtLDItLDMtLDUsZCwyLDUsMyw0Miw1LSw5LDgsMWQsNSw2LDItMiw4LDE1My0zLDEyMy0zLDMzLTI3ZmQsYTZkYS01MTI4LDIxZi01ZGYsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLDItMWQsNjEtZmY3ZFwiKTtcbi8vIEBUT0RPOiBNYWtlIHRoaXMgcmVsYXRpdmUuLi5cblwiYWQsMzRmLDE4MDYsMTgwYiwxODBjLDE4MGQsMjAwYiwyMDBjLDIwMGQsMjA2MCxmZWZmXCIuc3BsaXQoXCIsXCIpLm1hcCgodikgPT4gcGFyc2VJbnQodiwgMTYpKTtcbmNyZWF0ZVRhYmxlKFwiYjU6M2JjLGMzOmZmLDc6NzMsMjoyNTMsNToyNTQsMzoyNTYsMToyNTcsNToyNTksMToyNWIsMzoyNjAsMToyNjMsMjoyNjksMToyNjgsNToyNmYsMToyNzIsMjoyNzUsNzoyODAsMzoyODMsNToyODgsMzoyOGEsMToyOGIsNToyOTIsM2Y6MTk1LDE6MWJmLDI5OjE5ZSwxMjU6M2I5LDhiOjNiMiwxOjNiOCwxOjNjNSwzOjNjNiwxOjNjMCwxYTozYmEsMTozYzEsMTozYzMsMjozYjgsMTozYjUsMWJjOTozYjksMWM6MWY3NiwxOjFmNzcsZjoxZjdhLDE6MWY3YixkOjFmNzgsMToxZjc5LDE6MWY3YywxOjFmN2QsMTA3OjYzLDU6MjViLDQ6NjgsMTo2OCwxOjY4LDM6NjksMTo2OSwxOjZjLDM6NmUsNDo3MCwxOjcxLDE6NzIsMTo3MiwxOjcyLDc6N2EsMjozYzksMjo3YSwyOjZiLDE6ZTUsMTo2MiwxOjYzLDM6NjUsMTo2NiwyOjZkLGI6M2IzLDE6M2MwLDY6NjQsMWI1NzQ6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzXCIpO1xuY3JlYXRlVGFibGUoXCIxNzk6MSwyOjEsMjoxLDU6MSwyOjEsYTo0ZixhOjEsODoxLDI6MSwyOjEsMzoxLDU6MSwzOjEsNDoxLDI6MSwzOjEsNDoxLDg6MiwxOjEsMjoyLDE6MSwyOjIsMjc6MiwxOTU6MjYsMjoyNSwxOjI1LDE6MjUsMjo0MCwyOjNmLDE6M2YsMzM6MSwxMTotNiwxOi05LDFhYzc6LTNhLDZkOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsYjotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCxjOi04LDI6LTgsMjotOCwyOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw0OTotOCwxOi04LDE6LTRhLDE6LTRhLGQ6LTU2LDE6LTU2LDE6LTU2LDE6LTU2LGQ6LTgsMTotOCxmOi04LDE6LTgsMzotN1wiKTtcbmNyZWF0ZVRhYmxlKFwiZGY6MDA3MzAwNzMsNTE6MDA2OTAzMDcsMTk6MDJCQzAwNkUsYTc6MDA2QTAzMEMsMThhOjAwMjAwM0I5LDE2OjAzQjkwMzA4MDMwMSwyMDowM0M1MDMwODAzMDEsMWQ3OjA1NjUwNTgyLDE5MGY6MDA2ODAzMzEsMTowMDc0MDMwOCwxOjAwNzcwMzBBLDE6MDA3OTAzMEEsMTowMDYxMDJCRSxiNjowM0M1MDMxMywyOjAzQzUwMzEzMDMwMCwyOjAzQzUwMzEzMDMwMSwyOjAzQzUwMzEzMDM0MiwyYToxRjAwMDNCOSwxOjFGMDEwM0I5LDE6MUYwMjAzQjksMToxRjAzMDNCOSwxOjFGMDQwM0I5LDE6MUYwNTAzQjksMToxRjA2MDNCOSwxOjFGMDcwM0I5LDE6MUYwMDAzQjksMToxRjAxMDNCOSwxOjFGMDIwM0I5LDE6MUYwMzAzQjksMToxRjA0MDNCOSwxOjFGMDUwM0I5LDE6MUYwNjAzQjksMToxRjA3MDNCOSwxOjFGMjAwM0I5LDE6MUYyMTAzQjksMToxRjIyMDNCOSwxOjFGMjMwM0I5LDE6MUYyNDAzQjksMToxRjI1MDNCOSwxOjFGMjYwM0I5LDE6MUYyNzAzQjksMToxRjIwMDNCOSwxOjFGMjEwM0I5LDE6MUYyMjAzQjksMToxRjIzMDNCOSwxOjFGMjQwM0I5LDE6MUYyNTAzQjksMToxRjI2MDNCOSwxOjFGMjcwM0I5LDE6MUY2MDAzQjksMToxRjYxMDNCOSwxOjFGNjIwM0I5LDE6MUY2MzAzQjksMToxRjY0MDNCOSwxOjFGNjUwM0I5LDE6MUY2NjAzQjksMToxRjY3MDNCOSwxOjFGNjAwM0I5LDE6MUY2MTAzQjksMToxRjYyMDNCOSwxOjFGNjMwM0I5LDE6MUY2NDAzQjksMToxRjY1MDNCOSwxOjFGNjYwM0I5LDE6MUY2NzAzQjksMzoxRjcwMDNCOSwxOjAzQjEwM0I5LDE6MDNBQzAzQjksMjowM0IxMDM0MiwxOjAzQjEwMzQyMDNCOSw1OjAzQjEwM0I5LDY6MUY3NDAzQjksMTowM0I3MDNCOSwxOjAzQUUwM0I5LDI6MDNCNzAzNDIsMTowM0I3MDM0MjAzQjksNTowM0I3MDNCOSw2OjAzQjkwMzA4MDMwMCwxOjAzQjkwMzA4MDMwMSwzOjAzQjkwMzQyLDE6MDNCOTAzMDgwMzQyLGI6MDNDNTAzMDgwMzAwLDE6MDNDNTAzMDgwMzAxLDE6MDNDMTAzMTMsMjowM0M1MDM0MiwxOjAzQzUwMzA4MDM0MixiOjFGN0MwM0I5LDE6MDNDOTAzQjksMTowM0NFMDNCOSwyOjAzQzkwMzQyLDE6MDNDOTAzNDIwM0I5LDU6MDNDOTAzQjksYWM6MDA3MjAwNzMsNWI6MDBCMDAwNjMsNjowMEIwMDA2NixkOjAwNkUwMDZGLGE6MDA3MzAwNkQsMTowMDc0MDA2NTAwNkMsMTowMDc0MDA2RCwxMjRmOjAwNjgwMDcwMDA2MSwyOjAwNjEwMDc1LDI6MDA2RjAwNzYsYjowMDcwMDA2MSwxOjAwNkUwMDYxLDE6MDNCQzAwNjEsMTowMDZEMDA2MSwxOjAwNkIwMDYxLDE6MDA2QjAwNjIsMTowMDZEMDA2MiwxOjAwNjcwMDYyLDM6MDA3MDAwNjYsMTowMDZFMDA2NiwxOjAzQkMwMDY2LDQ6MDA2ODAwN0EsMTowMDZCMDA2ODAwN0EsMTowMDZEMDA2ODAwN0EsMTowMDY3MDA2ODAwN0EsMTowMDc0MDA2ODAwN0EsMTU6MDA3MDAwNjEsMTowMDZCMDA3MDAwNjEsMTowMDZEMDA3MDAwNjEsMTowMDY3MDA3MDAwNjEsODowMDcwMDA3NiwxOjAwNkUwMDc2LDE6MDNCQzAwNzYsMTowMDZEMDA3NiwxOjAwNkIwMDc2LDE6MDA2RDAwNzYsMTowMDcwMDA3NywxOjAwNkUwMDc3LDE6MDNCQzAwNzcsMTowMDZEMDA3NywxOjAwNkIwMDc3LDE6MDA2RDAwNzcsMTowMDZCMDNDOSwxOjAwNkQwM0M5LDI6MDA2MjAwNzEsMzowMDYzMjIxNTAwNkIwMDY3LDE6MDA2MzAwNkYwMDJFLDE6MDA2NDAwNjIsMTowMDY3MDA3OSwyOjAwNjgwMDcwLDI6MDA2QjAwNkIsMTowMDZCMDA2RCw5OjAwNzAwMDY4LDI6MDA3MDAwNzAwMDZELDE6MDA3MDAwNzIsMjowMDczMDA3NiwxOjAwNzcwMDYyLGM3MjM6MDA2NjAwNjYsMTowMDY2MDA2OSwxOjAwNjYwMDZDLDE6MDA2NjAwNjYwMDY5LDE6MDA2NjAwNjYwMDZDLDE6MDA3MzAwNzQsMTowMDczMDA3NCxkOjA1NzQwNTc2LDE6MDU3NDA1NjUsMTowNTc0MDU2QiwxOjA1N0UwNTc2LDE6MDU3NDA1NkRcIiwgYnl0ZXMyKTtcbmNyZWF0ZVJhbmdlVGFibGUoXCI4MC0yMCwyYTAtLDM5YywzMixmNzEsMThlLDdmMi1mLDE5LTcsMzAtNCw3LTUsZjgxLWIsNSxhODAwLTIwZmYsNGQxLTFmLDExMCxmYS02LGQxNzQtNywyZTg0LSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSwyLDFmLTVmLGZmN2YtMjAwMDFcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZG5zRW5jb2RlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoLmRuc0VuY29kZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2hhc2hNZXNzYWdlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoLmhhc2hNZXNzYWdlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaWQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2guaWQ7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpc1ZhbGlkTmFtZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaC5pc1ZhbGlkTmFtZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ25hbWVoYXNoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoLm5hbWVoYXNoOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnYXJyYXlpZnknLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmFycmF5aWZ5OyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY29uY2F0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5jb25jYXQ7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdoZXhDb25jYXQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmhleENvbmNhdDsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2hleERhdGFMZW5ndGgnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmhleERhdGFMZW5ndGg7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdoZXhEYXRhU2xpY2UnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmhleERhdGFTbGljZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2hleFN0cmlwWmVyb3MnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmhleFN0cmlwWmVyb3M7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdoZXhWYWx1ZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuaGV4VmFsdWU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdoZXhaZXJvUGFkJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5oZXhaZXJvUGFkOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaGV4bGlmeScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuaGV4bGlmeTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2lzQnl0ZXMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmlzQnl0ZXM7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpc0J5dGVzTGlrZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuaXNCeXRlc0xpa2U7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpc0hleFN0cmluZycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuaXNIZXhTdHJpbmc7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdqb2luU2lnbmF0dXJlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5qb2luU2lnbmF0dXJlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc3BsaXRTaWduYXR1cmUnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLnNwbGl0U2lnbmF0dXJlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc3RyaXBaZXJvcycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuc3RyaXBaZXJvczsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3plcm9QYWQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLnplcm9QYWQ7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmb3JtYXRFdGhlcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHMuZm9ybWF0RXRoZXI7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmb3JtYXRVbml0cycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHMuZm9ybWF0VW5pdHM7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdwYXJzZUV0aGVyJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0cy5wYXJzZUV0aGVyOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncGFyc2VVbml0cycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHMucGFyc2VVbml0czsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ludGVyZmFjZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJpLkludGVyZmFjZTsgfVxufSk7XG5leHBvcnRzLnRvVXRmOEJ5dGVzID0gdG9VdGY4Qnl0ZXM7XG5leHBvcnRzLnRvVXRmOFN0cmluZyA9IHRvVXRmOFN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaGFzaCIsInJlcXVpcmUiLCJieXRlcyIsInVuaXRzIiwiYWJpIiwidmVyc2lvbiQxIiwiX3Blcm1hbmVudENlbnNvckVycm9ycyIsIl9jZW5zb3JFcnJvcnMiLCJMb2dMZXZlbHMiLCJkZWJ1ZyIsImluZm8iLCJ3YXJuaW5nIiwiZXJyb3IiLCJvZmYiLCJfbG9nTGV2ZWwiLCJfZ2xvYmFsTG9nZ2VyIiwiX2NoZWNrTm9ybWFsaXplIiwibWlzc2luZyIsImZvckVhY2giLCJmb3JtIiwibm9ybWFsaXplIiwiRXJyb3IiLCJwdXNoIiwibGVuZ3RoIiwiam9pbiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm1lc3NhZ2UiLCJfbm9ybWFsaXplRXJyb3IiLCJMb2dMZXZlbCIsIkVycm9yQ29kZSIsIkhFWCIsIkxvZ2dlciIsImNvbnN0cnVjdG9yIiwidmVyc2lvbiIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIl9sb2ciLCJsb2dMZXZlbCIsImFyZ3MiLCJsZXZlbCIsInRvTG93ZXJDYXNlIiwidGhyb3dBcmd1bWVudEVycm9yIiwiY29uc29sZSIsImxvZyIsImFwcGx5IiwibGV2ZWxzIiwiREVCVUciLCJJTkZPIiwid2FybiIsIldBUk5JTkciLCJtYWtlRXJyb3IiLCJjb2RlIiwicGFyYW1zIiwiZXJyb3JzIiwiVU5LTk9XTl9FUlJPUiIsIm1lc3NhZ2VEZXRhaWxzIiwia2V5cyIsImtleSIsIlVpbnQ4QXJyYXkiLCJoZXgiLCJpIiwiSlNPTiIsInN0cmluZ2lmeSIsInRvU3RyaW5nIiwicmVhc29uIiwidXJsIiwiTlVNRVJJQ19GQVVMVCIsImZhdWx0IiwiQ0FMTF9FWENFUFRJT04iLCJJTlNVRkZJQ0lFTlRfRlVORFMiLCJNSVNTSU5HX05FVyIsIk5PTkNFX0VYUElSRUQiLCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCIsIlRSQU5TQUNUSU9OX1JFUExBQ0VEIiwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVQiLCJ0aHJvd0Vycm9yIiwibmFtZSIsIklOVkFMSURfQVJHVU1FTlQiLCJhcmd1bWVudCIsImFzc2VydCIsImNvbmRpdGlvbiIsImFzc2VydEFyZ3VtZW50IiwiY2hlY2tOb3JtYWxpemUiLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJvcGVyYXRpb24iLCJjaGVja1NhZmVVaW50NTMiLCJjaGVja0FyZ3VtZW50Q291bnQiLCJjb3VudCIsImV4cGVjdGVkQ291bnQiLCJNSVNTSU5HX0FSR1VNRU5UIiwiVU5FWFBFQ1RFRF9BUkdVTUVOVCIsImNoZWNrTmV3IiwidGFyZ2V0Iiwia2luZCIsImNoZWNrQWJzdHJhY3QiLCJnbG9iYWxMb2dnZXIiLCJzZXRDZW5zb3JzaGlwIiwiY2Vuc29yc2hpcCIsInBlcm1hbmVudCIsInNldExvZ0xldmVsIiwiZnJvbSIsImxvZ2dlciIsIlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSIsIlV0ZjhFcnJvclJlYXNvbiIsImVycm9yRnVuYyIsIm9mZnNldCIsIm91dHB1dCIsImJhZENvZGVwb2ludCIsImlnbm9yZUZ1bmMiLCJCQURfUFJFRklYIiwiVU5FWFBFQ1RFRF9DT05USU5VRSIsIm8iLCJPVkVSUlVOIiwicmVwbGFjZUZ1bmMiLCJPVkVSTE9ORyIsIlV0ZjhFcnJvckZ1bmNzIiwiZnJlZXplIiwiaWdub3JlIiwicmVwbGFjZSIsImdldFV0ZjhDb2RlUG9pbnRzIiwiYnl0ZXMkMSIsIm9uRXJyb3IiLCJhcnJheWlmeSIsInJlc3VsdCIsImMiLCJleHRyYUxlbmd0aCIsIm92ZXJsb25nTWFzayIsInJlcyIsImoiLCJuZXh0Q2hhciIsIk1JU1NJTkdfQ09OVElOVUUiLCJPVVRfT0ZfUkFOR0UiLCJVVEYxNl9TVVJST0dBVEUiLCJ0b1V0ZjhCeXRlcyIsInN0ciIsImN1cnJlbnQiLCJjaGFyQ29kZUF0IiwiYzIiLCJwYWlyIiwiX3RvVXRmOFN0cmluZyIsImNvZGVQb2ludHMiLCJtYXAiLCJjb2RlUG9pbnQiLCJ0b1V0ZjhTdHJpbmciLCJieXRlczIiLCJkYXRhIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJjcmVhdGVUYWJsZSIsImZ1bmMiLCJsbyIsInNwbGl0IiwiY29tcHMiLCJjcmVhdGVSYW5nZVRhYmxlIiwiaGkiLCJ2IiwibCIsImgiLCJnZXQiLCJkbnNFbmNvZGUiLCJoYXNoTWVzc2FnZSIsImlkIiwiaXNWYWxpZE5hbWUiLCJuYW1laGFzaCIsImNvbmNhdCIsImhleENvbmNhdCIsImhleERhdGFMZW5ndGgiLCJoZXhEYXRhU2xpY2UiLCJoZXhTdHJpcFplcm9zIiwiaGV4VmFsdWUiLCJoZXhaZXJvUGFkIiwiaGV4bGlmeSIsImlzQnl0ZXMiLCJpc0J5dGVzTGlrZSIsImlzSGV4U3RyaW5nIiwiam9pblNpZ25hdHVyZSIsInNwbGl0U2lnbmF0dXJlIiwic3RyaXBaZXJvcyIsInplcm9QYWQiLCJmb3JtYXRFdGhlciIsImZvcm1hdFVuaXRzIiwicGFyc2VFdGhlciIsInBhcnNlVW5pdHMiLCJJbnRlcmZhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/alchemy-sdk/dist/cjs/index-3873e7b8.js":
/*!*************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/cjs/index-3873e7b8.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./api/utils */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\nvar bignumber = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\nvar bytes = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\nvar axios = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\");\nvar abstractProvider = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\nvar wallet = __webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/./node_modules/@ethersproject/wallet/lib.esm/index.js\");\nvar contracts = __webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/./node_modules/@ethersproject/contracts/lib.esm/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar axios__default = /*#__PURE__*/ _interopDefaultLegacy(axios);\n/**\r\n * The supported networks by Alchemy. Note that some functions are not available\r\n * on all networks. Please refer to the Alchemy documentation for which APIs are\r\n * available on which networks\r\n * {@link https://docs.alchemy.com/alchemy/apis/feature-support-by-chain}\r\n *\r\n * @public\r\n */ exports.Network = void 0;\n(function(Network) {\n    Network[\"ETH_MAINNET\"] = \"eth-mainnet\";\n    /** @deprecated */ Network[\"ETH_GOERLI\"] = \"eth-goerli\";\n    Network[\"ETH_SEPOLIA\"] = \"eth-sepolia\";\n    Network[\"ETH_HOLESKY\"] = \"eth-holesky\";\n    Network[\"ETH_HOODI\"] = \"eth-hoodi\";\n    Network[\"OPT_MAINNET\"] = \"opt-mainnet\";\n    /** @deprecated */ Network[\"OPT_GOERLI\"] = \"opt-goerli\";\n    Network[\"OPT_SEPOLIA\"] = \"opt-sepolia\";\n    Network[\"ARB_MAINNET\"] = \"arb-mainnet\";\n    /** @deprecated */ Network[\"ARB_GOERLI\"] = \"arb-goerli\";\n    Network[\"ARB_SEPOLIA\"] = \"arb-sepolia\";\n    Network[\"MATIC_MAINNET\"] = \"polygon-mainnet\";\n    /** @deprecated */ Network[\"MATIC_MUMBAI\"] = \"polygon-mumbai\";\n    Network[\"MATIC_AMOY\"] = \"polygon-amoy\";\n    Network[\"ASTAR_MAINNET\"] = \"astar-mainnet\";\n    Network[\"POLYGONZKEVM_MAINNET\"] = \"polygonzkevm-mainnet\";\n    /** @deprecated */ Network[\"POLYGONZKEVM_TESTNET\"] = \"polygonzkevm-testnet\";\n    Network[\"POLYGONZKEVM_CARDONA\"] = \"polygonzkevm-cardona\";\n    Network[\"BASE_MAINNET\"] = \"base-mainnet\";\n    /** @deprecated */ Network[\"BASE_GOERLI\"] = \"base-goerli\";\n    Network[\"BASE_SEPOLIA\"] = \"base-sepolia\";\n    Network[\"ZKSYNC_MAINNET\"] = \"zksync-mainnet\";\n    Network[\"ZKSYNC_SEPOLIA\"] = \"zksync-sepolia\";\n    Network[\"SHAPE_MAINNET\"] = \"shape-mainnet\";\n    Network[\"SHAPE_SEPOLIA\"] = \"shape-sepolia\";\n    Network[\"LINEA_MAINNET\"] = \"linea-mainnet\";\n    Network[\"LINEA_SEPOLIA\"] = \"linea-sepolia\";\n    Network[\"FANTOM_MAINNET\"] = \"fantom-mainnet\";\n    /** @deprecated */ Network[\"FANTOM_TESTNET\"] = \"fantom-testnet\";\n    Network[\"ZETACHAIN_MAINNET\"] = \"zetachain-mainnet\";\n    Network[\"ZETACHAIN_TESTNET\"] = \"zetachain-testnet\";\n    Network[\"ARBNOVA_MAINNET\"] = \"arbnova-mainnet\";\n    Network[\"BLAST_MAINNET\"] = \"blast-mainnet\";\n    Network[\"BLAST_SEPOLIA\"] = \"blast-sepolia\";\n    Network[\"MANTLE_MAINNET\"] = \"mantle-mainnet\";\n    Network[\"MANTLE_SEPOLIA\"] = \"mantle-sepolia\";\n    Network[\"SCROLL_MAINNET\"] = \"scroll-mainnet\";\n    Network[\"SCROLL_SEPOLIA\"] = \"scroll-sepolia\";\n    Network[\"GNOSIS_MAINNET\"] = \"gnosis-mainnet\";\n    Network[\"GNOSIS_CHIADO\"] = \"gnosis-chiado\";\n    Network[\"BNB_MAINNET\"] = \"bnb-mainnet\";\n    Network[\"BNB_TESTNET\"] = \"bnb-testnet\";\n    Network[\"AVAX_MAINNET\"] = \"avax-mainnet\";\n    Network[\"AVAX_FUJI\"] = \"avax-fuji\";\n    Network[\"CELO_MAINNET\"] = \"celo-mainnet\";\n    Network[\"CELO_ALFAJORES\"] = \"celo-alfajores\";\n    /** @deprecated */ Network[\"CELO_BAKLAVA\"] = \"celo-baklava\";\n    Network[\"METIS_MAINNET\"] = \"metis-mainnet\";\n    Network[\"OPBNB_MAINNET\"] = \"opbnb-mainnet\";\n    Network[\"OPBNB_TESTNET\"] = \"opbnb-testnet\";\n    /** @deprecated */ Network[\"BERACHAIN_BARTIO\"] = \"berachain-bartio\";\n    Network[\"BERACHAIN_MAINNET\"] = \"berachain-mainnet\";\n    Network[\"BERACHAIN_BEPOLIA\"] = \"berachain-bepolia\";\n    Network[\"SONEIUM_MAINNET\"] = \"soneium-mainnet\";\n    Network[\"SONEIUM_MINATO\"] = \"soneium-minato\";\n    Network[\"WORLDCHAIN_MAINNET\"] = \"worldchain-mainnet\";\n    Network[\"WORLDCHAIN_SEPOLIA\"] = \"worldchain-sepolia\";\n    Network[\"ROOTSTOCK_MAINNET\"] = \"rootstock-mainnet\";\n    Network[\"ROOTSTOCK_TESTNET\"] = \"rootstock-testnet\";\n    Network[\"FLOW_MAINNET\"] = \"flow-mainnet\";\n    Network[\"FLOW_TESTNET\"] = \"flow-testnet\";\n    Network[\"ZORA_MAINNET\"] = \"zora-mainnet\";\n    Network[\"ZORA_SEPOLIA\"] = \"zora-sepolia\";\n    Network[\"FRAX_MAINNET\"] = \"frax-mainnet\";\n    Network[\"FRAX_SEPOLIA\"] = \"frax-sepolia\";\n    Network[\"POLYNOMIAL_MAINNET\"] = \"polynomial-mainnet\";\n    Network[\"POLYNOMIAL_SEPOLIA\"] = \"polynomial-sepolia\";\n    Network[\"CROSSFI_MAINNET\"] = \"crossfi-mainnet\";\n    Network[\"CROSSFI_TESTNET\"] = \"crossfi-testnet\";\n    Network[\"APECHAIN_MAINNET\"] = \"apechain-mainnet\";\n    Network[\"APECHAIN_CURTIS\"] = \"apechain-curtis\";\n    Network[\"LENS_MAINNET\"] = \"lens-mainnet\";\n    Network[\"LENS_SEPOLIA\"] = \"lens-sepolia\";\n    /** @deprecated */ Network[\"GEIST_MAINNET\"] = \"geist-mainnet\";\n    /** @deprecated */ Network[\"GEIST_POLTER\"] = \"geist-polter\";\n    Network[\"LUMIA_PRISM\"] = \"lumia-prism\";\n    Network[\"LUMIA_TESTNET\"] = \"lumia-testnet\";\n    Network[\"UNICHAIN_MAINNET\"] = \"unichain-mainnet\";\n    Network[\"UNICHAIN_SEPOLIA\"] = \"unichain-sepolia\";\n    Network[\"SONIC_MAINNET\"] = \"sonic-mainnet\";\n    Network[\"SONIC_BLAZE\"] = \"sonic-blaze\";\n    Network[\"XMTP_TESTNET\"] = \"xmtp-testnet\";\n    Network[\"ABSTRACT_MAINNET\"] = \"abstract-mainnet\";\n    Network[\"ABSTRACT_TESTNET\"] = \"abstract-testnet\";\n    Network[\"DEGEN_MAINNET\"] = \"degen-mainnet\";\n    Network[\"INK_MAINNET\"] = \"ink-mainnet\";\n    Network[\"INK_SEPOLIA\"] = \"ink-sepolia\";\n    Network[\"SEI_MAINNET\"] = \"sei-mainnet\";\n    Network[\"SEI_TESTNET\"] = \"sei-testnet\";\n    Network[\"RONIN_MAINNET\"] = \"ronin-mainnet\";\n    Network[\"RONIN_SAIGON\"] = \"ronin-saigon\";\n    Network[\"MONAD_TESTNET\"] = \"monad-testnet\";\n    Network[\"SETTLUS_SEPTESTNET\"] = \"settlus-septestnet\";\n    Network[\"SETTLUS_MAINNET\"] = \"settlus-mainnet\";\n    Network[\"SOLANA_MAINNET\"] = \"solana-mainnet\";\n    Network[\"SOLANA_DEVNET\"] = \"solana-devnet\";\n    Network[\"GENSYN_TESTNET\"] = \"gensyn-testnet\";\n    Network[\"SUPERSEED_MAINNET\"] = \"superseed-mainnet\";\n    Network[\"SUPERSEED_SEPOLIA\"] = \"superseed-sepolia\";\n    Network[\"TEA_SEPOLIA\"] = \"tea-sepolia\";\n    Network[\"ANIME_MAINNET\"] = \"anime-mainnet\";\n    Network[\"ANIME_SEPOLIA\"] = \"anime-sepolia\";\n    Network[\"STORY_MAINNET\"] = \"story-mainnet\";\n    Network[\"STORY_AENEID\"] = \"story-aeneid\";\n    Network[\"MEGAETH_TESTNET\"] = \"megaeth-testnet\";\n    Network[\"BOTANIX_MAINNET\"] = \"botanix-mainnet\";\n    Network[\"BOTANIX_TESTNET\"] = \"botanix-testnet\";\n    Network[\"HUMANITY_MAINNET\"] = \"humanity-mainnet\";\n    Network[\"RISE_TESTNET\"] = \"rise-testnet\";\n})(exports.Network || (exports.Network = {}));\n/** Token Types for the `getTokenBalances()` endpoint. */ exports.TokenBalanceType = void 0;\n(function(TokenBalanceType) {\n    /**\r\n     * Option to fetch the top 100 tokens by 24-hour volume. This option is only\r\n     * available on Mainnet in Ethereum, Polygon, and Arbitrum.\r\n     */ TokenBalanceType[\"DEFAULT_TOKENS\"] = \"DEFAULT_TOKENS\";\n    /**\r\n     * Option to fetch the set of ERC-20 tokens that the address as ever held. his\r\n     * list is produced by an address's historical transfer activity and includes\r\n     * all tokens that the address has ever received.\r\n     */ TokenBalanceType[\"ERC20\"] = \"erc20\";\n})(exports.TokenBalanceType || (exports.TokenBalanceType = {}));\n/**\r\n * Categories of transfers to use with the {@link AssetTransfersParams} request\r\n * object when using {@link CoreNamespace.getAssetTransfers}.\r\n *\r\n * @public\r\n */ exports.AssetTransfersCategory = void 0;\n(function(AssetTransfersCategory) {\n    /**\r\n     * Top level ETH transactions that occur where the `fromAddress` is an\r\n     * external user-created address. External addresses have private keys and are\r\n     * accessed by users.\r\n     */ AssetTransfersCategory[\"EXTERNAL\"] = \"external\";\n    /**\r\n     * Top level ETH transactions that occur where the `fromAddress` is an\r\n     * internal, smart contract address. For example, a smart contract calling\r\n     * another smart contract or sending\r\n     */ AssetTransfersCategory[\"INTERNAL\"] = \"internal\";\n    /** ERC20 transfers. */ AssetTransfersCategory[\"ERC20\"] = \"erc20\";\n    /** ERC721 transfers. */ AssetTransfersCategory[\"ERC721\"] = \"erc721\";\n    /** ERC1155 transfers. */ AssetTransfersCategory[\"ERC1155\"] = \"erc1155\";\n    /** Special contracts that don't follow ERC 721/1155, (ex: CryptoKitties). */ AssetTransfersCategory[\"SPECIALNFT\"] = \"specialnft\";\n})(exports.AssetTransfersCategory || (exports.AssetTransfersCategory = {}));\n/**\r\n * The type of transfer for the request. Note that using `TO` will also include\r\n * NFTs that were minted by the owner.\r\n */ exports.GetTransfersForOwnerTransferType = void 0;\n(function(GetTransfersForOwnerTransferType) {\n    GetTransfersForOwnerTransferType[\"TO\"] = \"TO\";\n    GetTransfersForOwnerTransferType[\"FROM\"] = \"FROM\";\n})(exports.GetTransfersForOwnerTransferType || (exports.GetTransfersForOwnerTransferType = {}));\n/**\r\n * Enum for representing the supported sorting orders of the API.\r\n *\r\n * @public\r\n */ exports.SortingOrder = void 0;\n(function(SortingOrder) {\n    SortingOrder[\"ASCENDING\"] = \"asc\";\n    SortingOrder[\"DESCENDING\"] = \"desc\";\n})(exports.SortingOrder || (exports.SortingOrder = {}));\n/** An OpenSea collection's approval status. */ exports.OpenSeaSafelistRequestStatus = void 0;\n(function(OpenSeaSafelistRequestStatus) {\n    /** Verified collection. */ OpenSeaSafelistRequestStatus[\"VERIFIED\"] = \"verified\";\n    /** Collections that are approved on open sea and can be found in search results. */ OpenSeaSafelistRequestStatus[\"APPROVED\"] = \"approved\";\n    /** Collections that requested safelisting on OpenSea. */ OpenSeaSafelistRequestStatus[\"REQUESTED\"] = \"requested\";\n    /** Brand new collections. */ OpenSeaSafelistRequestStatus[\"NOT_REQUESTED\"] = \"not_requested\";\n})(exports.OpenSeaSafelistRequestStatus || (exports.OpenSeaSafelistRequestStatus = {}));\n/**\r\n * Method names for Alchemy's custom Subscription API endpoints.\r\n *\r\n * This value is provided in the `method` field when creating an event filter on\r\n * the Websocket Namespace.\r\n */ exports.AlchemySubscription = void 0;\n(function(AlchemySubscription) {\n    AlchemySubscription[\"PENDING_TRANSACTIONS\"] = \"alchemy_pendingTransactions\";\n    AlchemySubscription[\"MINED_TRANSACTIONS\"] = \"alchemy_minedTransactions\";\n})(exports.AlchemySubscription || (exports.AlchemySubscription = {}));\n/**\r\n * Asset type returned when calling {@link TransactNamespace.simulateAssetChanges}.\r\n * Allows you to determine if the assets approved or / and transferred are\r\n * native, tokens or NFTs.\r\n */ exports.SimulateAssetType = void 0;\n(function(SimulateAssetType) {\n    /**\r\n     * Native transfers that involve the currency of the chain the simulation is\r\n     * run on (ex: ETH for Ethereum, MATIC for Polygon, ETH for Arbitrum).\r\n     */ SimulateAssetType[\"NATIVE\"] = \"NATIVE\";\n    /** ERC20 approval or transfers. */ SimulateAssetType[\"ERC20\"] = \"ERC20\";\n    /** ERC721 approval or transfers. */ SimulateAssetType[\"ERC721\"] = \"ERC721\";\n    /** ERC1155 approval or transfers. */ SimulateAssetType[\"ERC1155\"] = \"ERC1155\";\n    /**\r\n     * Special contracts that don't follow ERC 721/1155.Currently limited to\r\n     * CryptoKitties and CryptoPunks.\r\n     */ SimulateAssetType[\"SPECIAL_NFT\"] = \"SPECIAL_NFT\";\n})(exports.SimulateAssetType || (exports.SimulateAssetType = {}));\n/**\r\n * Change type returned when calling {@link TransactNamespace.simulateAssetChanges}.\r\n */ exports.SimulateChangeType = void 0;\n(function(SimulateChangeType) {\n    /**\r\n     * Represents a transaction that approved or disapproved permissions for a\r\n     * contract.\r\n     *\r\n     * APPROVE without token ID  approve all tokens\r\n     * APPROVE without amount  approve all amount\r\n     * APPROVE with zero amount  approval being cleared\r\n     */ SimulateChangeType[\"APPROVE\"] = \"APPROVE\";\n    /**\r\n     * Represents a transaction that transferred tokens from one address to another.\r\n     */ SimulateChangeType[\"TRANSFER\"] = \"TRANSFER\";\n})(exports.SimulateChangeType || (exports.SimulateChangeType = {}));\n/**\r\n * Authority used to decode calls and logs when using the\r\n * {@link TransactNamespace.simulateExecution} method.\r\n */ exports.DecodingAuthority = void 0;\n(function(DecodingAuthority) {\n    DecodingAuthority[\"ETHERSCAN\"] = \"ETHERSCAN\";\n})(exports.DecodingAuthority || (exports.DecodingAuthority = {}));\n/** The type of call in a debug call trace. */ exports.DebugCallType = void 0;\n(function(DebugCallType) {\n    DebugCallType[\"CREATE\"] = \"CREATE\";\n    DebugCallType[\"CALL\"] = \"CALL\";\n    DebugCallType[\"STATICCALL\"] = \"STATICCALL\";\n    DebugCallType[\"DELEGATECALL\"] = \"DELEGATECALL\";\n})(exports.DebugCallType || (exports.DebugCallType = {}));\n/**\r\n * Potential transaction job statuses for a {@link GasOptimizedTransactionResponse}\r\n *\r\n * @internal\r\n */ // TODO(txjob): Remove internal tag once this feature is released.\nexports.GasOptimizedTransactionStatus = void 0;\n(function(GasOptimizedTransactionStatus) {\n    GasOptimizedTransactionStatus[\"UNSPECIFIED\"] = \"TRANSACTION_JOB_STATUS_UNSPECIFIED\";\n    GasOptimizedTransactionStatus[\"IN_PROGRESS\"] = \"IN_PROGRESS\";\n    GasOptimizedTransactionStatus[\"COMPLETE\"] = \"COMPLETE\";\n    GasOptimizedTransactionStatus[\"ABANDONED\"] = \"ABANDONED\";\n})(exports.GasOptimizedTransactionStatus || (exports.GasOptimizedTransactionStatus = {}));\n/** The version of the webhook. All newly created webhooks default to V2. */ exports.WebhookVersion = void 0;\n(function(WebhookVersion) {\n    WebhookVersion[\"V1\"] = \"V1\";\n    WebhookVersion[\"V2\"] = \"V2\";\n})(exports.WebhookVersion || (exports.WebhookVersion = {}));\n/** The type of {@link Webhook}. */ exports.WebhookType = void 0;\n(function(WebhookType) {\n    WebhookType[\"MINED_TRANSACTION\"] = \"MINED_TRANSACTION\";\n    WebhookType[\"DROPPED_TRANSACTION\"] = \"DROPPED_TRANSACTION\";\n    WebhookType[\"ADDRESS_ACTIVITY\"] = \"ADDRESS_ACTIVITY\";\n    WebhookType[\"NFT_ACTIVITY\"] = \"NFT_ACTIVITY\";\n    WebhookType[\"NFT_METADATA_UPDATE\"] = \"NFT_METADATA_UPDATE\";\n    WebhookType[\"GRAPHQL\"] = \"GRAPHQL\";\n})(exports.WebhookType || (exports.WebhookType = {}));\n/**\r\n * Commitment level of the target block with using methods in the\r\n * {@link DebugNamespace}\r\n */ exports.CommitmentLevel = void 0;\n(function(CommitmentLevel) {\n    /**\r\n     * Sample next block inferred by Alchemy built on top of the latest block.\r\n     * This contains the set of transactions taken from the local mempool and\r\n     * is a proxy for blocks that have not been mined yet.\r\n     */ CommitmentLevel[\"PENDING\"] = \"pending\";\n    /**\r\n     * The most recent block in the canonical chain observed by Alchemy. Note that\r\n     * this block may be re-orged out of the canonical chain.\r\n     */ CommitmentLevel[\"LATEST\"] = \"latest\";\n    /**\r\n     * The most recent crypto-economically secure block that cannot be re-orged\r\n     * outside of manual intervention driven by community coordination. This is\r\n     * only available on {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.\r\n     */ CommitmentLevel[\"SAFE\"] = \"safe\";\n    /**\r\n     * The most recent secure block that has been accepted by >2/3 of validators.\r\n     * This block is very unlikely to be re-orged. This is only available on\r\n     * {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.\r\n     */ CommitmentLevel[\"FINALIZED\"] = \"finalized\";\n    /**\r\n     * The lowest numbered block available that is usually the first block created.\r\n     */ CommitmentLevel[\"EARLIEST\"] = \"earliest\";\n})(exports.CommitmentLevel || (exports.CommitmentLevel = {}));\n/**\r\n * The type of tracer to use when running debug methods in the\r\n * {@link DebugNamespace}.\r\n */ exports.DebugTracerType = void 0;\n(function(DebugTracerType) {\n    DebugTracerType[\"CALL_TRACER\"] = \"callTracer\";\n    DebugTracerType[\"PRESTATE_TRACER\"] = \"prestateTracer\";\n})(exports.DebugTracerType || (exports.DebugTracerType = {}));\n/**\r\n * An enum for specifying the token type on NFTs.\r\n *\r\n * @public\r\n */ exports.NftTokenType = void 0;\n(function(NftTokenType) {\n    NftTokenType[\"ERC721\"] = \"ERC721\";\n    NftTokenType[\"ERC1155\"] = \"ERC1155\";\n    NftTokenType[\"NO_SUPPORTED_NFT_STANDARD\"] = \"NO_SUPPORTED_NFT_STANDARD\";\n    NftTokenType[\"NOT_A_CONTRACT\"] = \"NOT_A_CONTRACT\";\n    NftTokenType[\"UNKNOWN\"] = \"UNKNOWN\";\n})(exports.NftTokenType || (exports.NftTokenType = {}));\n/** Potential reasons why an NFT contract was classified as spam. */ exports.NftSpamClassification = void 0;\n(function(NftSpamClassification) {\n    NftSpamClassification[\"Erc721TooManyOwners\"] = \"Erc721TooManyOwners\";\n    NftSpamClassification[\"Erc721TooManyTokens\"] = \"Erc721TooManyTokens\";\n    NftSpamClassification[\"Erc721DishonestTotalSupply\"] = \"Erc721DishonestTotalSupply\";\n    NftSpamClassification[\"MostlyHoneyPotOwners\"] = \"MostlyHoneyPotOwners\";\n    NftSpamClassification[\"OwnedByMostHoneyPots\"] = \"OwnedByMostHoneyPots\";\n    NftSpamClassification[\"LowDistinctOwnersPercent\"] = \"LowDistinctOwnersPercent\";\n    NftSpamClassification[\"HighHoneyPotOwnerPercent\"] = \"HighHoneyPotOwnerPercent\";\n    NftSpamClassification[\"HighHoneyPotPercent\"] = \"HighHoneyPotPercent\";\n    NftSpamClassification[\"HoneyPotsOwnMultipleTokens\"] = \"HoneyPotsOwnMultipleTokens\";\n    NftSpamClassification[\"NoSalesActivity\"] = \"NoSalesActivity\";\n    NftSpamClassification[\"HighAirdropPercent\"] = \"HighAirdropPercent\";\n    NftSpamClassification[\"Unknown\"] = \"Unknown\";\n})(exports.NftSpamClassification || (exports.NftSpamClassification = {}));\n/**\r\n * Enum of NFT filters that can be applied to a {@link getNftsForOwner} or a\r\n * {@link getContractsForOwner} request.\r\n *\r\n * @beta\r\n */ exports.NftFilters = void 0;\n(function(NftFilters) {\n    /** NFTs that have been classified as spam. */ NftFilters[\"SPAM\"] = \"SPAM\";\n    /** NFTs that have been airdropped to a user. */ NftFilters[\"AIRDROPS\"] = \"AIRDROPS\";\n})(exports.NftFilters || (exports.NftFilters = {}));\n/**\r\n * Enum of ordering that can be applied to a {@link getNftsForOwner} or a\r\n * {@link getContractsForOwner} response.\r\n *\r\n * @beta\r\n */ exports.NftOrdering = void 0;\n(function(NftOrdering) {\n    NftOrdering[\"TRANSFERTIME\"] = \"TRANSFERTIME\";\n})(exports.NftOrdering || (exports.NftOrdering = {}));\n/**\r\n * Enum representing the supported NFT marketplaces by the\r\n * {@link NftNamespace.getNftSales} method.\r\n *\r\n * @public\r\n */ exports.NftSaleMarketplace = void 0;\n(function(NftSaleMarketplace) {\n    NftSaleMarketplace[\"SEAPORT\"] = \"seaport\";\n    NftSaleMarketplace[\"LOOKSRARE\"] = \"looksrare\";\n    NftSaleMarketplace[\"X2Y2\"] = \"x2y2\";\n    NftSaleMarketplace[\"WYVERN\"] = \"wyvern\";\n    NftSaleMarketplace[\"CRYPTOPUNKS\"] = \"cryptopunks\";\n    NftSaleMarketplace[\"BLUR\"] = \"blur\";\n    NftSaleMarketplace[\"UNKNOWN\"] = \"unknown\";\n})(exports.NftSaleMarketplace || (exports.NftSaleMarketplace = {}));\n/**\r\n * Enum for specifying the taker type for the {@link NftNamespace.getNftSales}\r\n * method.\r\n *\r\n * @public\r\n */ exports.NftSaleTakerType = void 0;\n(function(NftSaleTakerType) {\n    NftSaleTakerType[\"BUYER\"] = \"buyer\";\n    NftSaleTakerType[\"SELLER\"] = \"seller\";\n})(exports.NftSaleTakerType || (exports.NftSaleTakerType = {}));\n/** The current state of the NFT contract refresh process. */ exports.NftRefreshState = void 0;\n(function(NftRefreshState) {\n    /** The provided contract is not an NFT or does not contain metadata. */ NftRefreshState[\"DOES_NOT_EXIST\"] = \"does_not_exist\";\n    /** The contract has already been queued for refresh. */ NftRefreshState[\"ALREADY_QUEUED\"] = \"already_queued\";\n    /** The contract is currently being refreshed. */ NftRefreshState[\"IN_PROGRESS\"] = \"in_progress\";\n    /** The contract refresh is complete. */ NftRefreshState[\"FINISHED\"] = \"finished\";\n    /** The contract refresh has been queued and await execution. */ NftRefreshState[\"QUEUED\"] = \"queued\";\n    /** The contract was unable to be queued due to an internal error. */ NftRefreshState[\"QUEUE_FAILED\"] = \"queue_failed\";\n})(exports.NftRefreshState || (exports.NftRefreshState = {}));\n/**\r\n * Enum representing the supported NFT marketplaces on a\r\n * {@link NftCollectionFloorPrice} object.\r\n */ exports.NftCollectionMarketplace = void 0;\n(function(NftCollectionMarketplace) {\n    NftCollectionMarketplace[\"OPENSEA\"] = \"OpenSea\";\n})(exports.NftCollectionMarketplace || (exports.NftCollectionMarketplace = {}));\n/**\r\n * Valid time intervals for historical price data.\r\n *\r\n * @public\r\n */ exports.HistoricalPriceInterval = void 0;\n(function(HistoricalPriceInterval) {\n    /** 5-minute intervals */ HistoricalPriceInterval[\"FIVE_MINUTE\"] = \"5m\";\n    /** 1-hour intervals */ HistoricalPriceInterval[\"ONE_HOUR\"] = \"1h\";\n    /** 1-day intervals */ HistoricalPriceInterval[\"ONE_DAY\"] = \"1d\";\n})(exports.HistoricalPriceInterval || (exports.HistoricalPriceInterval = {}));\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter$1(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nconst DEFAULT_ALCHEMY_API_KEY = \"demo\";\nconst DEFAULT_NETWORK = exports.Network.ETH_MAINNET;\nconst DEFAULT_MAX_RETRIES = 5;\nconst DEFAULT_REQUEST_TIMEOUT = 0; // 0 = no timeout\n/**\r\n * Returns the base URL for making Alchemy API requests. The `alchemy.com`\r\n * endpoints only work with non eth json-rpc requests.\r\n *\r\n * @internal\r\n */ function getAlchemyHttpUrl(network, apiKey) {\n    return `https://${network}.g.alchemy.com/v2/${apiKey}`;\n}\nfunction getAlchemyNftHttpUrl(network, apiKey) {\n    return `https://${network}.g.alchemy.com/nft/v3/${apiKey}`;\n}\nfunction getAlchemyWsUrl(network, apiKey) {\n    return `wss://${network}.g.alchemy.com/v2/${apiKey}`;\n}\nfunction getAlchemyWebhookHttpUrl() {\n    return \"https://dashboard.alchemy.com/api\";\n}\nfunction getPricesBaseUrl(apiKey) {\n    return `https://api.g.alchemy.com/prices/v1/${apiKey}`;\n}\nfunction getDataBaseUrl(apiKey) {\n    return `https://api.g.alchemy.com/data/v1/${apiKey}`;\n}\nvar AlchemyApiType;\n(function(AlchemyApiType) {\n    AlchemyApiType[AlchemyApiType[\"BASE\"] = 0] = \"BASE\";\n    AlchemyApiType[AlchemyApiType[\"NFT\"] = 1] = \"NFT\";\n    AlchemyApiType[AlchemyApiType[\"WEBHOOK\"] = 2] = \"WEBHOOK\";\n    AlchemyApiType[AlchemyApiType[\"PRICES\"] = 3] = \"PRICES\";\n    AlchemyApiType[AlchemyApiType[\"PORTFOLIO\"] = 4] = \"PORTFOLIO\";\n})(AlchemyApiType || (AlchemyApiType = {}));\n/**\r\n * Mapping of network names to their corresponding Network strings used to\r\n * create an Ethers.js Provider instance.\r\n */ const EthersNetwork = {\n    [exports.Network.ETH_MAINNET]: \"mainnet\",\n    [exports.Network.ETH_GOERLI]: \"goerli\",\n    [exports.Network.ETH_SEPOLIA]: \"sepolia\",\n    [exports.Network.ETH_HOLESKY]: \"holesky\",\n    [exports.Network.ETH_HOODI]: \"hoodi\",\n    [exports.Network.OPT_MAINNET]: \"opt-mainnet\",\n    [exports.Network.OPT_GOERLI]: \"optimism-goerli\",\n    [exports.Network.OPT_SEPOLIA]: \"optimism-sepolia\",\n    [exports.Network.ARB_MAINNET]: \"arbitrum\",\n    [exports.Network.ARB_GOERLI]: \"arbitrum-goerli\",\n    [exports.Network.ARB_SEPOLIA]: \"arbitrum-sepolia\",\n    [exports.Network.MATIC_MAINNET]: \"matic\",\n    [exports.Network.MATIC_MUMBAI]: \"maticmum\",\n    [exports.Network.MATIC_AMOY]: \"maticamoy\",\n    [exports.Network.SOLANA_MAINNET]: null,\n    [exports.Network.SOLANA_DEVNET]: null,\n    [exports.Network.ASTAR_MAINNET]: \"astar-mainnet\",\n    [exports.Network.POLYGONZKEVM_MAINNET]: \"polygonzkevm-mainnet\",\n    [exports.Network.POLYGONZKEVM_TESTNET]: \"polygonzkevm-testnet\",\n    [exports.Network.POLYGONZKEVM_CARDONA]: \"polygonzkevm-cardona\",\n    [exports.Network.BASE_MAINNET]: \"base-mainnet\",\n    [exports.Network.BASE_GOERLI]: \"base-goerli\",\n    [exports.Network.BASE_SEPOLIA]: \"base-sepolia\",\n    [exports.Network.ZKSYNC_MAINNET]: \"zksync-mainnet\",\n    [exports.Network.ZKSYNC_SEPOLIA]: \"zksync-sepolia\",\n    [exports.Network.SHAPE_MAINNET]: \"shape-mainnet\",\n    [exports.Network.SHAPE_SEPOLIA]: \"shape-sepolia\",\n    [exports.Network.LINEA_MAINNET]: \"linea-mainnet\",\n    [exports.Network.LINEA_SEPOLIA]: \"linea-sepolia\",\n    [exports.Network.FANTOM_MAINNET]: \"fantom-mainnet\",\n    [exports.Network.FANTOM_TESTNET]: \"fantom-testnet\",\n    [exports.Network.ZETACHAIN_MAINNET]: \"zetachain-mainnet\",\n    [exports.Network.ZETACHAIN_TESTNET]: \"zetachain-testnet\",\n    [exports.Network.ARBNOVA_MAINNET]: \"arbnova-mainnet\",\n    [exports.Network.BLAST_MAINNET]: \"blast-mainnet\",\n    [exports.Network.BLAST_SEPOLIA]: \"blast-sepolia\",\n    [exports.Network.MANTLE_MAINNET]: \"mantle-mainnet\",\n    [exports.Network.MANTLE_SEPOLIA]: \"mantle-sepolia\",\n    [exports.Network.SCROLL_MAINNET]: \"scroll-mainnet\",\n    [exports.Network.SCROLL_SEPOLIA]: \"scroll-sepolia\",\n    [exports.Network.GNOSIS_MAINNET]: \"gnosis-mainnet\",\n    [exports.Network.GNOSIS_CHIADO]: \"gnosis-chiado\",\n    [exports.Network.BNB_MAINNET]: \"bnb-mainnet\",\n    [exports.Network.BNB_TESTNET]: \"bnb-testnet\",\n    [exports.Network.AVAX_MAINNET]: \"avax-mainnet\",\n    [exports.Network.AVAX_FUJI]: \"avax-fuji\",\n    [exports.Network.CELO_MAINNET]: \"celo-mainnet\",\n    [exports.Network.CELO_ALFAJORES]: \"celo-alfajores\",\n    [exports.Network.CELO_BAKLAVA]: \"celo-baklava\",\n    [exports.Network.METIS_MAINNET]: \"metis-mainnet\",\n    [exports.Network.OPBNB_MAINNET]: \"opbnb-mainnet\",\n    [exports.Network.OPBNB_TESTNET]: \"opbnb-testnet\",\n    [exports.Network.BERACHAIN_BARTIO]: \"berachain-bartio\",\n    [exports.Network.BERACHAIN_MAINNET]: \"berachain-mainnet\",\n    [exports.Network.BERACHAIN_BEPOLIA]: \"berachain-bepolia\",\n    [exports.Network.SONEIUM_MAINNET]: \"soneium-mainnet\",\n    [exports.Network.SONEIUM_MINATO]: \"soneium-minato\",\n    [exports.Network.WORLDCHAIN_MAINNET]: \"worldchain-mainnet\",\n    [exports.Network.WORLDCHAIN_SEPOLIA]: \"worldchain-sepolia\",\n    [exports.Network.ROOTSTOCK_MAINNET]: \"rootstock-mainnet\",\n    [exports.Network.ROOTSTOCK_TESTNET]: \"rootstock-testnet\",\n    [exports.Network.FLOW_MAINNET]: \"flow-mainnet\",\n    [exports.Network.FLOW_TESTNET]: \"flow-testnet\",\n    [exports.Network.ZORA_MAINNET]: \"zora-mainnet\",\n    [exports.Network.ZORA_SEPOLIA]: \"zora-sepolia\",\n    [exports.Network.FRAX_MAINNET]: \"frax-mainnet\",\n    [exports.Network.FRAX_SEPOLIA]: \"frax-sepolia\",\n    [exports.Network.POLYNOMIAL_MAINNET]: \"polynomial-mainnet\",\n    [exports.Network.POLYNOMIAL_SEPOLIA]: \"polynomial-sepolia\",\n    [exports.Network.CROSSFI_MAINNET]: \"crossfi-mainnet\",\n    [exports.Network.CROSSFI_TESTNET]: \"crossfi-testnet\",\n    [exports.Network.APECHAIN_MAINNET]: \"apechain-mainnet\",\n    [exports.Network.APECHAIN_CURTIS]: \"apechain-curtis\",\n    [exports.Network.LENS_MAINNET]: \"lens-mainnet\",\n    [exports.Network.LENS_SEPOLIA]: \"lens-sepolia\",\n    [exports.Network.GEIST_MAINNET]: \"geist-mainnet\",\n    [exports.Network.GEIST_POLTER]: \"geist-polter\",\n    [exports.Network.LUMIA_PRISM]: \"lumia-prism\",\n    [exports.Network.LUMIA_TESTNET]: \"lumia-testnet\",\n    [exports.Network.UNICHAIN_MAINNET]: \"unichain-mainnet\",\n    [exports.Network.UNICHAIN_SEPOLIA]: \"unichain-sepolia\",\n    [exports.Network.SONIC_MAINNET]: \"sonic-mainnet\",\n    [exports.Network.SONIC_BLAZE]: \"sonic-blaze\",\n    [exports.Network.XMTP_TESTNET]: \"xmtp-testnet\",\n    [exports.Network.ABSTRACT_MAINNET]: \"abstract-mainnet\",\n    [exports.Network.ABSTRACT_TESTNET]: \"abstract-testnet\",\n    [exports.Network.DEGEN_MAINNET]: \"degen-mainnet\",\n    [exports.Network.INK_MAINNET]: \"ink-mainnet\",\n    [exports.Network.INK_SEPOLIA]: \"ink-sepolia\",\n    [exports.Network.SEI_MAINNET]: \"sei-mainnet\",\n    [exports.Network.SEI_TESTNET]: \"sei-testnet\",\n    [exports.Network.RONIN_MAINNET]: \"ronin-mainnet\",\n    [exports.Network.RONIN_SAIGON]: \"ronin-saigon\",\n    [exports.Network.MONAD_TESTNET]: \"monad-testnet\",\n    [exports.Network.SETTLUS_MAINNET]: \"settlus-mainnet\",\n    [exports.Network.SETTLUS_SEPTESTNET]: \"settlus-septestnet\",\n    [exports.Network.GENSYN_TESTNET]: \"gensyn-testnet\",\n    [exports.Network.SUPERSEED_MAINNET]: \"superseed-mainnet\",\n    [exports.Network.SUPERSEED_SEPOLIA]: \"superseed-sepolia\",\n    [exports.Network.TEA_SEPOLIA]: \"tea-sepolia\",\n    [exports.Network.ANIME_MAINNET]: \"anime-mainnet\",\n    [exports.Network.ANIME_SEPOLIA]: \"anime-sepolia\",\n    [exports.Network.STORY_MAINNET]: \"story-mainnet\",\n    [exports.Network.STORY_AENEID]: \"story-aeneid\",\n    [exports.Network.MEGAETH_TESTNET]: \"megaeth-testnet\",\n    [exports.Network.BOTANIX_MAINNET]: \"botanix-mainnet\",\n    [exports.Network.BOTANIX_TESTNET]: \"botanix-testnet\",\n    [exports.Network.HUMANITY_MAINNET]: \"humanity-mainnet\",\n    [exports.Network.RISE_TESTNET]: \"rise-testnet\"\n};\n/**\r\n * Mapping of network names to their corresponding Ethers Network objects. These\r\n * networks are not yet supported by Ethers and are listed here to be overriden\r\n * in the provider.\r\n */ const CustomNetworks = {\n    \"arbitrum-goerli\": {\n        chainId: 421613,\n        name: \"arbitrum-goerli\"\n    },\n    \"arbitrum-sepolia\": {\n        chainId: 421614,\n        name: \"arbitrum-sepolia\"\n    },\n    \"astar-mainnet\": {\n        chainId: 592,\n        name: \"astar-mainnet\"\n    },\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\"\n    },\n    holesky: {\n        chainId: 17000,\n        name: \"holesky\"\n    },\n    hoodi: {\n        chainId: 560048,\n        name: \"hoodi\"\n    },\n    \"opt-mainnet\": {\n        chainId: 10,\n        name: \"opt-mainnet\"\n    },\n    \"optimism-sepolia\": {\n        chainId: 11155420,\n        name: \"optimism-sepolia\"\n    },\n    \"polygonzkevm-mainnet\": {\n        chainId: 1101,\n        name: \"polygonzkevm-mainnet\"\n    },\n    \"polygonzkevm-testnet\": {\n        chainId: 1442,\n        name: \"polygonzkevm-testnet\"\n    },\n    \"polygonzkevm-cardona\": {\n        chainId: 2442,\n        name: \"polygonzkevm-cardona\"\n    },\n    \"base-mainnet\": {\n        chainId: 8453,\n        name: \"base-mainnet\"\n    },\n    \"base-goerli\": {\n        chainId: 84531,\n        name: \"base-goerli\"\n    },\n    \"base-sepolia\": {\n        chainId: 84532,\n        name: \"base-sepolia\"\n    },\n    maticamoy: {\n        chainId: 80002,\n        name: \"maticamoy\"\n    },\n    \"zksync-mainnet\": {\n        chainId: 324,\n        name: \"zksync-mainnet\"\n    },\n    \"zksync-sepolia\": {\n        chainId: 300,\n        name: \"zksync-sepolia\"\n    },\n    \"shape-mainnet\": {\n        chainId: 360,\n        name: \"shape-mainnet\"\n    },\n    \"shape-sepolia\": {\n        chainId: 11011,\n        name: \"shape-sepolia\"\n    },\n    \"linea-mainnet\": {\n        chainId: 59144,\n        name: \"linea-mainnet\"\n    },\n    \"linea-sepolia\": {\n        chainId: 59141,\n        name: \"linea-sepolia\"\n    },\n    \"fantom-mainnet\": {\n        chainId: 250,\n        name: \"fantom-mainnet\"\n    },\n    \"fantom-testnet\": {\n        chainId: 4002,\n        name: \"fantom-testnet\"\n    },\n    \"zetachain-mainnet\": {\n        chainId: 7000,\n        name: \"zetachain-mainnet\"\n    },\n    \"zetachain-testnet\": {\n        chainId: 7001,\n        name: \"zetachain-testnet\"\n    },\n    \"arbnova-mainnet\": {\n        chainId: 42170,\n        name: \"arbnova-mainnet\"\n    },\n    \"blast-mainnet\": {\n        chainId: 81457,\n        name: \"blast-mainnet\"\n    },\n    \"blast-sepolia\": {\n        chainId: 168587773,\n        name: \"blast-sepolia\"\n    },\n    \"mantle-mainnet\": {\n        chainId: 5000,\n        name: \"mantle-mainnet\"\n    },\n    \"mantle-sepolia\": {\n        chainId: 5003,\n        name: \"mantle-sepolia\"\n    },\n    \"scroll-mainnet\": {\n        chainId: 534352,\n        name: \"scroll-mainnet\"\n    },\n    \"scroll-sepolia\": {\n        chainId: 534351,\n        name: \"scroll-sepolia\"\n    },\n    \"gnosis-mainnet\": {\n        chainId: 100,\n        name: \"gnosis-mainnet\"\n    },\n    \"gnosis-chiado\": {\n        chainId: 10200,\n        name: \"gnosis-chiado\"\n    },\n    \"bnb-mainnet\": {\n        chainId: 56,\n        name: \"bnb-mainnet\"\n    },\n    \"bnb-testnet\": {\n        chainId: 97,\n        name: \"bnb-testnet\"\n    },\n    \"avax-mainnet\": {\n        chainId: 43114,\n        name: \"avax-mainnet\"\n    },\n    \"avax-fuji\": {\n        chainId: 43113,\n        name: \"avax-fuji\"\n    },\n    \"celo-mainnet\": {\n        chainId: 42220,\n        name: \"celo-mainnet\"\n    },\n    \"celo-alfajores\": {\n        chainId: 44787,\n        name: \"celo-alfajores\"\n    },\n    \"celo-baklava\": {\n        chainId: 62320,\n        name: \"celo-baklava\"\n    },\n    \"metis-mainnet\": {\n        chainId: 1088,\n        name: \"metis-mainnet\"\n    },\n    \"opbnb-mainnet\": {\n        chainId: 204,\n        name: \"opbnb-mainnet\"\n    },\n    \"opbnb-testnet\": {\n        chainId: 5611,\n        name: \"opbnb-testnet\"\n    },\n    \"berachain-bartio\": {\n        chainId: 80084,\n        name: \"berachain-bartio\"\n    },\n    \"berachain-mainnet\": {\n        chainId: 80094,\n        name: \"berachain-mainnet\"\n    },\n    \"berachain-bepolia\": {\n        chainId: 80069,\n        name: \"berachain-bepolia\"\n    },\n    \"soneium-mainnet\": {\n        chainId: 1868,\n        name: \"soneium-mainnet\"\n    },\n    \"soneium-minato\": {\n        chainId: 0x79a,\n        name: \"soneium-minato\"\n    },\n    \"worldchain-mainnet\": {\n        chainId: 0x1e0,\n        name: \"worldchain-mainnet\"\n    },\n    \"worldchain-sepolia\": {\n        chainId: 0x12c1,\n        name: \"worldchain-sepolia\"\n    },\n    \"rootstock-mainnet\": {\n        chainId: 0x1e,\n        name: \"rootstock-mainnet\"\n    },\n    \"rootstock-testnet\": {\n        chainId: 0x1f,\n        name: \"rootstock-testnet\"\n    },\n    \"flow-mainnet\": {\n        chainId: 747,\n        name: \"flow-mainnet\"\n    },\n    \"flow-testnet\": {\n        chainId: 545,\n        name: \"flow-testnet\"\n    },\n    \"zora-mainnet\": {\n        chainId: 7777777,\n        name: \"zora-mainnet\"\n    },\n    \"zora-sepolia\": {\n        chainId: 999999999,\n        name: \"zora-sepolia\"\n    },\n    \"frax-mainnet\": {\n        chainId: 252,\n        name: \"frax-mainnet\"\n    },\n    \"frax-sepolia\": {\n        chainId: 2522,\n        name: \"frax-sepolia\"\n    },\n    \"polynomial-mainnet\": {\n        chainId: 8008,\n        name: \"polynomial-mainnet\"\n    },\n    \"polynomial-sepolia\": {\n        chainId: 8009,\n        name: \"polynomial-sepolia\"\n    },\n    \"crossfi-mainnet\": {\n        chainId: 4158,\n        name: \"crossfi-mainnet\"\n    },\n    \"crossfi-testnet\": {\n        chainId: 4157,\n        name: \"crossfi-testnet\"\n    },\n    \"apechain-mainnet\": {\n        chainId: 33139,\n        name: \"apechain-mainnet\"\n    },\n    \"apechain-curtis\": {\n        chainId: 33111,\n        name: \"apechain-curtis\"\n    },\n    \"lens-mainnet\": {\n        chainId: 232,\n        name: \"lens-mainnet\"\n    },\n    \"lens-sepolia\": {\n        chainId: 0x90f7,\n        name: \"lens-sepolia\"\n    },\n    \"geist-mainnet\": {\n        chainId: 63157,\n        name: \"geist-mainnet\"\n    },\n    \"geist-polter\": {\n        chainId: 631571,\n        name: \"geist-polter\"\n    },\n    \"lumia-prism\": {\n        chainId: 0x3b4c8eb9,\n        name: \"lumia-prism\"\n    },\n    \"lumia-testnet\": {\n        chainId: 0x7467cbf8,\n        name: \"lumia-testnet\"\n    },\n    \"unichain-mainnet\": {\n        chainId: 130,\n        name: \"unichain-mainnet\"\n    },\n    \"unichain-sepolia\": {\n        chainId: 0x515,\n        name: \"unichain-sepolia\"\n    },\n    \"sonic-mainnet\": {\n        chainId: 0x92,\n        name: \"sonic-mainnet\"\n    },\n    \"sonic-blaze\": {\n        chainId: 0xdede,\n        name: \"sonic-blaze\"\n    },\n    \"xmtp-testnet\": {\n        chainId: 241320161,\n        name: \"xmtp-testnet\"\n    },\n    \"abstract-mainnet\": {\n        chainId: 2741,\n        name: \"abstract-mainnet\"\n    },\n    \"abstract-testnet\": {\n        chainId: 11124,\n        name: \"abstract-testnet\"\n    },\n    \"degen-mainnet\": {\n        chainId: 0x27bc86aa,\n        name: \"degen-mainnet\"\n    },\n    \"ink-mainnet\": {\n        chainId: 0xdef1,\n        name: \"ink-mainnet\"\n    },\n    \"ink-sepolia\": {\n        chainId: 0xba5ed,\n        name: \"ink-sepolia\"\n    },\n    \"sei-mainnet\": {\n        chainId: 1329,\n        name: \"sei-mainnet\"\n    },\n    \"sei-testnet\": {\n        chainId: 1328,\n        name: \"sei-testnet\"\n    },\n    \"ronin-mainnet\": {\n        chainId: 2020,\n        name: \"ronin-mainnet\"\n    },\n    \"ronin-saigon\": {\n        chainId: 2021,\n        name: \"ronin-saigon\"\n    },\n    \"monad-testnet\": {\n        chainId: 0x279f,\n        name: \"monad-testnet\"\n    },\n    \"settlus-mainnet\": {\n        chainId: 5371,\n        name: \"settlus-mainnet\"\n    },\n    \"settlus-septestnet\": {\n        chainId: 0x14fd,\n        name: \"settlus-septestnet\"\n    },\n    \"gensyn-testnet\": {\n        chainId: 685685,\n        name: \"gensyn-testnet\"\n    },\n    \"superseed-mainnet\": {\n        chainId: 5330,\n        name: \"superseed-mainnet\"\n    },\n    \"superseed-sepolia\": {\n        chainId: 53302,\n        name: \"superseed-sepolia\"\n    },\n    \"tea-sepolia\": {\n        chainId: 10218,\n        name: \"tea-sepolia\"\n    },\n    \"anime-mainnet\": {\n        chainId: 69000,\n        name: \"anime-mainnet\"\n    },\n    \"anime-sepolia\": {\n        chainId: 0x1af4,\n        name: \"anime-sepolia\"\n    },\n    \"story-mainnet\": {\n        chainId: 0x5ea,\n        name: \"story-mainnet\"\n    },\n    \"story-aeneid\": {\n        chainId: 0x523,\n        name: \"story-aeneid\"\n    },\n    \"megaeth-testnet\": {\n        chainId: 0x18c6,\n        name: \"megaeth-testnet\"\n    },\n    \"botanix-mainnet\": {\n        chainId: 0xe34,\n        name: \"botanix-mainnet\"\n    },\n    \"botanix-testnet\": {\n        chainId: 0xe35,\n        name: \"botanix-testnet\"\n    },\n    \"humanity-mainnet\": {\n        chainId: 0x6a96a9,\n        name: \"humanity-mainnet\"\n    },\n    \"rise-testnet\": {\n        chainId: 0xaa39db,\n        name: \"rise-testnet\"\n    }\n};\nfunction noop() {\n// It's a no-op\n}\nconst ETH_NULL_VALUE = \"0x\";\nconst ETH_NULL_ADDRESS = \"0x0000000000000000000000000000000000000000\";\n/**\r\n * This class holds the config information for the SDK client instance and\r\n * exposes the underlying providers for more advanced use cases.\r\n *\r\n * @public\r\n */ class AlchemyConfig {\n    constructor(config){\n        this.apiKey = (config === null || config === void 0 ? void 0 : config.apiKey) || DEFAULT_ALCHEMY_API_KEY;\n        this.network = (config === null || config === void 0 ? void 0 : config.network) || DEFAULT_NETWORK;\n        this.maxRetries = (config === null || config === void 0 ? void 0 : config.maxRetries) || DEFAULT_MAX_RETRIES;\n        this.url = config === null || config === void 0 ? void 0 : config.url;\n        this.authToken = config === null || config === void 0 ? void 0 : config.authToken;\n        this.batchRequests = (config === null || config === void 0 ? void 0 : config.batchRequests) || false;\n        this.requestTimeout = (config === null || config === void 0 ? void 0 : config.requestTimeout) || DEFAULT_REQUEST_TIMEOUT;\n        this.connectionInfoOverrides = config === null || config === void 0 ? void 0 : config.connectionInfoOverrides;\n    }\n    /**\r\n     * Returns the URL endpoint to send the HTTP request to. If a custom URL was\r\n     * provided in the config, that URL is returned. Otherwise, the default URL is\r\n     * from the network and API key.\r\n     *\r\n     * @param apiType - The type of API to get the URL for.\r\n     * @internal\r\n     */ _getRequestUrl(apiType) {\n        if (this.url !== undefined) {\n            return this.url;\n        } else if (apiType === AlchemyApiType.NFT) {\n            return getAlchemyNftHttpUrl(this.network, this.apiKey);\n        } else if (apiType === AlchemyApiType.WEBHOOK) {\n            return getAlchemyWebhookHttpUrl();\n        } else if (apiType === AlchemyApiType.PRICES) {\n            return getPricesBaseUrl(this.apiKey);\n        } else if (apiType === AlchemyApiType.PORTFOLIO) {\n            return getDataBaseUrl(this.apiKey);\n        } else {\n            return getAlchemyHttpUrl(this.network, this.apiKey);\n        }\n    }\n    /**\r\n     * Returns an AlchemyProvider instance. Only one provider is created per\r\n     * Alchemy instance.\r\n     *\r\n     * The AlchemyProvider is a wrapper around ether's `AlchemyProvider` class and\r\n     * has been expanded to support Alchemy's Enhanced APIs.\r\n     *\r\n     * Most common methods on the provider are available as top-level methods on\r\n     * the {@link Alchemy} instance, but the provider is exposed here to access\r\n     * other less-common methods.\r\n     *\r\n     * @public\r\n     */ getProvider() {\n        if (!this._baseAlchemyProvider) {\n            this._baseAlchemyProvider = (()=>__awaiter$1(this, void 0, void 0, function*() {\n                    const { AlchemyProvider } = yield Promise.resolve().then(function() {\n                        return __webpack_require__(/*! ./alchemy-provider-b006a4bc.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-provider-b006a4bc.js\");\n                    });\n                    return new AlchemyProvider(this);\n                }))();\n        }\n        return this._baseAlchemyProvider;\n    }\n    /**\r\n     * Returns an AlchemyWebsocketProvider instance. Only one provider is created\r\n     * per Alchemy instance.\r\n     *\r\n     * The AlchemyWebSocketProvider is a wrapper around ether's\r\n     * `AlchemyWebSocketProvider` class and has been expanded to support Alchemy's\r\n     * Subscription APIs, automatic backfilling, and other performance improvements.\r\n     *\r\n     * Most common methods on the provider are available as top-level methods on\r\n     * the {@link Alchemy} instance, but the provider is exposed here to access\r\n     * other less-common methods.\r\n     */ getWebSocketProvider() {\n        if (!this._baseAlchemyWssProvider) {\n            this._baseAlchemyWssProvider = (()=>__awaiter$1(this, void 0, void 0, function*() {\n                    const { AlchemyWebSocketProvider } = yield Promise.resolve().then(function() {\n                        return __webpack_require__(/*! ./alchemy-websocket-provider-2dafa9e4.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-2dafa9e4.js\");\n                    });\n                    return new AlchemyWebSocketProvider(this);\n                }))();\n        }\n        return this._baseAlchemyWssProvider;\n    }\n}\nconst version$1 = \"logger/5.7.0\";\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = {\n    debug: 1,\n    \"default\": 2,\n    info: 2,\n    warning: 3,\n    error: 4,\n    off: 5\n};\nlet _logLevel = LogLevels[\"default\"];\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\n            \"NFD\",\n            \"NFC\",\n            \"NFKD\",\n            \"NFKC\"\n        ].forEach((form)=>{\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            } catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    } catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel$1;\n(function(LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel$1 || (LogLevel$1 = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\nconst HEX = \"0123456789abcdef\";\nclass Logger$1 {\n    constructor(version){\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger$1.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger$1.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger$1.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger$1.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key)=>{\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for(let i = 0; i < value.length; i++){\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch(code){\n            case ErrorCode.NUMERIC_FAULT:\n                {\n                    url = \"NUMERIC_FAULT\";\n                    const fault = message;\n                    switch(fault){\n                        case \"overflow\":\n                        case \"underflow\":\n                        case \"division-by-zero\":\n                            url += \"-\" + fault;\n                            break;\n                        case \"negative-power\":\n                        case \"negative-width\":\n                            url += \"-unsupported\";\n                            break;\n                        case \"unbound-bitwise-result\":\n                            url += \"-unbound-result\";\n                            break;\n                    }\n                    break;\n                }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https://links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger$1.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\",\n                form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof value !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger$1.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger$1.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger$1.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger$1.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger$1.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                name: target.name,\n                operation: \"new\"\n            });\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger$1.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger$1(version$1);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger$1.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger$1(version);\n    }\n}\nLogger$1.errors = ErrorCode;\nLogger$1.levels = LogLevel$1;\nconst version = \"properties/5.7.0\";\nvar __awaiter =  false || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst logger = new Logger$1(version);\nfunction defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false\n    });\n}\nfunction resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const promises = Object.keys(object).map((key)=>{\n            const value = object[key];\n            return Promise.resolve(value).then((v)=>({\n                    key: key,\n                    value: v\n                }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result)=>{\n            accum[result.key] = result.value;\n            return accum;\n        }, {});\n    });\n}\nconst opaque = {\n    bigint: true,\n    boolean: true,\n    \"function\": true,\n    number: true,\n    string: true\n};\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof object]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof object === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for(let i = 0; i < keys.length; i++){\n            let value = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item)=>deepCopy(item)));\n    }\n    if (typeof object === \"object\") {\n        const result = {};\n        for(const key in object){\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\nfunction deepCopy(object) {\n    return _deepCopy(object);\n}\n/**\r\n * Converts a hex string to a decimal number.\r\n *\r\n * @param hexString - The hex string to convert.\r\n * @public\r\n */ function fromHex(hexString) {\n    return bignumber.BigNumber.from(hexString).toNumber();\n}\n/**\r\n * Converts a number to a hex string.\r\n *\r\n * @param num - The number to convert to hex.\r\n * @public\r\n */ function toHex(num) {\n    return bytes.hexValue(num);\n}\n/**\r\n * Checks if a value is a hex string.\r\n *\r\n * @param possibleHexString - The value to check.\r\n * @public\r\n */ function isHex(possibleHexString) {\n    return /^0x[0-9a-fA-F]+$/.test(possibleHexString);\n}\nfunction formatBlock(block) {\n    if (typeof block === \"string\") {\n        return block;\n    } else if (Number.isInteger(block)) {\n        return toHex(block);\n    }\n    return block.toString();\n}\nfunction stringToEnum(x, enumb) {\n    return Object.values(enumb).includes(x) ? x : null;\n}\nfunction getNftContractForNftFromRaw(rawNftContract) {\n    return nullsToUndefined(Object.assign(Object.assign({}, getNftContractFromRaw(rawNftContract)), {\n        spamClassifications: rawNftContract.spamClassifications.map(parseNftSpamClassification)\n    }));\n}\nfunction getNftContractsForOwnerFromRaw(rawNftContract) {\n    return nullsToUndefined(Object.assign(Object.assign({}, getNftContractFromRaw(rawNftContract)), {\n        displayNft: rawNftContract.displayNft,\n        image: rawNftContract.image,\n        totalBalance: rawNftContract.totalBalance,\n        numDistinctTokensOwned: rawNftContract.numDistinctTokensOwned,\n        isSpam: rawNftContract.isSpam\n    }));\n}\nfunction getNftContractFromRaw(rawNftContract) {\n    var _a;\n    return nullsToUndefined(Object.assign(Object.assign({}, rawNftContract), {\n        tokenType: parseNftTokenType(rawNftContract.tokenType),\n        openSeaMetadata: Object.assign(Object.assign({}, rawNftContract.openSeaMetadata), {\n            safelistRequestStatus: ((_a = rawNftContract.openSeaMetadata) === null || _a === void 0 ? void 0 : _a.safelistRequestStatus) ? stringToEnum(rawNftContract.openSeaMetadata.safelistRequestStatus, exports.OpenSeaSafelistRequestStatus) : null\n        })\n    }));\n}\nfunction getNftCollectionFromRaw(rawNftCollection) {\n    return nullsToUndefined(Object.assign(Object.assign({}, rawNftCollection), {\n        floorPrice: Object.assign(Object.assign({}, rawNftCollection.floorPrice), {\n            marketplace: parseNftCollectionMarketplace(rawNftCollection.floorPrice.marketplace)\n        })\n    }));\n}\nfunction getBaseNftFromRaw(rawBaseNft, contractAddress) {\n    return {\n        contractAddress: contractAddress ? contractAddress : rawBaseNft.contractAddress,\n        tokenId: rawBaseNft.tokenId\n    };\n}\nfunction getNftFromRaw(rawNft) {\n    return nullsToUndefined(Object.assign(Object.assign({}, rawNft), {\n        contract: getNftContractForNftFromRaw(rawNft.contract),\n        tokenType: parseNftTokenType(rawNft.tokenType),\n        acquiredAt: rawNft.acquiredAt,\n        collection: rawNft.collection,\n        mint: rawNft.mint\n    }));\n}\nfunction getNftSalesFromRaw(rawNftSales) {\n    return nullsToUndefined({\n        nftSales: rawNftSales.nftSales.map((rawNftSale)=>Object.assign(Object.assign({}, rawNftSale), {\n                marketplace: parseNftSaleMarketplace(rawNftSale.marketplace),\n                taker: parseNftTaker(rawNftSale.taker)\n            })),\n        validAt: rawNftSales.validAt,\n        pageKey: rawNftSales.pageKey\n    });\n}\nfunction parseNftSaleMarketplace(marketplace) {\n    switch(marketplace){\n        case \"looksrare\":\n            return exports.NftSaleMarketplace.LOOKSRARE;\n        case \"seaport\":\n            return exports.NftSaleMarketplace.SEAPORT;\n        case \"x2y2\":\n            return exports.NftSaleMarketplace.X2Y2;\n        case \"wyvern\":\n            return exports.NftSaleMarketplace.WYVERN;\n        case \"cryptopunks\":\n            return exports.NftSaleMarketplace.CRYPTOPUNKS;\n        case \"blur\":\n            return exports.NftSaleMarketplace.BLUR;\n        default:\n            return exports.NftSaleMarketplace.UNKNOWN;\n    }\n}\nfunction parseNftCollectionMarketplace(marketplace) {\n    switch(marketplace){\n        case \"OpenSea\":\n            return exports.NftCollectionMarketplace.OPENSEA;\n        default:\n            return undefined;\n    }\n}\nfunction parseNftTaker(taker) {\n    // The `.toLowerCase()` call is needed because the API returns the capitalized values\n    switch(taker.toLowerCase()){\n        case \"buyer\":\n            return exports.NftSaleTakerType.BUYER;\n        case \"seller\":\n            return exports.NftSaleTakerType.SELLER;\n        default:\n            throw new Error(`Unsupported NftSaleTakerType ${taker}`);\n    }\n}\nfunction parseNftSpamClassification(s) {\n    const res = stringToEnum(s, exports.NftSpamClassification);\n    if (res == null) {\n        return exports.NftSpamClassification.Unknown;\n    }\n    return res;\n}\nfunction parseNftTokenType(tokenType) {\n    switch(tokenType){\n        case \"erc721\":\n        case \"ERC721\":\n            return exports.NftTokenType.ERC721;\n        case \"erc1155\":\n        case \"ERC1155\":\n            return exports.NftTokenType.ERC1155;\n        case \"no_supported_nft_standard\":\n        case \"NO_SUPPORTED_NFT_STANDARD\":\n            return exports.NftTokenType.NO_SUPPORTED_NFT_STANDARD;\n        case \"not_a_contract\":\n        case \"NOT_A_CONTRACT\":\n            return exports.NftTokenType.NOT_A_CONTRACT;\n        default:\n            return exports.NftTokenType.UNKNOWN;\n    }\n}\nconst IS_BROWSER =  false && 0;\nfunction nullsToUndefined(obj) {\n    if (obj === null || obj === undefined) {\n        return undefined;\n    }\n    if (obj.constructor.name === \"Object\" || Array.isArray(obj)) {\n        for(const key in obj){\n            obj[key] = nullsToUndefined(obj[key]);\n        }\n    }\n    return obj;\n}\n/**\r\n * This file contains the underlying implementations for exposed API surface in\r\n * the {@link CoreNamespace}. By moving the methods out into a separate file,\r\n * other namespaces can access these methods without depending on the entire\r\n * CoreNamespace, or override the `srcMethod` param used for logging.\r\n */ /**\r\n * Gets the asset transfers for the provided params.\r\n */ function getAssetTransfers(config, params, srcMethod = \"getAssetTransfers\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        if (params.fromAddress) {\n            params.fromAddress = yield provider._getAddress(params.fromAddress);\n        }\n        if (params.toAddress) {\n            params.toAddress = yield provider._getAddress(params.toAddress);\n        }\n        return provider._send(\"alchemy_getAssetTransfers\", [\n            Object.assign(Object.assign({}, params), {\n                fromBlock: params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n                toBlock: params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n                maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n            })\n        ], srcMethod);\n    });\n}\nfunction getTransactionReceipts(config, params, srcMethod = \"getTransactionReceipts\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        return provider._send(\"alchemy_getTransactionReceipts\", [\n            params\n        ], srcMethod);\n    });\n}\n/**\r\n * This method is based on the ethers implementation of getLogs, but is expanded\r\n * to support specifying an address array in the filter.\r\n *\r\n * The main modifications made to support an address array are:\r\n * - Custom `getFilter()` method that supports an address array\r\n * - Use of `arrayOf()` formatter to format the logs to avoid the `Formatter` import.\r\n * - Use of `provider.send()` to avoid formatting logic in `provider.perform()`.\r\n */ function getLogs(config, filter) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        yield provider.getNetwork();\n        const params = yield resolveProperties({\n            filter: getFilter(config, filter)\n        });\n        const logs = yield provider.send(\"eth_getLogs\", [\n            params.filter\n        ]);\n        logs.forEach((log)=>{\n            if (log.removed == null) {\n                log.removed = false;\n            }\n        });\n        return arrayOf(provider.formatter.filterLog.bind(provider.formatter))(logs);\n    });\n}\n/**\r\n * This method is based on and copied from the ethers implementation of\r\n * `JsonRpcProvider._getFilter()`, but is extended to support an address array.\r\n *\r\n * This implementation is a hacky way to get around the ethers formatter. The\r\n * formatter is used to check the types of the `filter` params, but ethers does\r\n * not allow an array in the `address` field. To preserve the ethers formatter\r\n * on the other fields, we use the formatter to check the types of those other\r\n * fields, and then manually check the `address` field last.\r\n */ function getFilter(config, filter) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        // START MODIFIED CODE\n        const provider = yield config.getProvider();\n        const resolvedFilter = yield filter;\n        let result = {};\n        // END MODIFIED CODE\n        [\n            \"blockHash\",\n            \"topics\"\n        ].forEach((key)=>{\n            if (resolvedFilter[key] == null) {\n                return;\n            }\n            result[key] = resolvedFilter[key];\n        });\n        [\n            \"fromBlock\",\n            \"toBlock\"\n        ].forEach((key)=>{\n            if (resolvedFilter[key] == null) {\n                return;\n            }\n            result[key] = provider._getBlockTag(resolvedFilter[key]);\n        });\n        // BEGIN MODIFIED CODE\n        // Format the `result` object using the ethers formatter without the `address`\n        // field.\n        result = provider.formatter.filter((yield resolveProperties(result)));\n        // After formatting the other fields, manually format the `address` field\n        // before adding it to the `result` object.\n        if (Array.isArray(resolvedFilter.address)) {\n            result.address = yield Promise.all(resolvedFilter.address.map((address)=>__awaiter$1(this, void 0, void 0, function*() {\n                    return provider._getAddress(address);\n                })));\n        } else if (resolvedFilter.address != null) {\n            result.address = yield provider._getAddress(resolvedFilter.address);\n        }\n        return result;\n    // END MODIFIED CODE\n    });\n}\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * This function is directly copied over from ethers implementation of\r\n * `Formatter.arrayOf()`. It is copied here to avoid having to import the\r\n * `Formatter` class or `FormatterFunc` type from ethers, that are not part of\r\n * the default export.\r\n *\r\n * This function returns a function that applies the formatter to an array of\r\n * values, and is used to format the logs returned by `getLogs()`.\r\n */ function arrayOf(format) {\n    return function(array) {\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        const result = [];\n        array.forEach((value)=>{\n            result.push(format(value));\n        });\n        return result;\n    };\n}\n/**\r\n * The core namespace contains all commonly-used [Ethers.js\r\n * Provider](https://docs.ethers.io/v5/api/providers/api-providers/#AlchemyProvider)\r\n * methods. If you are already using Ethers.js, you should be simply able to\r\n * replace the Ethers.js Provider object with `alchemy.core` when accessing\r\n * provider methods and it should just work.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.core`.\r\n */ class CoreNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Returns the balance of a given address as of the provided block.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the balance for.\r\n     * @param blockTag The optional block number or hash to get the balance for.\r\n     *   Defaults to 'latest' if unspecified.\r\n     * @public\r\n     */ getBalance(addressOrName, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBalance(addressOrName, blockTag);\n        });\n    }\n    /**\r\n     * Checks if the provided address is a smart contract.\r\n     *\r\n     * @param address The address to check type for.\r\n     * @public\r\n     */ isContractAddress(address) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const code = yield provider.getCode(address);\n            return code !== \"0x\";\n        });\n    }\n    /**\r\n     * Returns the contract code of the provided address at the block. If there is\r\n     * no contract deployed, the result is `0x`.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the code for.\r\n     * @param blockTag The optional block number or hash to get the code for.\r\n     *   Defaults to 'latest' if unspecified.\r\n     * @public\r\n     */ getCode(addressOrName, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getCode(addressOrName, blockTag);\n        });\n    }\n    /**\r\n     * Return the value of the provided position at the provided address, at the\r\n     * provided block in `Bytes32` format.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the code for.\r\n     * @param position The position of the storage slot to get.\r\n     * @param blockTag The optional block number or hash to get the code for.\r\n     *   Defaults to 'latest' if unspecified.\r\n     * @public\r\n     */ getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getStorageAt(addressOrName, position, blockTag);\n        });\n    }\n    /**\r\n     * Returns the number of transactions ever sent from the provided address, as\r\n     * of the provided block tag. This value is used as the nonce for the next\r\n     * transaction from the address sent to the network.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the nonce for.\r\n     * @param blockTag The optional block number or hash to get the nonce for.\r\n     * @public\r\n     */ getTransactionCount(addressOrName, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransactionCount(addressOrName, blockTag);\n        });\n    }\n    /**\r\n     * Returns the block from the network based on the provided block number or\r\n     * hash. Transactions on the block are represented as an array of transaction\r\n     * hashes. To get the full transaction details on the block, use\r\n     * {@link getBlockWithTransactions} instead.\r\n     *\r\n     * @param blockHashOrBlockTag The block number or hash to get the block for.\r\n     * @public\r\n     */ getBlock(blockHashOrBlockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBlock(blockHashOrBlockTag);\n        });\n    }\n    /**\r\n     * Returns the block from the network based on the provided block number or\r\n     * hash. Transactions on the block are represented as an array of\r\n     * {@link TransactionResponse} objects.\r\n     *\r\n     * @param blockHashOrBlockTag The block number or hash to get the block for.\r\n     * @public\r\n     */ getBlockWithTransactions(blockHashOrBlockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBlockWithTransactions(blockHashOrBlockTag);\n        });\n    }\n    /**\r\n     * Returns the {@link EthersNetworkAlias} Alchemy is connected to.\r\n     *\r\n     * @public\r\n     */ getNetwork() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getNetwork();\n        });\n    }\n    /**\r\n     * Returns the block number of the most recently mined block.\r\n     *\r\n     * @public\r\n     */ getBlockNumber() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBlockNumber();\n        });\n    }\n    /**\r\n     * Returns the best guess of the current gas price to use in a transaction.\r\n     *\r\n     * @public\r\n     */ getGasPrice() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getGasPrice();\n        });\n    }\n    /**\r\n     * Returns the recommended fee data to use in a transaction.\r\n     *\r\n     * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas\r\n     * should be used.\r\n     *\r\n     * For legacy transactions and networks which do not support EIP-1559, the\r\n     * gasPrice should be used.\r\n     *\r\n     * @public\r\n     */ getFeeData() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getFeeData();\n        });\n    }\n    /**\r\n     * Returns a Promise which will stall until the network has heen established,\r\n     * ignoring errors due to the target node not being active yet.\r\n     *\r\n     * This can be used for testing or attaching scripts to wait until the node is\r\n     * up and running smoothly.\r\n     *\r\n     * @public\r\n     */ ready() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.ready;\n        });\n    }\n    /**\r\n     * Returns the result of executing the transaction, using call. A call does\r\n     * not require any ether, but cannot change any state. This is useful for\r\n     * calling getters on Contracts.\r\n     *\r\n     * @param transaction The transaction to execute.\r\n     * @param blockTag The optional block number or hash to get the call for.\r\n     * @public\r\n     */ call(transaction, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.call(transaction, blockTag);\n        });\n    }\n    /**\r\n     * Returns an estimate of the amount of gas that would be required to submit\r\n     * transaction to the network.\r\n     *\r\n     * An estimate may not be accurate since there could be another transaction on\r\n     * the network that was not accounted for, but after being mined affects the\r\n     * relevant state.\r\n     *\r\n     * This is an alias for {@link TransactNamespace.estimateGas}.\r\n     *\r\n     * @param transaction The transaction to estimate gas for.\r\n     * @public\r\n     */ estimateGas(transaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.estimateGas(transaction);\n        });\n    }\n    /**\r\n     * Returns the transaction with hash or null if the transaction is unknown.\r\n     *\r\n     * If a transaction has not been mined, this method will search the\r\n     * transaction pool. Various backends may have more restrictive transaction\r\n     * pool access (e.g. if the gas price is too low or the transaction was only\r\n     * recently sent and not yet indexed) in which case this method may also return null.\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */ getTransaction(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransaction(transactionHash);\n        });\n    }\n    /**\r\n     * Returns the transaction receipt for hash or null if the transaction has not\r\n     * been mined.\r\n     *\r\n     * To stall until the transaction has been mined, consider the\r\n     * waitForTransaction method below.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */ getTransactionReceipt(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransactionReceipt(transactionHash);\n        });\n    }\n    /**\r\n     * Submits transaction to the network to be mined. The transaction must be\r\n     * signed, and be valid (i.e. the nonce is correct and the account has\r\n     * sufficient balance to pay for the transaction).\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param signedTransaction The signed transaction to send.\r\n     * @public\r\n     */ sendTransaction(signedTransaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.sendTransaction(signedTransaction);\n        });\n    }\n    /**\r\n     * Returns a promise which will not resolve until specified transaction hash is mined.\r\n     *\r\n     * If {@link confirmations} is 0, this method is non-blocking and if the\r\n     * transaction has not been mined returns null. Otherwise, this method will\r\n     * block until the transaction has confirmed blocks mined on top of the block\r\n     * in which it was mined.\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to wait for.\r\n     * @param confirmations The number of blocks to wait for.\r\n     * @param timeout The maximum time to wait for the transaction to confirm.\r\n     * @public\r\n     */ waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.waitForTransaction(transactionHash, confirmations, timeout);\n        });\n    }\n    /**\r\n     * Returns an array of logs that match the provided filter.\r\n     *\r\n     * @param filter The filter object to use.\r\n     * @public\r\n     */ getLogs(filter) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getLogs(this.config, filter);\n        });\n    }\n    /**\r\n     * Allows sending a raw message to the Alchemy backend.\r\n     *\r\n     * @param method The method to call.\r\n     * @param params The parameters to pass to the method.\r\n     * @public\r\n     */ send(method, params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.send(method, params);\n        });\n    }\n    /**\r\n     * Finds the address that deployed the provided contract and block number it\r\n     * was deployed in.\r\n     *\r\n     * NOTE: This method performs a binary search across all blocks since genesis\r\n     * and can take a long time to complete. This method is a convenience method\r\n     * that will eventually be replaced by a single call to an Alchemy endpoint\r\n     * with this information cached.\r\n     *\r\n     * @param contractAddress - The contract address to find the deployer for.\r\n     * @beta\r\n     */ findContractDeployer(contractAddress) {\n        var _a;\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const currentBlockNum = yield provider.getBlockNumber();\n            if ((yield provider.getCode(contractAddress, currentBlockNum)) === ETH_NULL_VALUE) {\n                throw new Error(`Contract '${contractAddress}' does not exist`);\n            }\n            // Binary search for the block number that the contract was deployed in.\n            const firstBlock = yield binarySearchFirstBlock(0, currentBlockNum + 1, contractAddress, this.config);\n            // Find the first transaction in the block that matches the provided address.\n            const txReceipts = yield getTransactionReceipts(this.config, {\n                blockNumber: toHex(firstBlock)\n            }, \"findContractDeployer\");\n            const matchingReceipt = (_a = txReceipts.receipts) === null || _a === void 0 ? void 0 : _a.find((receipt)=>receipt.contractAddress === contractAddress.toLowerCase());\n            return {\n                deployerAddress: matchingReceipt === null || matchingReceipt === void 0 ? void 0 : matchingReceipt.from,\n                blockNumber: firstBlock\n            };\n        });\n    }\n    getTokenBalances(addressOrName, contractAddressesOrOptions) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const address = yield provider._getAddress(addressOrName);\n            if (Array.isArray(contractAddressesOrOptions)) {\n                if (contractAddressesOrOptions.length > 1500) {\n                    throw new Error(\"You cannot pass in more than 1500 contract addresses to getTokenBalances()\");\n                }\n                if (contractAddressesOrOptions.length === 0) {\n                    throw new Error(\"getTokenBalances() requires at least one contractAddress when using an array\");\n                }\n                return provider._send(\"alchemy_getTokenBalances\", [\n                    address,\n                    contractAddressesOrOptions\n                ], \"getTokenBalances\");\n            } else {\n                const tokenType = contractAddressesOrOptions === undefined ? exports.TokenBalanceType.ERC20 : contractAddressesOrOptions.type;\n                const params = [\n                    address,\n                    tokenType\n                ];\n                if ((contractAddressesOrOptions === null || contractAddressesOrOptions === void 0 ? void 0 : contractAddressesOrOptions.type) === exports.TokenBalanceType.ERC20 && contractAddressesOrOptions.pageKey) {\n                    params.push({\n                        pageKey: contractAddressesOrOptions.pageKey\n                    });\n                }\n                return provider._send(\"alchemy_getTokenBalances\", params, \"getTokenBalances\");\n            }\n        });\n    }\n    /**\r\n     * Returns the tokens that the specified address owns, along with the amount\r\n     * of each token and the relevant metadata.\r\n     *\r\n     * @param addressOrName The owner address to get the tokens with balances for.\r\n     * @param options Additional options to pass to the request.\r\n     * @public\r\n     */ getTokensForOwner(addressOrName, options) {\n        var _a;\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const address = yield provider._getAddress(addressOrName);\n            const params = [\n                address,\n                (_a = options === null || options === void 0 ? void 0 : options.contractAddresses) !== null && _a !== void 0 ? _a : exports.TokenBalanceType.ERC20\n            ];\n            if (options === null || options === void 0 ? void 0 : options.pageKey) {\n                params.push({\n                    pageKey: options.pageKey\n                });\n            }\n            const response = yield provider._send(\"alchemy_getTokenBalances\", params, \"getTokensForOwner\");\n            const formattedBalances = response.tokenBalances.map((balance)=>({\n                    contractAddress: balance.contractAddress,\n                    rawBalance: bignumber.BigNumber.from(balance.tokenBalance).toString()\n                }));\n            const metadataPromises = yield Promise.allSettled(response.tokenBalances.map((token)=>provider._send(\"alchemy_getTokenMetadata\", [\n                    token.contractAddress\n                ], \"getTokensForOwner\")));\n            const metadata = metadataPromises.map((p)=>p.status === \"fulfilled\" ? p.value : {\n                    name: null,\n                    symbol: null,\n                    decimals: null,\n                    logo: null\n                });\n            const ownedTokens = formattedBalances.map((balance, index)=>Object.assign(Object.assign(Object.assign({}, balance), metadata[index]), {\n                    balance: metadata[index].decimals !== null ? utils.formatUnits(balance.rawBalance, metadata[index].decimals) : undefined\n                }));\n            return {\n                tokens: ownedTokens.map((t)=>nullsToUndefined(t)),\n                pageKey: response.pageKey\n            };\n        });\n    }\n    /**\r\n     * Returns metadata for a given token contract address.\r\n     *\r\n     * @param address The contract address to get metadata for.\r\n     * @public\r\n     */ getTokenMetadata(address) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"alchemy_getTokenMetadata\", [\n                address\n            ], \"getTokenMetadata\");\n        });\n    }\n    getAssetTransfers(params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getAssetTransfers(this.config, params);\n        });\n    }\n    /**\r\n     * Gets all transaction receipts for a given block by number or block hash.\r\n     *\r\n     * @param params An object containing fields for the transaction receipt query.\r\n     * @public\r\n     */ getTransactionReceipts(params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getTransactionReceipts(this.config, params);\n        });\n    }\n    /**\r\n     * Returns the underlying owner address for the provided ENS address, or `null`\r\n     * if the ENS name does not have an underlying address.\r\n     *\r\n     * @param name The ENS address name to resolve.\r\n     */ resolveName(name) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.resolveName(name);\n        });\n    }\n    /**\r\n     * Performs a reverse lookup of the address in ENS using the Reverse Registrar. If the name does not exist, or the forward lookup does not match, null is returned.\r\n     *\r\n     * An ENS name requires additional configuration to setup a reverse record, so not all ENS addresses will map back to the original ENS domain.\r\n     *\r\n     * @param address The address to look up the ENS domain name for.\r\n     */ lookupAddress(address) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.lookupAddress(address);\n        });\n    }\n}\n/**\r\n * Perform a binary search between an integer range of block numbers to find the\r\n * block number where the contract was deployed.\r\n *\r\n * @internal\r\n */ function binarySearchFirstBlock(start, end, address, config) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        if (start >= end) {\n            return end;\n        }\n        const mid = Math.floor((start + end) / 2);\n        const provider = yield config.getProvider();\n        const code = yield provider.getCode(address, mid);\n        if (code === ETH_NULL_VALUE) {\n            return binarySearchFirstBlock(mid + 1, end, address, config);\n        }\n        return binarySearchFirstBlock(start, mid, address, config);\n    });\n}\n/**\r\n * The Debug namespace contains methods to access the non-standard RPC methods\r\n * for inspecting and debugging transactions.\r\n *\r\n * For more information on the different methods and use cases please read our\r\n * [documentation](https://docs.alchemy.com/reference/debug-api-quickstart).\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the debug namespace\r\n * via `alchemy.debug`.\r\n */ class DebugNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    traceCall(transaction, blockIdentifier, tracer) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = [\n                transaction,\n                blockIdentifier,\n                parseTracerParams(tracer)\n            ];\n            return provider._send(\"debug_traceCall\", params, \"traceCall\");\n        });\n    }\n    traceTransaction(transactionHash, tracer, timeout) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = [\n                transactionHash,\n                parseTracerParams(tracer, timeout)\n            ];\n            return provider._send(\"debug_traceTransaction\", params, \"traceTransaction\");\n        });\n    }\n    traceBlock(blockIdentifier, tracer) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            let method;\n            let params;\n            if (utils.isHexString(blockIdentifier, 32)) {\n                method = \"debug_traceBlockByHash\";\n                params = [\n                    blockIdentifier,\n                    parseTracerParams(tracer)\n                ];\n            } else {\n                method = \"debug_traceBlockByNumber\";\n                const block = typeof blockIdentifier === \"number\" ? utils.hexStripZeros(utils.hexValue(blockIdentifier)) : blockIdentifier;\n                params = [\n                    block,\n                    parseTracerParams(tracer)\n                ];\n            }\n            return provider._send(method, params, \"traceBlock\");\n        });\n    }\n}\nfunction parseTracerParams(tracer, timeout) {\n    return Object.assign({\n        tracer: tracer.type\n    }, tracer.onlyTopCall !== undefined && {\n        tracerConfig: {\n            onlyTopCall: tracer.onlyTopCall,\n            timeout\n        }\n    });\n}\nfunction sanitizeTokenType(tokenType) {\n    if (tokenType === exports.NftTokenType.ERC1155 || tokenType === exports.NftTokenType.ERC721) {\n        return tokenType;\n    }\n    return undefined;\n}\n/**\r\n * The SDK has 4 log levels and a 5th option for disabling all logging. By\r\n * default, the log level is set to INFO.\r\n *\r\n * The order is a follows: DEBUG < INFO < WARN < ERROR\r\n *\r\n * All log types above the current log level will be outputted.\r\n */ var LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"INFO\"] = 1] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 2] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 3] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 4] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst logLevelStringToEnum = {\n    debug: LogLevel.DEBUG,\n    info: LogLevel.INFO,\n    warn: LogLevel.WARN,\n    error: LogLevel.ERROR,\n    silent: LogLevel.SILENT\n};\n// HACKY: Use the console method as a string rather than the function itself\n// in order to allow for mocking in tests.\nconst logLevelToConsoleFn = {\n    [LogLevel.DEBUG]: \"log\",\n    [LogLevel.INFO]: \"info\",\n    [LogLevel.WARN]: \"warn\",\n    [LogLevel.ERROR]: \"error\"\n};\nconst DEFAULT_LOG_LEVEL = LogLevel.INFO;\n/**\r\n * Configures the verbosity of logging. The default log level is `info`.\r\n *\r\n * @param logLevel - The verbosity of logging. Can be any of the following values:\r\n *\r\n *   - `debug`: The most verbose logging level.\r\n *   - `info`: The default logging level.\r\n *   - `warn`: A logging level for non-critical issues.\r\n *   - `error`: A logging level for critical issues.\r\n *   - `silent`: Turn off all logging.\r\n *\r\n * @public\r\n */ function setLogLevel(logLevel) {\n    loggerClient.logLevel = logLevelStringToEnum[logLevel];\n}\nfunction logDebug(message, ...args) {\n    loggerClient.debug(message, args);\n}\nfunction logInfo(message, ...args) {\n    loggerClient.info(message, args);\n}\nfunction logWarn(message, ...args) {\n    loggerClient.warn(message, args);\n}\nclass Logger {\n    constructor(){\n        /** The log level of the given Logger instance. */ this._logLevel = DEFAULT_LOG_LEVEL;\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    debug(...args) {\n        this._log(LogLevel.DEBUG, ...args);\n    }\n    info(...args) {\n        this._log(LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._log(LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._log(LogLevel.ERROR, ...args);\n    }\n    /**\r\n     * Forwards log messages to their corresponding console counterparts if the\r\n     * log level allows it.\r\n     */ _log(logLevel, ...args) {\n        if (logLevel < this._logLevel) {\n            return;\n        }\n        const now = new Date().toISOString();\n        const method = logLevelToConsoleFn[logLevel];\n        if (method) {\n            console[method](`[${now}] Alchemy:`, ...args.map(stringify));\n        } else {\n            throw new Error(`Logger received an invalid logLevel (value: ${logLevel})`);\n        }\n    }\n}\nfunction stringify(obj) {\n    if (typeof obj === \"string\") {\n        return obj;\n    } else {\n        try {\n            return JSON.stringify(obj);\n        } catch (e) {\n            // Failed to convert to JSON, log the object directly.\n            return obj;\n        }\n    }\n}\n// Instantiate default logger for the SDK.\nconst loggerClient = new Logger();\n// This file is autogenerated by injectVersion.js. Any changes will be\n// overwritten on commit!\nconst VERSION = \"3.6.2\";\n/**\r\n * Given a REST endpoint, method, and params, sends the request with axios and\r\n * returns the response.\r\n */ /**\r\n * Helper function to send http requests using Axis.\r\n *\r\n * @private\r\n */ function sendAxiosRequest(baseUrl, restApiName, methodName, params, overrides) {\n    var _a;\n    const requestUrl = baseUrl + \"/\" + restApiName;\n    const config = Object.assign(Object.assign({}, overrides), {\n        headers: Object.assign(Object.assign(Object.assign({}, overrides === null || overrides === void 0 ? void 0 : overrides.headers), !IS_BROWSER && {\n            \"Accept-Encoding\": \"gzip\"\n        }), {\n            \"Alchemy-Ethers-Sdk-Version\": VERSION,\n            \"Alchemy-Ethers-Sdk-Method\": methodName\n        }),\n        method: (_a = overrides === null || overrides === void 0 ? void 0 : overrides.method) !== null && _a !== void 0 ? _a : \"GET\",\n        url: requestUrl,\n        params\n    });\n    return axios__default[\"default\"](config);\n}\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nconst DEFAULT_BACKOFF_MULTIPLIER = 1.5;\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 30 * 1000;\nconst DEFAULT_BACKOFF_MAX_ATTEMPTS = 5;\n/**\r\n * Helper class for implementing exponential backoff and max retry attempts.\r\n *\r\n * @private\r\n * @internal\r\n */ class ExponentialBackoff {\n    constructor(maxAttempts = DEFAULT_BACKOFF_MAX_ATTEMPTS){\n        this.maxAttempts = maxAttempts;\n        this.initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n        this.backoffMultiplier = DEFAULT_BACKOFF_MULTIPLIER;\n        this.maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;\n        this.numAttempts = 0;\n        this.currentDelayMs = 0;\n        this.isInBackoff = false;\n    }\n    /**\r\n     * Returns a promise that resolves after the the backoff delay. The delay is\r\n     * increased for each attempt. The promise is rejected if the maximum number\r\n     * of attempts is exceeded.\r\n     */ // TODO: beautify this into an async iterator.\n    backoff() {\n        if (this.numAttempts >= this.maxAttempts) {\n            return Promise.reject(new Error(`Exceeded maximum number of attempts: ${this.maxAttempts}`));\n        }\n        if (this.isInBackoff) {\n            return Promise.reject(new Error(\"A backoff operation is already in progress\"));\n        }\n        const backoffDelayWithJitterMs = this.withJitterMs(this.currentDelayMs);\n        if (backoffDelayWithJitterMs > 0) {\n            logDebug(\"ExponentialBackoff.backoff\", `Backing off for ${backoffDelayWithJitterMs}ms`);\n        }\n        // Calculate the next delay.\n        this.currentDelayMs *= this.backoffMultiplier;\n        this.currentDelayMs = Math.max(this.currentDelayMs, this.initialDelayMs);\n        this.currentDelayMs = Math.min(this.currentDelayMs, this.maxDelayMs);\n        this.numAttempts += 1;\n        return new Promise((resolve)=>{\n            this.isInBackoff = true;\n            setTimeout(()=>{\n                this.isInBackoff = false;\n                resolve();\n            }, backoffDelayWithJitterMs);\n        });\n    }\n    /**\r\n     * Applies +/- 50% jitter to the backoff delay, up to the max delay cap.\r\n     *\r\n     * @private\r\n     * @param delayMs\r\n     */ withJitterMs(delayMs) {\n        return Math.min(delayMs + (Math.random() - 0.5) * delayMs, this.maxDelayMs);\n    }\n}\n/**\r\n * A wrapper function to make http requests and retry if the request fails.\r\n *\r\n * @internal\r\n */ // TODO: Wrap Axios error in AlchemyError.\nfunction requestHttpWithBackoff(config, apiType, restApiName, methodName, params, overrides) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        let lastError = undefined;\n        const backoff = new ExponentialBackoff(config.maxRetries);\n        for(let attempt = 0; attempt < config.maxRetries + 1; attempt++){\n            try {\n                if (lastError !== undefined) {\n                    logInfo(\"requestHttp\", `Retrying after error: ${lastError.message}`);\n                }\n                try {\n                    yield backoff.backoff();\n                } catch (err) {\n                    break;\n                }\n                const response = yield sendAxiosRequest(config._getRequestUrl(apiType), restApiName, methodName, params, Object.assign(Object.assign({}, overrides), {\n                    timeout: config.requestTimeout\n                }));\n                if (response.status === 200) {\n                    logDebug(restApiName, `Successful request: ${restApiName}`);\n                    return response.data;\n                } else {\n                    logInfo(restApiName, `Request failed: ${restApiName}, ${response.status}, ${response.data}`);\n                    lastError = new Error(response.status + \": \" + response.data);\n                }\n            } catch (err) {\n                if (!axios__default[\"default\"].isAxiosError(err) || err.response === undefined) {\n                    throw err;\n                }\n                // TODO: Standardize all errors into AlchemyError\n                lastError = new Error(err.response.status + \": \" + JSON.stringify(err.response.data));\n                if (!isRetryableHttpError(err, apiType)) {\n                    break;\n                }\n            }\n        }\n        return Promise.reject(lastError);\n    });\n}\nfunction isRetryableHttpError(err, apiType) {\n    // TODO: remove 500s after webhooks are more stable.\n    const retryableCodes = apiType === AlchemyApiType.WEBHOOK ? [\n        429,\n        500\n    ] : [\n        429\n    ];\n    return err.response !== undefined && retryableCodes.includes(err.response.status);\n}\n/**\r\n * Fetches all pages in a paginated endpoint, given a `pageKey` field that\r\n * represents the property name containing the next page token.\r\n *\r\n * @internal\r\n */ function paginateEndpoint(config, apiType, restApiName, methodName, reqPageKey, resPageKey, params) {\n    return __asyncGenerator(this, arguments, function* paginateEndpoint_1() {\n        let hasNext = true;\n        const requestParams = Object.assign({}, params);\n        while(hasNext){\n            const response = yield __await(requestHttpWithBackoff(config, apiType, restApiName, methodName, requestParams));\n            yield yield __await(response);\n            if (response[resPageKey] !== null) {\n                requestParams[reqPageKey] = response[resPageKey];\n            } else {\n                hasNext = false;\n            }\n        }\n    });\n}\n/**\r\n * This file contains the underlying implementations for exposed API surface in\r\n * the {@link NftNamespace}. By moving the methods out into a separate file,\r\n * other namespaces can access these methods without depending on the entire\r\n * NftNamespace.\r\n */ /**\r\n * Get the NFT metadata for the provided contract address.\r\n */ function getNftMetadata(config, contractAddress, tokenId, options, srcMethod = \"getNftMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTMetadata\", srcMethod, {\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString(),\n            tokenType: sanitizeTokenType(options === null || options === void 0 ? void 0 : options.tokenType),\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            refreshCache: options === null || options === void 0 ? void 0 : options.refreshCache\n        });\n        return getNftFromRaw(response);\n    });\n}\nfunction getNftMetadataBatch(config, tokens, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const data = {\n            tokens,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            refreshCache: options === null || options === void 0 ? void 0 : options.refreshCache\n        };\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTMetadataBatch\", \"getNftMetadataBatch\", {}, {\n            method: \"POST\",\n            data\n        });\n        return {\n            nfts: response.nfts.map((nft)=>getNftFromRaw(nft))\n        };\n    });\n}\nfunction getContractMetadata(config, contractAddress, srcMethod = \"getContractMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getContractMetadata\", srcMethod, {\n            contractAddress\n        });\n        return getNftContractFromRaw(response);\n    });\n}\nfunction getContractMetadataBatch(config, contractAddresses) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getContractMetadataBatch\", \"getContractMetadataBatch\", {}, {\n            method: \"POST\",\n            data: {\n                contractAddresses\n            }\n        });\n        return {\n            contracts: response.contracts.map(getNftContractFromRaw)\n        };\n    });\n}\nfunction getCollectionMetadata(config, collectionSlug, srcMethod = \"getCollectionMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getCollectionMetadata\", srcMethod, {\n            collectionSlug\n        });\n        return getNftCollectionFromRaw(response);\n    });\n}\nfunction getNftsForOwnerIterator(config, owner, options, srcMethod = \"getNftsForOwnerIterator\") {\n    return __asyncGenerator(this, arguments, function* getNftsForOwnerIterator_1() {\n        var e_1, _a;\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        try {\n            for(var _b = __asyncValues(paginateEndpoint(config, AlchemyApiType.NFT, \"getNFTsForOwner\", srcMethod, \"pageKey\", \"pageKey\", {\n                contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n                pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n                excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n                includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,\n                owner,\n                withMetadata,\n                tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n                orderBy: options === null || options === void 0 ? void 0 : options.orderBy\n            })), _c; _c = yield __await(_b.next()), !_c.done;){\n                const response = _c.value;\n                for (const ownedNft of response.ownedNfts){\n                    yield yield __await(Object.assign(Object.assign({}, nftFromGetNftResponse(ownedNft)), {\n                        balance: ownedNft.balance\n                    }));\n                }\n            }\n        } catch (e_1_1) {\n            e_1 = {\n                error: e_1_1\n            };\n        } finally{\n            try {\n                if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n            } finally{\n                if (e_1) throw e_1.error;\n            }\n        }\n    });\n}\nfunction getNftsForOwner(config, owner, options, srcMethod = \"getNftsForOwner\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTsForOwner\", srcMethod, {\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n            includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,\n            owner,\n            pageSize: options === null || options === void 0 ? void 0 : options.pageSize,\n            withMetadata,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            orderBy: options === null || options === void 0 ? void 0 : options.orderBy\n        });\n        if (withMetadata) {\n            return nullsToUndefined({\n                ownedNfts: response.ownedNfts.map((res)=>Object.assign(Object.assign({}, getNftFromRaw(res)), {\n                        balance: res.balance\n                    })),\n                pageKey: response.pageKey,\n                totalCount: response.totalCount,\n                validAt: response.validAt\n            });\n        }\n        return nullsToUndefined({\n            ownedNfts: response.ownedNfts.map((res)=>Object.assign(Object.assign({}, getBaseNftFromRaw(res)), {\n                    balance: res.balance\n                })),\n            pageKey: response.pageKey,\n            totalCount: response.totalCount,\n            validAt: response.validAt\n        });\n    });\n}\nfunction getNftsForContract(config, contractAddress, options, srcMethod = \"getNftsForContract\") {\n    var _a;\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTsForContract\", srcMethod, {\n            contractAddress,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            withMetadata,\n            limit: (_a = options === null || options === void 0 ? void 0 : options.pageSize) !== null && _a !== void 0 ? _a : undefined,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs\n        });\n        if (withMetadata) {\n            return nullsToUndefined({\n                nfts: response.nfts.map((res)=>getNftFromRaw(res)),\n                pageKey: response.pageKey\n            });\n        }\n        return nullsToUndefined({\n            nfts: response.nfts.map((res)=>getBaseNftFromRaw(res, contractAddress)),\n            pageKey: response.pageKey\n        });\n    });\n}\nfunction getNftsForContractIterator(config, contractAddress, options, srcMethod = \"getNftsForContractIterator\") {\n    return __asyncGenerator(this, arguments, function* getNftsForContractIterator_1() {\n        var e_2, _a;\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        try {\n            for(var _b = __asyncValues(paginateEndpoint(config, AlchemyApiType.NFT, \"getNFTsForContract\", srcMethod, \"pageKey\", \"pageKey\", {\n                contractAddress,\n                pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n                withMetadata\n            })), _c; _c = yield __await(_b.next()), !_c.done;){\n                const response = _c.value;\n                for (const nft of response.nfts){\n                    yield yield __await(nftFromGetNftContractResponse(nft, contractAddress));\n                }\n            }\n        } catch (e_2_1) {\n            e_2 = {\n                error: e_2_1\n            };\n        } finally{\n            try {\n                if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n            } finally{\n                if (e_2) throw e_2.error;\n            }\n        }\n    });\n}\nfunction getOwnersForContract(config, contractAddress, options, srcMethod = \"getOwnersForContract\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        // Cast to `any` to avoid more type wrangling.\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getOwnersForContract\", srcMethod, Object.assign(Object.assign({}, options), {\n            contractAddress\n        }));\n        if (options === null || options === void 0 ? void 0 : options.withTokenBalances) {\n            return nullsToUndefined({\n                owners: response.owners,\n                pageKey: response.pageKey\n            });\n        }\n        return nullsToUndefined({\n            owners: response.owners,\n            pageKey: response.pageKey\n        });\n    });\n}\nfunction getContractsForOwner(config, owner, options, srcMethod = \"getContractsForOwner\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getContractsForOwner\", srcMethod, {\n            owner,\n            excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n            includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            pageSize: options === null || options === void 0 ? void 0 : options.pageSize,\n            orderBy: options === null || options === void 0 ? void 0 : options.orderBy\n        });\n        return nullsToUndefined({\n            contracts: response.contracts.map(getNftContractsForOwnerFromRaw),\n            pageKey: response.pageKey,\n            totalCount: response.totalCount\n        });\n    });\n}\nfunction getOwnersForNft(config, contractAddress, tokenId, options, srcMethod = \"getOwnersForNft\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getOwnersForNFT\", srcMethod, Object.assign({\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString()\n        }, options));\n    });\n}\nfunction getMintedNfts(config, owner, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        const ownerAddress = yield provider._getAddress(owner);\n        const category = nftTokenTypeToCategory(options === null || options === void 0 ? void 0 : options.tokenType);\n        const params = {\n            fromBlock: \"0x0\",\n            fromAddress: ETH_NULL_ADDRESS,\n            toAddress: ownerAddress,\n            excludeZeroValue: true,\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n        };\n        const response = yield getAssetTransfers(config, params, \"getMintedNfts\");\n        return getNftsForTransfers(config, response);\n    });\n}\nfunction getTransfersForOwner(config, owner, transferType, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        const ownerAddress = yield provider._getAddress(owner);\n        const category = nftTokenTypeToCategory(options === null || options === void 0 ? void 0 : options.tokenType);\n        const params = {\n            fromBlock: \"0x0\",\n            excludeZeroValue: true,\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n        };\n        if (transferType === exports.GetTransfersForOwnerTransferType.TO) {\n            params.toAddress = ownerAddress;\n        } else {\n            params.fromAddress = ownerAddress;\n        }\n        const transfersResponse = yield getAssetTransfers(config, params, \"getTransfersForOwner\");\n        return getNftsForTransfers(config, transfersResponse);\n    });\n}\nfunction getTransfersForContract(config, contract, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const category = [\n            exports.AssetTransfersCategory.ERC721,\n            exports.AssetTransfersCategory.ERC1155,\n            exports.AssetTransfersCategory.SPECIALNFT\n        ];\n        const provider = yield config.getProvider();\n        const fromBlock = (options === null || options === void 0 ? void 0 : options.fromBlock) ? provider.formatter.blockTag((yield provider._getBlockTag(options.fromBlock))) : \"0x0\";\n        const toBlock = (options === null || options === void 0 ? void 0 : options.toBlock) ? provider.formatter.blockTag((yield provider._getBlockTag(options.toBlock))) : undefined;\n        const params = {\n            fromBlock,\n            toBlock,\n            excludeZeroValue: true,\n            contractAddresses: [\n                contract\n            ],\n            order: options === null || options === void 0 ? void 0 : options.order,\n            category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n        };\n        const transfersResponse = yield getAssetTransfers(config, params, \"getTransfersForContract\");\n        return getNftsForTransfers(config, transfersResponse);\n    });\n}\nfunction nftTokenTypeToCategory(tokenType) {\n    switch(tokenType){\n        case exports.NftTokenType.ERC721:\n            return [\n                exports.AssetTransfersCategory.ERC721\n            ];\n        case exports.NftTokenType.ERC1155:\n            return [\n                exports.AssetTransfersCategory.ERC1155\n            ];\n        default:\n            return [\n                exports.AssetTransfersCategory.ERC721,\n                exports.AssetTransfersCategory.ERC1155,\n                exports.AssetTransfersCategory.SPECIALNFT\n            ];\n    }\n}\nfunction parse1155Transfer(transfer) {\n    return transfer.erc1155Metadata.map((metadata)=>({\n            contractAddress: transfer.rawContract.address,\n            tokenId: metadata.tokenId,\n            tokenType: exports.NftTokenType.ERC1155\n        }));\n}\nfunction verifyNftOwnership(config, owner, contractAddresses, srcMethod = \"verifyNftOwnership\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        if (typeof contractAddresses === \"string\") {\n            const response = yield getNftsForOwner(config, owner, {\n                contractAddresses: [\n                    contractAddresses\n                ],\n                omitMetadata: true\n            }, srcMethod);\n            return response.ownedNfts.length > 0;\n        } else {\n            if (contractAddresses.length === 0) {\n                throw new Error(\"Must provide at least one contract address\");\n            }\n            const response = yield getNftsForOwner(config, owner, {\n                contractAddresses,\n                omitMetadata: true\n            }, srcMethod);\n            // Create map where all input contract addresses are set to false, then flip\n            // owned nfts to true.\n            const result = contractAddresses.reduce((acc, curr)=>{\n                acc[curr] = false;\n                return acc;\n            }, {});\n            for (const nft of response.ownedNfts){\n                result[nft.contractAddress] = true;\n            }\n            return result;\n        }\n    });\n}\nfunction isSpamContract(config, contractAddress, srcMethod = \"isSpamContract\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"isSpamContract\", srcMethod, {\n            contractAddress\n        });\n    });\n}\nfunction getSpamContracts(config, srcMethod = \"getSpamContracts\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getSpamContracts\", srcMethod, undefined);\n    });\n}\nfunction reportSpam(config, contractAddress, srcMethod = \"reportSpam\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        void requestHttpWithBackoff(config, AlchemyApiType.NFT, \"reportSpam\", srcMethod, {\n            contractAddress\n        });\n    });\n}\nfunction isAirdropNft(config, contractAddress, tokenId, srcMethod = \"isAirdropNft\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"isAirdropNFT\", srcMethod, {\n            contractAddress,\n            tokenId\n        });\n    });\n}\nfunction getFloorPrice(config, contractAddress, srcMethod = \"getFloorPrice\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getFloorPrice\", srcMethod, {\n            contractAddress\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction getNftSales(config, options = {}, srcMethod = \"getNftSales\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        // Avoid ts compiler complaining about the contractAddress field.\n        const params = Object.assign({}, options);\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTSales\", srcMethod, {\n            fromBlock: params === null || params === void 0 ? void 0 : params.fromBlock,\n            toBlock: params === null || params === void 0 ? void 0 : params.toBlock,\n            order: params === null || params === void 0 ? void 0 : params.order,\n            marketplace: params === null || params === void 0 ? void 0 : params.marketplace,\n            contractAddress: params === null || params === void 0 ? void 0 : params.contractAddress,\n            tokenId: (params === null || params === void 0 ? void 0 : params.tokenId) ? bignumber.BigNumber.from(params === null || params === void 0 ? void 0 : params.tokenId).toString() : undefined,\n            sellerAddress: params === null || params === void 0 ? void 0 : params.sellerAddress,\n            buyerAddress: params === null || params === void 0 ? void 0 : params.buyerAddress,\n            taker: params === null || params === void 0 ? void 0 : params.taker,\n            limit: params === null || params === void 0 ? void 0 : params.limit,\n            pageKey: params === null || params === void 0 ? void 0 : params.pageKey\n        });\n        return getNftSalesFromRaw(response);\n    });\n}\nfunction computeRarity(config, contractAddress, tokenId, srcMethod = \"computeRarity\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"computeRarity\", srcMethod, {\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString()\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction searchContractMetadata(config, query, srcMethod = \"searchContractMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"searchContractMetadata\", srcMethod, {\n            query\n        });\n        return {\n            contracts: response.contracts.map(getNftContractFromRaw)\n        };\n    });\n}\nfunction summarizeNftAttributes(config, contractAddress, srcMethod = \"summarizeNftAttributes\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"summarizeNFTAttributes\", srcMethod, {\n            contractAddress\n        });\n    });\n}\nfunction refreshNftMetadata(config, contractAddress, tokenId, srcMethod = \"refreshNftMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const tokenIdString = bignumber.BigNumber.from(tokenId).toString();\n        const first = yield getNftMetadata(config, contractAddress, tokenIdString, undefined, srcMethod);\n        const second = yield refresh(config, contractAddress, tokenIdString, srcMethod);\n        return first.timeLastUpdated !== second.timeLastUpdated;\n    });\n}\nfunction refreshContract(config, contractAddress, srcMethod = \"refreshContract\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"reingestContract\", srcMethod, {\n            contractAddress\n        });\n        return {\n            contractAddress: response.contractAddress,\n            refreshState: parseReingestionState(response.reingestionState),\n            progress: response.progress\n        };\n    });\n}\nfunction refresh(config, contractAddress, tokenId, srcMethod) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTMetadata\", srcMethod, {\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString(),\n            refreshCache: true\n        });\n        return getNftFromRaw(response);\n    });\n}\n/**\r\n * Helper method to convert a NFT response received from Alchemy backend to an\r\n * SDK NFT type.\r\n *\r\n * @internal\r\n */ function nftFromGetNftResponse(ownedNft) {\n    if (isNftWithMetadata(ownedNft)) {\n        return getNftFromRaw(ownedNft);\n    } else {\n        return getBaseNftFromRaw(ownedNft);\n    }\n}\n/**\r\n * Helper method to convert a NFT response received from Alchemy backend to an\r\n * SDK NFT type.\r\n *\r\n * @internal\r\n */ function nftFromGetNftContractResponse(ownedNft, contractAddress) {\n    if (isNftWithMetadata(ownedNft)) {\n        return getNftFromRaw(ownedNft);\n    } else {\n        return getBaseNftFromRaw(ownedNft, contractAddress);\n    }\n}\n/** @internal */ // TODO: more comprehensive type check\nfunction isNftWithMetadata(response) {\n    return response.name !== undefined;\n}\n/**\r\n * Given an AssetTransfersResponse, fetches the NFTs associated with the\r\n * transfers and collates them with transfer metadata.\r\n *\r\n * VISIBLE FOR TESTING\r\n */ function getNftsForTransfers(config, response) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const metadataTransfers = response.transfers.filter((transfer)=>transfer.rawContract.address !== null)// Use flatMap to flatten 1155 transfers that contain multiple NFTs.\n        .flatMap((transfer)=>{\n            var _a;\n            const tokens = getTokensFromTransfer(transfer);\n            const metadata = {\n                from: transfer.from,\n                to: (_a = transfer.to) !== null && _a !== void 0 ? _a : undefined,\n                transactionHash: transfer.hash,\n                blockNumber: transfer.blockNum\n            };\n            return tokens.map((token)=>({\n                    metadata,\n                    token\n                }));\n        });\n        if (metadataTransfers.length === 0) {\n            return {\n                nfts: []\n            };\n        }\n        // If we have more than 100 elements after unrolling 1155 transfers, split\n        // transfers into batches of 100 to stay under endpoint batch size limit.\n        const batchSize = 100;\n        const requestBatches = [];\n        for(let i = 0; i < metadataTransfers.length; i += batchSize){\n            requestBatches.push(metadataTransfers.slice(i, i + batchSize));\n        }\n        const responseBatches = yield Promise.all(requestBatches.map((batch)=>getNftMetadataBatch(config, batch.map((transfer)=>transfer.token))));\n        const nfts = responseBatches.map((r)=>r.nfts).flat();\n        // The same NFT can be transferred multiple times in the same transfers response.\n        // We want to return one NFT for each transfer, so we create a mapping for\n        // each NFT to pair with the transfer metadata.\n        const nftsByTokenId = new Map();\n        nfts.forEach((nft)=>{\n            const key = `${nft.contract.address.toLowerCase()}-${bignumber.BigNumber.from(nft.tokenId).toString()}`;\n            nftsByTokenId.set(key, nft);\n        });\n        const transferredNfts = metadataTransfers.map((t)=>{\n            const key = `${t.token.contractAddress.toLowerCase()}-${bignumber.BigNumber.from(t.token.tokenId).toString()}`;\n            return Object.assign(Object.assign({}, nftsByTokenId.get(key)), t.metadata);\n        });\n        return {\n            nfts: transferredNfts,\n            pageKey: response.pageKey\n        };\n    });\n}\n/**\r\n * Returns the underlying NFT tokens from a transfer as the params for a\r\n * `getNftMetadataBatch` call. Handles the 1155 case where multiple NFTs can be\r\n * transferred in a single transaction.\r\n */ function getTokensFromTransfer(transfer) {\n    // ERC1155 NFTs can contain multiple tokens in a single transfer, which\n    // requires special logic.\n    if (transfer.category === exports.AssetTransfersCategory.ERC1155) {\n        return parse1155Transfer(transfer);\n    } else {\n        return [\n            {\n                contractAddress: transfer.rawContract.address,\n                tokenId: transfer.tokenId,\n                tokenType: transfer.category === exports.AssetTransfersCategory.ERC721 ? exports.NftTokenType.ERC721 : undefined\n            }\n        ];\n    }\n}\n/**\r\n * Flips the `omitMetadata` SDK parameter type to the `withMetadata` parameter\r\n * required by the Alchemy API. If `omitMetadata` is undefined, the SDK defaults\r\n * to including metadata.\r\n *\r\n * @internal\r\n */ function omitMetadataToWithMetadata(omitMetadata) {\n    return omitMetadata === undefined ? true : !omitMetadata;\n}\nfunction parseReingestionState(reingestionState) {\n    switch(reingestionState){\n        case \"does_not_exist\":\n            return exports.NftRefreshState.DOES_NOT_EXIST;\n        case \"already_queued\":\n            return exports.NftRefreshState.ALREADY_QUEUED;\n        case \"in_progress\":\n            return exports.NftRefreshState.IN_PROGRESS;\n        case \"finished\":\n            return exports.NftRefreshState.FINISHED;\n        case \"queued\":\n            return exports.NftRefreshState.QUEUED;\n        case \"queue_failed\":\n            return exports.NftRefreshState.QUEUE_FAILED;\n        default:\n            throw new Error(\"Unknown reingestion state: \" + reingestionState);\n    }\n}\n/**\r\n * The NFT namespace contains all the functionality related to NFTs.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.nft`.\r\n */ class NftNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    getNftMetadata(contractAddress, tokenId, optionsOrTokenType, tokenUriTimeoutInMs) {\n        let options;\n        if (typeof optionsOrTokenType === \"object\") {\n            options = {\n                tokenType: optionsOrTokenType.tokenType,\n                tokenUriTimeoutInMs: optionsOrTokenType.tokenUriTimeoutInMs,\n                refreshCache: optionsOrTokenType.refreshCache\n            };\n        } else {\n            options = {\n                tokenType: optionsOrTokenType,\n                tokenUriTimeoutInMs\n            };\n        }\n        return getNftMetadata(this.config, contractAddress, tokenId, options);\n    }\n    /**\r\n     * Gets the NFT metadata for multiple NFT tokens.\r\n     *\r\n     * @param tokens An array of NFT tokens to fetch metadata for.\r\n     * @param options Configuration options for making the request.\r\n     */ getNftMetadataBatch(tokens, options) {\n        return getNftMetadataBatch(this.config, tokens, options);\n    }\n    /**\r\n     * Get the NFT contract metadata associated with the provided parameters.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT.\r\n     * @public\r\n     */ getContractMetadata(contractAddress) {\n        return getContractMetadata(this.config, contractAddress);\n    }\n    /**\r\n     * Get the NFT contract metadata for multiple NFT contracts in a single request.\r\n     *\r\n     * @param contractAddresses - An array of contract addresses to fetch metadata for.\r\n     */ getContractMetadataBatch(contractAddresses) {\n        return getContractMetadataBatch(this.config, contractAddresses);\n    }\n    /**\r\n     * Get the NFT collection metadata associated with the provided parameters.\r\n     *\r\n     * @param collectionSlug - The OpenSea collection slug of the NFT.\r\n     * @beta\r\n     */ getCollectionMetadata(collectionSlug) {\n        return getCollectionMetadata(this.config, collectionSlug);\n    }\n    getNftsForOwnerIterator(owner, options) {\n        return getNftsForOwnerIterator(this.config, owner, options);\n    }\n    getNftsForOwner(owner, options) {\n        return getNftsForOwner(this.config, owner, options);\n    }\n    getNftsForContract(contractAddress, options) {\n        return getNftsForContract(this.config, contractAddress, options);\n    }\n    getNftsForContractIterator(contractAddress, options) {\n        return getNftsForContractIterator(this.config, contractAddress, options);\n    }\n    getOwnersForContract(contractAddress, options) {\n        return getOwnersForContract(this.config, contractAddress, options);\n    }\n    /**\r\n     * Gets all the owners for a given NFT contract address and token ID.\r\n     *\r\n     * @param contractAddress - The NFT contract address.\r\n     * @param tokenId - Token id of the NFT.\r\n     * @param options - Optional parameters to use for the request.\r\n     * @beta\r\n     */ getOwnersForNft(contractAddress, tokenId, options) {\n        return getOwnersForNft(this.config, contractAddress, tokenId, options);\n    }\n    /**\r\n     * Gets all NFT contracts held by the specified owner address.\r\n     *\r\n     * @param owner - Address for NFT owner (can be in ENS format!).\r\n     * @param options - The optional parameters to use for the request.\r\n     * @public\r\n     */ // TODO(v3): Add overload for withMetadata=false\n    getContractsForOwner(owner, options) {\n        return getContractsForOwner(this.config, owner, options);\n    }\n    /**\r\n     * Gets all NFT transfers for a given owner's address.\r\n     *\r\n     * @param owner The owner to get transfers for.\r\n     * @param category Whether to get transfers to or from the owner address.\r\n     * @param options Additional options for the request.\r\n     */ getTransfersForOwner(owner, category, options) {\n        return getTransfersForOwner(this.config, owner, category, options);\n    }\n    /**\r\n     * Gets all NFT transfers for a given NFT contract address.\r\n     *\r\n     * Defaults to all transfers for the contract. To get transfers for a specific\r\n     * block range, use {@link GetTransfersForContractOptions}.\r\n     *\r\n     * @param contract The NFT contract to get transfers for.\r\n     * @param options Additional options for the request.\r\n     */ getTransfersForContract(contract, options) {\n        return getTransfersForContract(this.config, contract, options);\n    }\n    /**\r\n     * Get all the NFTs minted by a specified owner address.\r\n     *\r\n     * @param owner - Address for the NFT owner (can be in ENS format).\r\n     * @param options - The optional parameters to use for the request.\r\n     */ getMintedNfts(owner, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getMintedNfts(this.config, owner, options);\n        });\n    }\n    verifyNftOwnership(owner, contractAddress) {\n        return verifyNftOwnership(this.config, owner, contractAddress);\n    }\n    /**\r\n     * Returns whether a contract is marked as spam or not by Alchemy. For more\r\n     * information on how we classify spam, go to our NFT API FAQ at\r\n     * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n     *\r\n     * @param contractAddress - The contract address to check.\r\n     */ isSpamContract(contractAddress) {\n        return isSpamContract(this.config, contractAddress);\n    }\n    /**\r\n     * Returns a list of all spam contracts marked by Alchemy. For details on how\r\n     * Alchemy marks spam contracts, go to\r\n     * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n     */ getSpamContracts() {\n        return getSpamContracts(this.config);\n    }\n    /**\r\n     * Returns whether a contract is marked as spam or not by Alchemy. For more\r\n     * information on how we classify spam, go to our NFT API FAQ at\r\n     * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n     *\r\n     * @param contractAddress - The contract address to check.\r\n     */ reportSpam(contractAddress) {\n        return reportSpam(this.config, contractAddress);\n    }\n    /**\r\n     * Returns whether a token is marked as an airdrop or not.\r\n     * Airdrops are defined as NFTs that were minted to a user address in a transaction\r\n     * sent by a different address.\r\n     *\r\n     * @param contractAddress - The contract address to check.\r\n     * @param tokenId - Token id of the NFT.\r\n     */ isAirdropNft(contractAddress, tokenId) {\n        return isAirdropNft(this.config, contractAddress, tokenId);\n    }\n    /**\r\n     * Returns the floor prices of a NFT contract by marketplace.\r\n     *\r\n     * @param contractAddress - The contract address for the NFT collection.\r\n     * @beta\r\n     */ getFloorPrice(contractAddress) {\n        return getFloorPrice(this.config, contractAddress);\n    }\n    getNftSales(options) {\n        return getNftSales(this.config, options);\n    }\n    /**\r\n     * Get the rarity of each attribute of an NFT.\r\n     *\r\n     * @param contractAddress - Contract address for the NFT collection.\r\n     * @param tokenId - Token id of the NFT.\r\n     */ computeRarity(contractAddress, tokenId) {\n        return computeRarity(this.config, contractAddress, tokenId);\n    }\n    /**\r\n     * Search for a keyword across metadata of all ERC-721 and ERC-1155 smart contracts.\r\n     *\r\n     * @param query - The search string that you want to search for in contract metadata.\r\n     */ searchContractMetadata(query) {\n        return searchContractMetadata(this.config, query);\n    }\n    /**\r\n     * Get a summary of attribute prevalence for an NFT collection.\r\n     *\r\n     * @param contractAddress - Contract address for the NFT collection.\r\n     */ summarizeNftAttributes(contractAddress) {\n        return summarizeNftAttributes(this.config, contractAddress);\n    }\n    /**\r\n     * Refreshes the cached metadata for a provided NFT contract address and token\r\n     * id. Returns a boolean value indicating whether the metadata was refreshed.\r\n     *\r\n     * This method is useful when you want to refresh the metadata for a NFT that\r\n     * has been updated since the last time it was fetched. Note that the backend\r\n     * only allows one refresh per token every 15 minutes, globally for all users.\r\n     * The last refresh time for an NFT can be accessed on the\r\n     * {@link Nft.timeLastUpdated} field.\r\n     *\r\n     * To trigger a refresh for all NFTs in a contract, use {@link refreshContract} instead.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT.\r\n     * @param tokenId - The token id of the NFT.\r\n     */ refreshNftMetadata(contractAddress, tokenId) {\n        return refreshNftMetadata(this.config, contractAddress, tokenId);\n    }\n    /**\r\n     * Triggers a metadata refresh all NFTs in the provided contract address. This\r\n     * method is useful after an NFT collection is revealed.\r\n     *\r\n     * Refreshes are queued on the Alchemy backend and may take time to fully\r\n     * process. To refresh the metadata for a specific token, use the\r\n     * {@link refreshNftMetadata} method instead.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT collection.\r\n     * @beta\r\n     */ refreshContract(contractAddress) {\n        return refreshContract(this.config, contractAddress);\n    }\n}\n/**\r\n * The Notify namespace contains methods used for creating, reading, updating,\r\n * and deleting webhooks in the Notify API.\r\n *\r\n * To use the methods in the API, you must provide your team's auth token in the\r\n * {@link AlchemySettings.authToken} field when configuring\r\n * {@link AlchemySettings}. The auth token can be found in the Alchemy Dashboard\r\n * on the Notify tab.\r\n *\r\n * Note that not all networks are supported in the Notify API. Please consult\r\n * the documentation for which networks are supported.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the notify\r\n * namespace via `alchemy.notify`.\r\n */ class NotifyNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Get all webhooks on your team.\r\n     *\r\n     * The team is determined by the `authToken` provided into the {@link AlchemySettings}\r\n     * object when creating a new {@link Alchemy} instance.\r\n     *\r\n     * This method returns a response object containing all the webhooks\r\n     */ getAllWebhooks() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const response = yield this.sendWebhookRequest(\"team-webhooks\", \"getAllWebhooks\", {});\n            return {\n                webhooks: parseRawWebhookResponse(response),\n                totalCount: response.data.length\n            };\n        });\n    }\n    getAddresses(webhookOrId, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"webhook-addresses\", \"getAddresses\", {\n                webhook_id: webhookId,\n                limit: options === null || options === void 0 ? void 0 : options.limit,\n                after: options === null || options === void 0 ? void 0 : options.pageKey\n            });\n            return parseRawAddressActivityResponse(response);\n        });\n    }\n    getGraphqlQuery(webhookOrId) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"dashboard-webhook-graphql-query\", \"getGraphqlQuery\", {\n                webhook_id: webhookId\n            });\n            return parseRawCustomGraphqlWebhookResponse(response);\n        });\n    }\n    getNftFilters(webhookOrId, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"webhook-nft-filters\", \"getNftFilters\", {\n                webhook_id: webhookId,\n                limit: options === null || options === void 0 ? void 0 : options.limit,\n                after: options === null || options === void 0 ? void 0 : options.pageKey\n            });\n            return parseRawNftFiltersResponse(response);\n        });\n    }\n    updateWebhook(webhookOrId, update) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            let restApiName;\n            let methodName;\n            let method;\n            let data;\n            if (\"isActive\" in update) {\n                restApiName = \"update-webhook\";\n                methodName = \"updateWebhook\";\n                method = \"PUT\";\n                data = {\n                    webhook_id: webhookId,\n                    is_active: update.isActive\n                };\n            } else if (\"addFilters\" in update || \"removeFilters\" in update) {\n                restApiName = \"update-webhook-nft-filters\";\n                methodName = \"updateWebhookNftFilters\";\n                method = \"PATCH\";\n                data = {\n                    webhook_id: webhookId,\n                    nft_filters_to_add: update.addFilters ? update.addFilters.map(nftFilterToParam) : [],\n                    nft_filters_to_remove: update.removeFilters ? update.removeFilters.map(nftFilterToParam) : []\n                };\n            } else if (\"addMetadataFilters\" in update || \"removeMetadataFilters\" in update) {\n                restApiName = \"update-webhook-nft-metadata-filters\";\n                methodName = \"updateWebhookNftMetadataFilters\";\n                method = \"PATCH\";\n                data = {\n                    webhook_id: webhookId,\n                    nft_metadata_filters_to_add: update.addMetadataFilters ? update.addMetadataFilters.map(nftFilterToParam) : [],\n                    nft_metadata_filters_to_remove: update.removeMetadataFilters ? update.removeMetadataFilters.map(nftFilterToParam) : []\n                };\n            } else if (\"addAddresses\" in update || \"removeAddresses\" in update) {\n                restApiName = \"update-webhook-addresses\";\n                methodName = \"webhook:updateWebhookAddresses\";\n                method = \"PATCH\";\n                data = {\n                    webhook_id: webhookId,\n                    addresses_to_add: yield this.resolveAddresses(update.addAddresses),\n                    addresses_to_remove: yield this.resolveAddresses(update.removeAddresses)\n                };\n            } else if (\"newAddresses\" in update) {\n                restApiName = \"update-webhook-addresses\";\n                methodName = \"webhook:updateWebhookAddress\";\n                method = \"PUT\";\n                data = {\n                    webhook_id: webhookId,\n                    addresses: yield this.resolveAddresses(update.newAddresses)\n                };\n            } else {\n                throw new Error(\"Invalid `update` param passed into `updateWebhook`\");\n            }\n            yield this.sendWebhookRequest(restApiName, methodName, {}, {\n                method,\n                data\n            });\n        });\n    }\n    createWebhook(url, type, params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            let appId;\n            if (type === exports.WebhookType.MINED_TRANSACTION || type === exports.WebhookType.DROPPED_TRANSACTION || type === exports.WebhookType.GRAPHQL) {\n                if (!(\"appId\" in params)) {\n                    throw new Error(\"Transaction and GraphQL Webhooks require an app id.\");\n                }\n                appId = params.appId;\n            }\n            let network = NETWORK_TO_WEBHOOK_NETWORK.get(this.config.network);\n            let nftFilterObj;\n            let addresses;\n            let graphqlQuery;\n            let skipEmptyMessages;\n            if (type === exports.WebhookType.NFT_ACTIVITY || type === exports.WebhookType.NFT_METADATA_UPDATE) {\n                if (!(\"filters\" in params) || params.filters.length === 0) {\n                    throw new Error(\"Nft Activity Webhooks require a non-empty array input.\");\n                }\n                network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n                const filters = params.filters.map((filter)=>filter.tokenId ? {\n                        contract_address: filter.contractAddress,\n                        token_id: bignumber.BigNumber.from(filter.tokenId).toString()\n                    } : {\n                        contract_address: filter.contractAddress\n                    });\n                nftFilterObj = type === exports.WebhookType.NFT_ACTIVITY ? {\n                    nft_filters: filters\n                } : {\n                    nft_metadata_filters: filters\n                };\n            } else if (type === exports.WebhookType.ADDRESS_ACTIVITY) {\n                if (params === undefined || !(\"addresses\" in params) || params.addresses.length === 0) {\n                    throw new Error(\"Address Activity Webhooks require a non-empty array input.\");\n                }\n                network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n                addresses = yield this.resolveAddresses(params.addresses);\n            } else if (type == exports.WebhookType.GRAPHQL) {\n                if (params === undefined || !(\"graphqlQuery\" in params) || params.graphqlQuery.length === 0) {\n                    throw new Error(\"Custom Webhooks require a non-empty graphql query.\");\n                }\n                network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n                graphqlQuery = params.graphqlQuery;\n                skipEmptyMessages = params.skipEmptyMessages;\n            }\n            const data = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n                network,\n                webhook_type: type,\n                webhook_url: url\n            }, appId && {\n                app_id: appId\n            }), params.name && {\n                name: params.name\n            }), nftFilterObj), addresses && {\n                addresses\n            }), graphqlQuery && {\n                graphql_query: {\n                    query: graphqlQuery,\n                    skip_empty_messages: !!skipEmptyMessages\n                }\n            });\n            const response = yield this.sendWebhookRequest(\"create-webhook\", \"createWebhook\", {}, {\n                method: \"POST\",\n                data\n            });\n            return parseRawWebhook(response.data);\n        });\n    }\n    deleteWebhook(webhookOrId) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"delete-webhook\", \"deleteWebhook\", {\n                webhook_id: webhookId\n            }, {\n                method: \"DELETE\"\n            });\n            if (\"message\" in response) {\n                throw new Error(`Webhook not found. Failed to delete webhook: ${webhookId}`);\n            }\n        });\n    }\n    verifyConfig() {\n        if (this.config.authToken === undefined) {\n            throw new Error(\"Using the Notify API requires setting the Alchemy Auth Token in \" + \"the settings object when initializing Alchemy.\");\n        }\n    }\n    sendWebhookRequest(restApiName, methodName, params, overrides) {\n        return requestHttpWithBackoff(this.config, AlchemyApiType.WEBHOOK, restApiName, methodName, params, Object.assign(Object.assign({}, overrides), {\n            headers: Object.assign({\n                \"X-Alchemy-Token\": this.config.authToken\n            }, overrides === null || overrides === void 0 ? void 0 : overrides.headers)\n        }));\n    }\n    /** Resolves ENS addresses to the raw address.\r\n     * @internal */ resolveAddresses(addresses) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (addresses === undefined) {\n                return [];\n            }\n            const resolvedAddresses = [];\n            const provider = yield this.config.getProvider();\n            for (const address of addresses){\n                const rawAddress = yield provider.resolveName(address);\n                if (rawAddress === null) {\n                    throw new Error(`Unable to resolve the ENS address: ${address}`);\n                }\n                resolvedAddresses.push(rawAddress);\n            }\n            return resolvedAddresses;\n        });\n    }\n}\n/**\r\n * Mapping of webhook network representations to the SDK's network representation.\r\n *\r\n * @internal\r\n */ const WEBHOOK_NETWORK_TO_NETWORK = Object.fromEntries(Object.entries(exports.Network));\n/** Mapping of the SDK's network representation the webhook API's network representation. */ const NETWORK_TO_WEBHOOK_NETWORK = Object.keys(exports.Network).reduce((map, key)=>{\n    if (key in WEBHOOK_NETWORK_TO_NETWORK) {\n        map.set(WEBHOOK_NETWORK_TO_NETWORK[key], key);\n    }\n    return map;\n}, new Map());\nfunction parseRawWebhookResponse(response) {\n    return response.data.map(parseRawWebhook);\n}\nfunction parseRawWebhook(rawWebhook) {\n    return Object.assign(Object.assign({\n        id: rawWebhook.id,\n        network: WEBHOOK_NETWORK_TO_NETWORK[rawWebhook.network],\n        type: rawWebhook.webhook_type,\n        url: rawWebhook.webhook_url,\n        isActive: rawWebhook.is_active,\n        timeCreated: new Date(rawWebhook.time_created).toISOString(),\n        signingKey: rawWebhook.signing_key,\n        version: rawWebhook.version\n    }, rawWebhook.app_id !== undefined && {\n        appId: rawWebhook.app_id\n    }), rawWebhook.name !== undefined && {\n        name: rawWebhook.name\n    });\n}\nfunction parseRawAddressActivityResponse(response) {\n    return {\n        addresses: response.data,\n        totalCount: response.pagination.total_count,\n        pageKey: response.pagination.cursors.after\n    };\n}\nfunction parseRawCustomGraphqlWebhookResponse(response) {\n    return {\n        graphqlQuery: response.data.graphql_query\n    };\n}\nfunction parseRawNftFiltersResponse(response) {\n    return {\n        filters: response.data.map((f)=>f.token_id ? {\n                contractAddress: f.contract_address,\n                tokenId: bignumber.BigNumber.from(f.token_id).toString()\n            } : {\n                contractAddress: f.contract_address\n            }),\n        totalCount: response.pagination.total_count,\n        pageKey: response.pagination.cursors.after\n    };\n}\nfunction nftFilterToParam(filter) {\n    return filter.tokenId ? {\n        contract_address: filter.contractAddress,\n        token_id: bignumber.BigNumber.from(filter.tokenId).toString()\n    } : {\n        contract_address: filter.contractAddress\n    };\n}\nfunction getTokensByWallet(config, addresses, withMetadata = true, withPrices = true, includeNativeTokens = true, srcMethod = \"getTokensByWallet\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const data = {\n            addresses,\n            withMetadata,\n            withPrices,\n            includeNativeTokens\n        };\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.PORTFOLIO, \"assets/tokens/by-address\", srcMethod, {}, {\n            data,\n            method: \"POST\"\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction getTokenBalancesByWallet(config, addresses, includeNativeTokens = true, srcMethod = \"getTokenBalancesByWallet\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const data = {\n            addresses,\n            includeNativeTokens\n        };\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.PORTFOLIO, \"assets/tokens/balances/by-address\", srcMethod, {}, {\n            method: \"POST\",\n            data\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction getNftsByWallet(config, addresses, withMetadata = true, pageKey = undefined, pageSize = undefined, srcMethod = \"getNftsByWallet\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const data = {\n            addresses,\n            withMetadata,\n            pageKey,\n            pageSize\n        };\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.PORTFOLIO, \"assets/nfts/by-address\", srcMethod, {}, {\n            method: \"POST\",\n            data\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction getNftCollectionsByWallet(config, addresses, withMetadata = true, pageKey = undefined, pageSize = undefined, srcMethod = \"getNftCollectionsByWallet\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const data = {\n            addresses,\n            pageKey,\n            pageSize,\n            withMetadata\n        };\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.PORTFOLIO, \"assets/nfts/contracts/by-address\", srcMethod, {}, {\n            method: \"POST\",\n            data\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction getTransactionsByWallet(config, addresses, before = undefined, after = undefined, limit = undefined, srcMethod = \"getTransactionsByWallet\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const data = {\n            addresses,\n            before,\n            after,\n            limit\n        };\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.PORTFOLIO, \"transactions/history/by-address\", srcMethod, {}, {\n            method: \"POST\",\n            data\n        });\n        return nullsToUndefined(response);\n    });\n}\n/**\r\n * The Portfolio namespace contains methods for getting data needed to build a portfolio.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the portfolio namespace\r\n * via `alchemy.portfolio`.\r\n */ class PortfolioNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Fetches fungible tokens (native and ERC-20) for multiple wallet addresses\r\n     * and networks.\r\n     *\r\n     * @param addresses - Array of network/address pairs\r\n     *                    (limit 2 pairs, max 5 networks each).\r\n     * @param withMetadata - Boolean. If set to true, returns metadata. Setting\r\n     *                                this to false will reduce payload size and\r\n     *                                may result in a faster API call.\r\n     *                                (default: true)\r\n     * @param withPrices - Boolean. If set to true, returns token prices. Setting\r\n     *                              this to false will reduce payload size and may\r\n     *                              result in a faster API call. (default: true)\r\n     * @param includeNativeTokens - Boolean. Whether to include each chains\r\n     *                                       native token in the response\r\n     *                                       (e.g. ETH on Ethereum). The native\r\n     *                                       token will have a null contract\r\n     *                                       address. (default: true)\r\n     *\r\n     * @returns Promise containing a list of tokens with balances, prices, and\r\n     *          metadata for each wallet/network combination.\r\n     *\r\n     * @public\r\n     */ getTokensByWallet(addresses, withMetadata = true, withPrices = true, includeNativeTokens = true) {\n        return getTokensByWallet(this.config, addresses, withMetadata, withPrices, includeNativeTokens);\n    }\n    /**\r\n     * Fetches fungible tokens (native and ERC-20) for multiple wallet addresses and networks.\r\n     *\r\n     * @param addresses - Array of network/address pairs (limit 2 pairs, max 5 networks each).\r\n     * @param includeNativeTokens - Boolean. Whether to include each chains native token in the response (e.g. ETH on Ethereum). The native token will have a null contract address. (default: true)   * @returns Promise containing a list of tokens with balances for each wallet/network combination\r\n     * @public\r\n     */ getTokenBalancesByWallet(addresses, includeNativeTokens = true) {\n        return getTokenBalancesByWallet(this.config, addresses, includeNativeTokens);\n    }\n    /**\r\n     * Fetches NFTs for multiple wallet addresses and networks.\r\n     *\r\n     * @param addresses - Array of network/address pairs to fetch NFTs for.\r\n     * @param withMetadata - Boolean. If set to true, returns metadata. Setting this to false will reduce payload size and may result in a faster API call. (default: true)\r\n     * @param pageKey - Optional. The cursor that points to the current set of results.\r\n     * @param pageSize - Optional. Sets the number of items per page.\r\n     * @returns Promise containing a list of NFTs and metadata for each wallet/network combination.\r\n     *\r\n     * @public\r\n     */ getNftsByWallet(addresses, withMetadata = true, pageKey, pageSize) {\n        return getNftsByWallet(this.config, addresses, withMetadata, pageKey, pageSize);\n    }\n    /**\r\n     * Fetches NFT collections (contracts) for multiple wallet addresses and networks. Returns a list of\r\n     * collections and metadata for each wallet/network combination.\r\n     *\r\n     * @param addresses - Array of address and networks pairs (limit 2 pairs, max 15 networks each).\r\n     * @param withMetadata - Boolean. If set to true, returns metadata. (default: true)\r\n     * @param pageKey - Optional. The cursor that points to the current set of results.\r\n     * @param pageSize - Optional. Sets the number of items per page.\r\n     * @returns Promise containing a list of NFT collections for each wallet/network combination.\r\n     * @public\r\n     */ getNftCollectionsByWallet(addresses, withMetadata = true, pageKey, pageSize) {\n        return getNftCollectionsByWallet(this.config, addresses, withMetadata, pageKey, pageSize);\n    }\n    /**\r\n     * Fetches all historical transactions (internal & external) for multiple wallet addresses and networks.\r\n     *\r\n     * @param addresses - Array of network/address pairs to fetch transactions for.\r\n     * @param before - Optional. The cursor that points to the previous set of results.\r\n     * @param after - Optional. The cursor that points to the end of the current set of results.\r\n     * @param limit - Optional. Sets the maximum number of items per page (Max: 100)\r\n     * @returns Promise containing a list of transaction objects with metadata and log information.\r\n     *\r\n     * @public\r\n     */ getTransactionsByWallet(addresses, before, after, limit) {\n        return getTransactionsByWallet(this.config, addresses, before, after, limit);\n    }\n}\nfunction getTokenPriceByAddress(config, addresses, srcMethod = \"getTokenPriceByAddress\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.PRICES, \"tokens/by-address\", srcMethod, {}, {\n            method: \"POST\",\n            data: {\n                addresses\n            }\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction getTokenPriceBySymbol(config, symbols, srcMethod = \"getTokenPriceBySymbol\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.PRICES, \"tokens/by-symbol\", srcMethod, {\n            symbols\n        }, {\n            // We need to serialize the symbols array as URLSearchParams since the\n            // Alchemy API expects a query parameter for each symbol. The axios default\n            // serializer will not work here because the symbols array is an array of\n            // strings.\n            // Axios default encoding: ?symbols[]=AAVE&symbols[]=UNI\n            // Alchemy requires: ?symbols=AAVE&symbols=UNI\n            paramsSerializer: (params)=>{\n                const searchParams = new URLSearchParams();\n                Object.entries(params).forEach(([key, value])=>{\n                    value.forEach((v)=>searchParams.append(key, v));\n                });\n                return searchParams.toString();\n            }\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction getHistoricalPriceBySymbol(config, symbol, startTime, endTime, interval, srcMethod = \"getHistoricalPriceBySymbol\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.PRICES, \"tokens/historical\", srcMethod, {}, {\n            method: \"POST\",\n            data: {\n                symbol,\n                startTime,\n                endTime,\n                interval\n            }\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction getHistoricalPriceByAddress(config, network, address, startTime, endTime, interval, srcMethod = \"getHistoricalPriceByAddress\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.PRICES, \"tokens/historical\", srcMethod, {}, {\n            method: \"POST\",\n            data: {\n                network,\n                address,\n                startTime,\n                endTime,\n                interval\n            }\n        });\n        return nullsToUndefined(response);\n    });\n}\n/**\r\n * The Prices namespace contains methods for getting token price data.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the prices namespace\r\n * via `alchemy.prices`.\r\n */ class PricesNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Get token prices by network and contract address pairs.\r\n     *\r\n     * @param addresses - Array of network/address pairs to get prices for\r\n     * @returns Promise containing token price data\r\n     * @public\r\n     */ getTokenPriceByAddress(addresses) {\n        return getTokenPriceByAddress(this.config, addresses);\n    }\n    /**\r\n     * Get token prices by token symbol.\r\n     *\r\n     * @param symbols - Array of token symbols to get prices for\r\n     * @returns Promise containing token price data\r\n     * @public\r\n     */ getTokenPriceBySymbol(symbols) {\n        return getTokenPriceBySymbol(this.config, symbols);\n    }\n    /**\r\n     * Get historical token prices by token symbol.\r\n     *\r\n     * @param symbol - The token symbol to get historical prices for\r\n     * @param startTime - Start time in ISO-8601 string format or Unix timestamp in seconds\r\n     * @param endTime - End time in ISO-8601 string format or Unix timestamp in seconds\r\n     * @param interval - Time interval between data points\r\n     * @returns Promise containing historical token price data\r\n     * @public\r\n     */ getHistoricalPriceBySymbol(symbol, startTime, endTime, interval) {\n        return getHistoricalPriceBySymbol(this.config, symbol, startTime, endTime, interval);\n    }\n    /**\r\n     * Get historical token prices by network and contract address.\r\n     *\r\n     * @param network - The network where the token contract is deployed\r\n     * @param address - The token contract address\r\n     * @param startTime - Start time in ISO-8601 string format or Unix timestamp in seconds\r\n     * @param endTime - End time in ISO-8601 string format or Unix timestamp in seconds\r\n     * @param interval - Time interval between data points\r\n     * @returns Promise containing historical token price data\r\n     * @public\r\n     */ getHistoricalPriceByAddress(network, address, startTime, endTime, interval) {\n        return getHistoricalPriceByAddress(this.config, network, address, startTime, endTime, interval);\n    }\n}\n/**\r\n * Multiples to increment fee per gas when using\r\n * {@link TransactNamespace.sendGasOptimizedTransaction}.\r\n *\r\n * @internal\r\n */ const GAS_OPTIMIZED_TX_FEE_MULTIPLES = [\n    0.9,\n    1,\n    1.1,\n    1.2,\n    1.3\n];\n/**\r\n * The Transact namespace contains methods used for sending transactions and\r\n * checking on the state of submitted transactions.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the transact\r\n * namespace via `alchemy.transact`.\r\n */ class TransactNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Used to send a single transaction to Flashbots. Flashbots will attempt to\r\n     * send the transaction to miners for the next 25 blocks.\r\n     *\r\n     * Returns the transaction hash of the submitted transaction.\r\n     *\r\n     * @param signedTransaction The raw, signed transaction as a hash.\r\n     * @param maxBlockNumber Optional highest block number in which the\r\n     *   transaction should be included.\r\n     * @param options Options to configure the request.\r\n     */ sendPrivateTransaction(signedTransaction, maxBlockNumber, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const hexBlockNumber = maxBlockNumber ? toHex(maxBlockNumber) : undefined;\n            return provider._send(\"eth_sendPrivateTransaction\", [\n                {\n                    tx: signedTransaction,\n                    maxBlockNumber: hexBlockNumber,\n                    preferences: options\n                }\n            ], \"sendPrivateTransaction\");\n        });\n    }\n    /**\r\n     * Stops the provided private transaction from being submitted for future\r\n     * blocks. A transaction can only be cancelled if the request is signed by the\r\n     * same key as the {@link sendPrivateTransaction} call submitting the\r\n     * transaction in first place.\r\n     *\r\n     * Please note that fast mode transactions cannot be cancelled using this method.\r\n     *\r\n     * Returns a boolean indicating whether the cancellation was successful.\r\n     *\r\n     * @param transactionHash Transaction hash of private tx to be cancelled\r\n     */ cancelPrivateTransaction(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"eth_cancelPrivateTransaction\", [\n                {\n                    txHash: transactionHash\n                }\n            ], \"cancelPrivateTransaction\");\n        });\n    }\n    /**\r\n     * Simulates the asset changes resulting from a list of transactions simulated\r\n     * in sequence.\r\n     *\r\n     * Returns a list of asset changes for each transaction during simulation.\r\n     *\r\n     * @param transactions Transactions list of max 3 transactions to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateAssetChangesBundle(transactions, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transactions,\n                blockIdentifier\n            ] : [\n                transactions\n            ];\n            const res = yield provider._send(\"alchemy_simulateAssetChangesBundle\", params, \"simulateAssetChangesBundle\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Simulates the asset changes resulting from a single transaction.\r\n     *\r\n     * Returns list of asset changes that occurred during the transaction\r\n     * simulation. Note that this method does not run the transaction on the\r\n     * blockchain.\r\n     *\r\n     * @param transaction The transaction to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateAssetChanges(transaction, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transaction,\n                blockIdentifier\n            ] : [\n                transaction\n            ];\n            const res = yield provider._send(\"alchemy_simulateAssetChanges\", params, \"simulateAssetChanges\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Simulates a list of transactions in sequence and returns list of decoded\r\n     * traces and logs that occurred for each transaction during simulation.\r\n     *\r\n     * Note that this method does not run any transactions on the blockchain.\r\n     *\r\n     * @param transactions Transactions list of max 3 transactions to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateExecutionBundle(transactions, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transactions,\n                blockIdentifier\n            ] : [\n                transactions\n            ];\n            const res = provider._send(\"alchemy_simulateExecutionBundle\", params, \"simulateExecutionBundle\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Simulates a single transaction and the resulting and returns list of\r\n     * decoded traces and logs that occurred during the transaction simulation.\r\n     *\r\n     * Note that this method does not run the transaction on the blockchain.\r\n     *\r\n     * @param transaction The transaction to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateExecution(transaction, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transaction,\n                blockIdentifier\n            ] : [\n                transaction\n            ];\n            const res = provider._send(\"alchemy_simulateExecution\", params, \"simulateExecution\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Returns the transaction with hash or null if the transaction is unknown.\r\n     *\r\n     * If a transaction has not been mined, this method will search the\r\n     * transaction pool. Various backends may have more restrictive transaction\r\n     * pool access (e.g. if the gas price is too low or the transaction was only\r\n     * recently sent and not yet indexed) in which case this method may also return null.\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */ getTransaction(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransaction(transactionHash);\n        });\n    }\n    /**\r\n     * Submits transaction to the network to be mined. The transaction must be\r\n     * signed, and be valid (i.e. the nonce is correct and the account has\r\n     * sufficient balance to pay for the transaction).\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.sendTransaction}.\r\n     *\r\n     * @param signedTransaction The signed transaction to send.\r\n     * @public\r\n     */ sendTransaction(signedTransaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.sendTransaction(signedTransaction);\n        });\n    }\n    /**\r\n     * Returns an estimate of the amount of gas that would be required to submit\r\n     * transaction to the network.\r\n     *\r\n     * An estimate may not be accurate since there could be another transaction on\r\n     * the network that was not accounted for, but after being mined affects the\r\n     * relevant state.\r\n     *\r\n     * This is an alias for {@link CoreNamespace.estimateGas}.\r\n     *\r\n     * @param transaction The transaction to estimate gas for.\r\n     * @public\r\n     */ estimateGas(transaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.estimateGas(transaction);\n        });\n    }\n    /**\r\n     * Returns a fee per gas (in wei) that is an estimate of how much you can pay\r\n     * as a priority fee, or \"tip\", to get a transaction included in the current block.\r\n     *\r\n     * This number is generally used to set the `maxPriorityFeePerGas` field in a\r\n     * transaction request.\r\n     *\r\n     * @public\r\n     */ getMaxPriorityFeePerGas() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const feeHex = yield provider._send(\"eth_maxPriorityFeePerGas\", [], \"getMaxPriorityFeePerGas\");\n            return fromHex(feeHex);\n        });\n    }\n    /**\r\n     * Returns a promise which will not resolve until specified transaction hash is mined.\r\n     *\r\n     * If {@link confirmations} is 0, this method is non-blocking and if the\r\n     * transaction has not been mined returns null. Otherwise, this method will\r\n     * block until the transaction has confirmed blocks mined on top of the block\r\n     * in which it was mined.\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.waitForTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to wait for.\r\n     * @param confirmations The number of blocks to wait for.\r\n     * @param timeout The maximum time to wait for the transaction to confirm.\r\n     * @public\r\n     */ waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.waitForTransaction(transactionHash, confirmations, timeout);\n        });\n    }\n    sendGasOptimizedTransaction(transactionOrSignedTxs, wallet) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (Array.isArray(transactionOrSignedTxs)) {\n                return this._sendGasOptimizedTransaction(transactionOrSignedTxs, \"sendGasOptimizedTransactionPreSigned\");\n            }\n            let gasLimit;\n            let priorityFee;\n            let baseFee;\n            const provider = yield this.config.getProvider();\n            try {\n                gasLimit = yield this.estimateGas(transactionOrSignedTxs);\n                priorityFee = yield this.getMaxPriorityFeePerGas();\n                const currentBlock = yield provider.getBlock(\"latest\");\n                baseFee = currentBlock.baseFeePerGas.toNumber();\n            } catch (e) {\n                throw new Error(`Failed to estimate gas for transaction: ${e}`);\n            }\n            const gasSpreadTransactions = generateGasSpreadTransactions(transactionOrSignedTxs, gasLimit.toNumber(), baseFee, priorityFee);\n            const signedTransactions = yield Promise.all(gasSpreadTransactions.map((tx)=>wallet.signTransaction(tx)));\n            return this._sendGasOptimizedTransaction(signedTransactions, \"sendGasOptimizedTransactionGenerated\");\n        });\n    }\n    /**\r\n     * Returns the state of the transaction job returned by the\r\n     * {@link sendGasOptimizedTransaction}.\r\n     *\r\n     * @param trackingId The tracking id from the response of the sent gas optimized transaction.\r\n     * @internal\r\n     */ // TODO(txjob): Remove internal tag once this feature is released.\n    getGasOptimizedTransactionStatus(trackingId) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"alchemy_getGasOptimizedTransactionStatus\", [\n                trackingId\n            ], \"getGasOptimizedTransactionStatus\");\n        });\n    }\n    /** @internal */ _sendGasOptimizedTransaction(signedTransactions, methodName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"alchemy_sendGasOptimizedTransaction\", [\n                {\n                    rawTransactions: signedTransactions\n                }\n            ], methodName);\n        });\n    }\n}\n/**\r\n * Helper method to generate the raw transaction with the given gas limit and\r\n * priority fee across a spread of different gas prices.\r\n *\r\n * @internal\r\n */ // Visible for testing\nfunction generateGasSpreadTransactions(transaction, gasLimit, baseFee, priorityFee) {\n    return GAS_OPTIMIZED_TX_FEE_MULTIPLES.map((feeMultiplier)=>{\n        return Object.assign(Object.assign({}, transaction), {\n            gasLimit,\n            maxFeePerGas: Math.round(baseFee * feeMultiplier + priorityFee * feeMultiplier),\n            maxPriorityFeePerGas: Math.round(feeMultiplier * priorityFee)\n        });\n    });\n}\n/** This file contains internal types used by the SDK and are not exposed to the end user. */ /**\r\n * Prefix for `alchemy_pendingTransactions` subscriptions when serializing to\r\n * ethers events.\r\n *\r\n * This tag is used internally by ethers to track different event filters.\r\n */ const ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE = \"alchemy-pending-transactions\";\n/**\r\n * Prefix for `alchemy_minedTransactions` subscriptions when serializing to ethers events.\r\n *\r\n * This tag is used internally by ethers to track different event filters.\r\n */ const ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE = \"alchemy-mined-transactions\";\n/**\r\n * Array containing all the custom event tags used internally by ethers to track\r\n * event filters.\r\n */ const ALCHEMY_EVENT_TYPES = [\n    ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n    ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE\n];\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Event class copied directly over from ethers.js's `BaseProvider` class.\r\n *\r\n * This class is used to represent events and their corresponding listeners. The\r\n * SDK needs to extend this class in order to support Alchemy's custom\r\n * Subscription API types. The original class is not exported by ethers. Minimal\r\n * changes have been made in order to get TS to compile.\r\n */ class Event {\n    constructor(tag, listener, once){\n        this.listener = listener;\n        this.tag = tag;\n        this.once = once;\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch(this.type){\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n            default:\n                return this.tag;\n        }\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            throw new Error(\"Not a transaction event\");\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            throw new Error(\"Not a transaction event\");\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        const PollableEvents = [\n            \"block\",\n            \"network\",\n            \"pending\",\n            \"poll\"\n        ];\n        return this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n    }\n}\n/**\r\n * Wrapper class around the ethers `Event` class in order to add support for\r\n * Alchemy's custom subscriptions types.\r\n *\r\n * The serialization and deserialization mechanism requires the order of the\r\n * fields to be the same across different {@link ALCHEMY_EVENT_TYPES}. Before\r\n * using a getter on a new event filter, make sure that the position of the\r\n * field in serialization is correct.\r\n *\r\n * The getters on this class deserialize the event tag generated by\r\n * {@link getAlchemyEventTag} into the original fields passed into the event.\r\n */ class EthersEvent extends Event {\n    /**\r\n     * Converts the event tag into the original `fromAddress` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter}.\r\n     */ get fromAddress() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[1] && comps[1] !== \"*\") {\n            return deserializeAddressField(comps[1]);\n        } else {\n            return undefined;\n        }\n    }\n    /**\r\n     * Converts the event tag into the original `toAddress` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter}.\r\n     */ get toAddress() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[2] && comps[2] !== \"*\") {\n            return deserializeAddressField(comps[2]);\n        } else {\n            return undefined;\n        }\n    }\n    /**\r\n     * Converts the event tag into the original `hashesOnly` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter} and {@link AlchemyMinedTransactionsEventFilter}.\r\n     */ get hashesOnly() {\n        const comps = this.tag.split(\":\");\n        if (!ALCHEMY_EVENT_TYPES.includes(comps[0])) {\n            return undefined;\n        }\n        if (comps[3] && comps[3] !== \"*\") {\n            return comps[3] === \"true\";\n        } else {\n            return undefined;\n        }\n    }\n    get includeRemoved() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[2] && comps[2] !== \"*\") {\n            return comps[2] === \"true\";\n        } else {\n            return undefined;\n        }\n    }\n    get addresses() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[1] && comps[1] !== \"*\") {\n            return deserializeAddressesField(comps[1]);\n        } else {\n            return undefined;\n        }\n    }\n}\nfunction isAlchemyEvent(event) {\n    return typeof event === \"object\" && \"method\" in event;\n}\n/**\r\n * Creates a string representation of an `alchemy_pendingTransaction`\r\n * subscription filter that is compatible with the ethers implementation of\r\n * `getEventTag()`. The method is not an exported function in ethers, which is\r\n * why the SDK has its own implementation.\r\n *\r\n * The event tag is then deserialized by the SDK's {@link EthersEvent} getters.\r\n *\r\n * @example\r\n *   ```js\r\n *   // Returns 'alchemy-pending-transactions:0xABC:0xDEF|0xGHI:true'\r\n *   const eventTag =  getAlchemyEventTag(\r\n *   {\r\n *     \"method\": \"alchemy_pendingTransactions\",\r\n *     \"fromAddress\": \"0xABC\",\r\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\r\n *     \"hashesOnly: true\r\n *   });\r\n *   ```;\r\n *\r\n * @param event\r\n * @internal\r\n */ function getAlchemyEventTag(event) {\n    if (!isAlchemyEvent(event)) {\n        throw new Error(\"Event tag requires AlchemyEventType\");\n    }\n    if (event.method === exports.AlchemySubscription.PENDING_TRANSACTIONS) {\n        return serializePendingTransactionsEvent(event);\n    } else if (event.method === exports.AlchemySubscription.MINED_TRANSACTIONS) {\n        return serializeMinedTransactionsEvent(event);\n    } else {\n        throw new Error(`Unrecognized AlchemyFilterEvent: ${event}`);\n    }\n}\nfunction verifyAlchemyEventName(eventName) {\n    if (!Object.values(exports.AlchemySubscription).includes(eventName.method)) {\n        throw new Error(`Invalid method name ${eventName.method}. Accepted method names: ${Object.values(exports.AlchemySubscription)}`);\n    }\n}\n/**\r\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\r\n * compatible event tag.\r\n *\r\n * For the example event:\r\n * ```\r\n *  {\r\n *     \"method\": \"alchemy_pendingTransactions\",\r\n *     \"fromAddress\": \"0xABC\",\r\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\r\n *     \"hashesOnly: true\r\n *   }\r\n * ```\r\n *\r\n * The resulting serialization is:\r\n * `alchemy_pendingTransactions:0xABC:0xDEF|0xGHI:true`\r\n *\r\n * If a field is omitted, it is replaced with a `*`.\r\n */ function serializePendingTransactionsEvent(event) {\n    const fromAddress = serializeAddressField(event.fromAddress);\n    const toAddress = serializeAddressField(event.toAddress);\n    const hashesOnly = serializeBooleanField(event.hashesOnly);\n    return ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE + \":\" + fromAddress + \":\" + toAddress + \":\" + hashesOnly;\n}\n/**\r\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\r\n * compatible event tag.\r\n *\r\n * For the example event:\r\n * ```\r\n *  {\r\n *     \"method\": \"alchemy_minedTransactions\",\r\n *     \"addresses\": [\r\n *       {\r\n *         from: \"0xABC\"\r\n *       },\r\n *       {\r\n *         to: \"0xDEF\",\r\n *         from: \"0x123\"\r\n *       }\r\n *     ]\r\n *     \"includeRemoved\": false\r\n *     \"hashesOnly: true\r\n *   }\r\n * ```\r\n *\r\n * The resulting serialization is:\r\n * `alchemy_minedTransactions:*,0xABC|0xDEF,0x123:false:true`\r\n *\r\n * If a field is omitted, it is replaced with a `*`.\r\n *\r\n * The `addresses` array is split by the '|' character, and each to/from address\r\n * pair is separated by a ',' character.\r\n *\r\n */ function serializeMinedTransactionsEvent(event) {\n    const addresses = serializeAddressesField(event.addresses);\n    const includeRemoved = serializeBooleanField(event.includeRemoved);\n    const hashesOnly = serializeBooleanField(event.hashesOnly);\n    return ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE + \":\" + addresses + \":\" + includeRemoved + \":\" + hashesOnly;\n}\nfunction serializeAddressesField(addresses) {\n    if (addresses === undefined) {\n        return \"*\";\n    }\n    return addresses.map((filter)=>serializeAddressField(filter.to) + \",\" + serializeAddressField(filter.from)).join(\"|\");\n}\nfunction serializeAddressField(field) {\n    if (field === undefined) {\n        return \"*\";\n    } else if (Array.isArray(field)) {\n        return field.join(\"|\");\n    } else {\n        return field;\n    }\n}\nfunction serializeBooleanField(field) {\n    if (field === undefined) {\n        return \"*\";\n    } else {\n        return field.toString();\n    }\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic)=>{\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic)=>{\n            return topic === \"null\" ? null : topic;\n        });\n        return comps.length === 1 ? comps[0] : comps;\n    });\n}\nfunction deserializeAddressField(data) {\n    if (data === \"\") {\n        return undefined;\n    }\n    const addresses = data.split(\"|\");\n    return addresses.length === 1 ? addresses[0] : addresses;\n}\nfunction deserializeAddressesField(data) {\n    if (data === \"\") {\n        return undefined;\n    }\n    // Perform a cast here since TS doesn't know we're guaranteed a non-empty\n    // array from deserializing.\n    return data.split(\"|\").map((addressStr)=>addressStr.split(\",\")).map((addressPair)=>Object.assign(Object.assign({}, addressPair[0] !== \"*\" && {\n            to: addressPair[0]\n        }), addressPair[1] !== \"*\" && {\n            from: addressPair[1]\n        }));\n}\n/**\r\n * The Websocket namespace contains all subscription related functions that\r\n * allow you to subscribe to events and receive updates as they occur. The\r\n * underlying WebSocket provider has additional logic to handle reconnections\r\n * and automatically backfills missed events.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.ws`.\r\n */ class WebSocketNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Adds a listener to be triggered for each {@link eventName} event. Also\r\n     * includes Alchemy's Subscription API events. See {@link AlchemyEventType} for\r\n     * how to use them.\r\n     *\r\n     * @param eventName The event to listen for.\r\n     * @param listener The listener to call when the event is triggered.\r\n     * @public\r\n     */ on(eventName, listener) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);\n                provider.on(processedEvent, listener);\n            }))();\n        return this;\n    }\n    /**\r\n     * Adds a listener to be triggered for only the next {@link eventName} event,\r\n     * after which it will be removed. Also includes Alchemy's Subscription API\r\n     * events. See {@link AlchemyEventType} for how to use them.\r\n     *\r\n     * @param eventName The event to listen for.\r\n     * @param listener The listener to call when the event is triggered.\r\n     * @public\r\n     */ once(eventName, listener) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);\n                provider.once(processedEvent, listener);\n            }))();\n        return this;\n    }\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName The event to unlisten to.\r\n     * @param listener The listener to remove.\r\n     * @public\r\n     */ off(eventName, listener) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);\n                return provider.off(processedEvent, listener);\n            }))();\n        return this;\n    }\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @public\r\n     */ removeAllListeners(eventName) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : undefined;\n                provider.removeAllListeners(processedEvent);\n            }))();\n        return this;\n    }\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     */ listenerCount(eventName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getWebSocketProvider();\n            const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : undefined;\n            return provider.listenerCount(processedEvent);\n        });\n    }\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     */ listeners(eventName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getWebSocketProvider();\n            const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : undefined;\n            return provider.listeners(processedEvent);\n        });\n    }\n    /**\r\n     * Converts ENS addresses in an Alchemy Event to the underlying resolved\r\n     * address.\r\n     *\r\n     * VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */ _resolveEnsAlchemyEvent(eventName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (!isAlchemyEvent(eventName)) {\n                return eventName;\n            }\n            if (eventName.method === exports.AlchemySubscription.MINED_TRANSACTIONS && eventName.addresses) {\n                const processedAddresses = [];\n                for (const address of eventName.addresses){\n                    if (address.to) {\n                        address.to = yield this._resolveNameOrError(address.to);\n                    }\n                    if (address.from) {\n                        address.from = yield this._resolveNameOrError(address.from);\n                    }\n                    processedAddresses.push(address);\n                }\n                eventName.addresses = processedAddresses;\n            } else if (eventName.method === exports.AlchemySubscription.PENDING_TRANSACTIONS) {\n                if (eventName.fromAddress) {\n                    if (typeof eventName.fromAddress === \"string\") {\n                        eventName.fromAddress = yield this._resolveNameOrError(eventName.fromAddress);\n                    } else {\n                        eventName.fromAddress = yield Promise.all(eventName.fromAddress.map((address)=>this._resolveNameOrError(address)));\n                    }\n                }\n                if (eventName.toAddress) {\n                    if (typeof eventName.toAddress === \"string\") {\n                        eventName.toAddress = yield this._resolveNameOrError(eventName.toAddress);\n                    } else {\n                        eventName.toAddress = yield Promise.all(eventName.toAddress.map((address)=>this._resolveNameOrError(address)));\n                    }\n                }\n            }\n            return eventName;\n        });\n    }\n    /**\r\n     * Converts the provided ENS address or throws an error. This improves code\r\n     * readability and type safety in other methods.\r\n     *\r\n     * VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */ _resolveNameOrError(name) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const resolved = yield provider.resolveName(name);\n            if (resolved === null) {\n                throw new Error(`Unable to resolve the ENS address: ${name}`);\n            }\n            return resolved;\n        });\n    }\n}\n/**\r\n * The Alchemy SDK client. This class is the main entry point into Alchemy's\r\n * APIs and separates functionality into different namespaces.\r\n *\r\n * Each SDK instance is associated with a specific network and API key. To use a\r\n * different network or API key, create a new instance of {@link Alchemy}.\r\n *\r\n * @public\r\n */ class Alchemy {\n    /**\r\n     * @param {string} [settings.apiKey] - The API key to use for Alchemy\r\n     * @param {Network} [settings.network] - The network to use for Alchemy\r\n     * @param {number} [settings.maxRetries] - The maximum number of retries to attempt\r\n     * @param {number} [settings.requestTimeout] - The timeout after which request should fail\r\n     * @public\r\n     */ constructor(settings){\n        this.config = new AlchemyConfig(settings);\n        this.core = new CoreNamespace(this.config);\n        this.nft = new NftNamespace(this.config);\n        this.ws = new WebSocketNamespace(this.config);\n        this.transact = new TransactNamespace(this.config);\n        this.notify = new NotifyNamespace(this.config);\n        this.debug = new DebugNamespace(this.config);\n        this.prices = new PricesNamespace(this.config);\n        this.portfolio = new PortfolioNamespace(this.config);\n    }\n}\n/**\r\n * The Wallet class inherits Signer and can sign transactions and messages using\r\n * a private key as a standard Externally Owned Account (EOA).\r\n *\r\n * SDK's custom implementation of Ethers.js's 'Wallet'.\r\n *\r\n * Primary difference from Ethers.js 'Wallet' is that you can pass in either a\r\n * Provider or an Alchemy object. This implementation will intelligently detect\r\n * the format and set the provider accordingly.\r\n *\r\n * @public\r\n * @override\r\n */ class Wallet extends wallet.Wallet {\n    /**\r\n     * Overload permits users to pass in either a standard Provider or an Alchemy\r\n     * object. The constructor will detect the object type and handle appropriately.\r\n     *\r\n     * @override\r\n     */ constructor(privateKey, alchemyOrProvider){\n        // If object passed in is a provider, send to super\n        let superProvider;\n        if (alchemyOrProvider && abstractProvider.Provider.isProvider(alchemyOrProvider)) {\n            superProvider = alchemyOrProvider;\n        }\n        super(privateKey, superProvider);\n        // If object passed in is an Alchemy object, just set Alchemy\n        if (alchemyOrProvider && !abstractProvider.Provider.isProvider(alchemyOrProvider)) {\n            this.alchemyProviderPromise = alchemyOrProvider.config.getProvider();\n        }\n    }\n    //////////////////////////////////////////////////////////////////\n    // Set of overrides from Signer to handle async provider retrieval.\n    //////////////////////////////////////////////////////////////////\n    /**\r\n     * Returns the balance of this wallet at blockTag.\r\n     *\r\n     * @param blockTag The block to check the balance of\r\n     * @override\r\n     */ getBalance(blockTag) {\n        return this.getWallet().then((wallet)=>wallet.getBalance(blockTag));\n    }\n    /**\r\n     * Returns the number of transactions this account has ever sent. This is the\r\n     * value required to be included in transactions as the nonce.\r\n     *\r\n     * @param blockTag The block to check the transaction count on\r\n     * @override\r\n     */ getTransactionCount(blockTag) {\n        return this.getWallet().then((wallet)=>wallet.getTransactionCount(blockTag));\n    }\n    /**\r\n     * Returns the result of estimating the cost to send the transactionRequest,\r\n     * with this account address being used as the from field.\r\n     *\r\n     * @param transaction Transaction to estimate the gas on\r\n     * @override\r\n     */ estimateGas(transaction) {\n        return this.getWallet().then((wallet)=>wallet.estimateGas(transaction));\n    }\n    /**\r\n     * Returns the result of calling using the transactionRequest, with this\r\n     * account address being used as the from field.\r\n     *\r\n     * @param transaction To make a call on\r\n     * @param blockTag The block to make the call on\r\n     * @override\r\n     */ call(transaction, blockTag) {\n        return this.getWallet().then((wallet)=>wallet.call(transaction, blockTag));\n    }\n    /**\r\n     * Populates ALL keys for a transaction and checks that `from` matches this\r\n     * `Signer`. Resolves ENS names and populates fields like `gasPrice`, `gasLimit`,\r\n     * `nonce`, and `chainId` if they are not provided.\r\n     *\r\n     * @param transaction The transaction to populate.\r\n     * @override\r\n     */ populateTransaction(transaction) {\n        return this.getWallet().then((wallet)=>wallet.populateTransaction(transaction));\n    }\n    /**\r\n     * Populates all fields in a transaction, signs it and sends it to the network\r\n     *\r\n     * @param transaction The transaction to send.\r\n     * @override\r\n     */ sendTransaction(transaction) {\n        return this.getWallet().then((wallet)=>wallet.sendTransaction(transaction));\n    }\n    /**\r\n     * Returns the chain ID this wallet is connected to.\r\n     *\r\n     * @override\r\n     */ getChainId() {\n        return this.getWallet().then((wallet)=>wallet.getChainId());\n    }\n    /**\r\n     * Returns the current gas price.\r\n     *\r\n     * @override\r\n     */ getGasPrice() {\n        return this.getWallet().then((wallet)=>wallet.getGasPrice());\n    }\n    /**\r\n     * Returns the current recommended FeeData to use in a transaction.\r\n     *\r\n     * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas\r\n     * should be used.\r\n     *\r\n     * For legacy transactions and networks which do not support EIP-1559, the\r\n     * gasPrice should be used.\r\n     *\r\n     * @override\r\n     */ getFeeData() {\n        return this.getWallet().then((wallet)=>wallet.getFeeData());\n    }\n    /**\r\n     * Looks up the address of name. If the name is not owned, or does not have a\r\n     * Resolver configured, or the Resolver does not have an address configured,\r\n     * null is returned.\r\n     *\r\n     * @param name Name of the ENS address\r\n     * @override\r\n     */ resolveName(name) {\n        return this.getWallet().then((wallet)=>wallet.resolveName(name));\n    }\n    getWallet() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (!this.alchemyProviderPromise) {\n                return this.connect(this.provider);\n            }\n            return this.connect((yield this.alchemyProviderPromise));\n        });\n    }\n}\n/**\r\n * The Contract class is a wrapper around the Contract class from ethers.js and\r\n * is exported here for convenience.\r\n *\r\n * @public\r\n */ // TODO: support passing in Alchemy instance into the contract.\nclass Contract extends contracts.Contract {\n}\n/**\r\n * The ContractFactory class is a wrapper around the ContractFactory class from\r\n * ethers.js and is exported here for convenience.\r\n *\r\n * @public\r\n */ class ContractFactory extends contracts.ContractFactory {\n}\nexports.ALCHEMY_EVENT_TYPES = ALCHEMY_EVENT_TYPES;\nexports.ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE = ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE;\nexports.ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE = ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE;\nexports.Alchemy = Alchemy;\nexports.Contract = Contract;\nexports.ContractFactory = ContractFactory;\nexports.CustomNetworks = CustomNetworks;\nexports.DEFAULT_ALCHEMY_API_KEY = DEFAULT_ALCHEMY_API_KEY;\nexports.DEFAULT_NETWORK = DEFAULT_NETWORK;\nexports.EthersEvent = EthersEvent;\nexports.EthersNetwork = EthersNetwork;\nexports.IS_BROWSER = IS_BROWSER;\nexports.VERSION = VERSION;\nexports.Wallet = Wallet;\nexports.__awaiter = __awaiter$1;\nexports.deepCopy = deepCopy;\nexports.fromHex = fromHex;\nexports.getAlchemyEventTag = getAlchemyEventTag;\nexports.getAlchemyHttpUrl = getAlchemyHttpUrl;\nexports.getAlchemyWsUrl = getAlchemyWsUrl;\nexports.isAlchemyEvent = isAlchemyEvent;\nexports.isHex = isHex;\nexports.logWarn = logWarn;\nexports.noop = noop;\nexports.setLogLevel = setLogLevel;\nexports.toHex = toHex;\nexports.verifyAlchemyEventName = verifyAlchemyEventName; //# sourceMappingURL=index-3873e7b8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvaW5kZXgtMzg3M2U3YjguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJRSxRQUFRRixtQkFBT0EsQ0FBQztBQUNwQixJQUFJRyxRQUFRSCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJSSxtQkFBbUJKLG1CQUFPQSxDQUFDO0FBQy9CLElBQUlLLFNBQVNMLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlNLFlBQVlOLG1CQUFPQSxDQUFDO0FBRXhCLFNBQVNPLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRSxXQUFXQTtJQUFFO0FBQUc7QUFFakgsSUFBSUMsaUJBQWlCLFdBQVcsR0FBRUYsc0JBQXNCSjtBQUV4RDs7Ozs7OztDQU9DLEdBQ0RPLGVBQWUsR0FBRyxLQUFLO0FBQ3RCLFVBQVVDLE9BQU87SUFDZEEsT0FBTyxDQUFDLGNBQWMsR0FBRztJQUN6QixnQkFBZ0IsR0FDaEJBLE9BQU8sQ0FBQyxhQUFhLEdBQUc7SUFDeEJBLE9BQU8sQ0FBQyxjQUFjLEdBQUc7SUFDekJBLE9BQU8sQ0FBQyxjQUFjLEdBQUc7SUFDekJBLE9BQU8sQ0FBQyxZQUFZLEdBQUc7SUFDdkJBLE9BQU8sQ0FBQyxjQUFjLEdBQUc7SUFDekIsZ0JBQWdCLEdBQ2hCQSxPQUFPLENBQUMsYUFBYSxHQUFHO0lBQ3hCQSxPQUFPLENBQUMsY0FBYyxHQUFHO0lBQ3pCQSxPQUFPLENBQUMsY0FBYyxHQUFHO0lBQ3pCLGdCQUFnQixHQUNoQkEsT0FBTyxDQUFDLGFBQWEsR0FBRztJQUN4QkEsT0FBTyxDQUFDLGNBQWMsR0FBRztJQUN6QkEsT0FBTyxDQUFDLGdCQUFnQixHQUFHO0lBQzNCLGdCQUFnQixHQUNoQkEsT0FBTyxDQUFDLGVBQWUsR0FB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R3cwQjtBQUNoRHgwQiwrQ0FBK0MsR0FBR3UwQjtBQUNsRHYwQixlQUFlLEdBQUdzM0I7QUFDbEJ0M0IsZ0JBQWdCLEdBQUd5NEI7QUFDbkJ6NEIsdUJBQXVCLEdBQUcwNEI7QUFDMUIxNEIsc0JBQXNCLEdBQUdvTTtBQUN6QnBNLCtCQUErQixHQUFHeUU7QUFDbEN6RSx1QkFBdUIsR0FBRzBFO0FBQzFCMUUsbUJBQW1CLEdBQUd3MUI7QUFDdEJ4MUIscUJBQXFCLEdBQUd1RjtBQUN4QnZGLGtCQUFrQixHQUFHc2E7QUFDckJ0YSxlQUFlLEdBQUd5aUI7QUFDbEJ6aUIsY0FBYyxHQUFHODNCO0FBQ2pCOTNCLGlCQUFpQixHQUFHMEI7QUFDcEIxQixnQkFBZ0IsR0FBR3dWO0FBQ25CeFYsZUFBZSxHQUFHeVY7QUFDbEJ6ViwwQkFBMEIsR0FBRzgxQjtBQUM3QjkxQix5QkFBeUIsR0FBRzhFO0FBQzVCOUUsdUJBQXVCLEdBQUdrRjtBQUMxQmxGLHNCQUFzQixHQUFHNjFCO0FBQ3pCNzFCLGFBQWEsR0FBR2dXO0FBQ2hCaFcsZUFBZSxHQUFHbWlCO0FBQ2xCbmlCLFlBQVksR0FBRzJNO0FBQ2YzTSxtQkFBbUIsR0FBRytUO0FBQ3RCL1QsYUFBYSxHQUFHNlY7QUFDaEI3Viw4QkFBOEIsR0FBR20yQix3QkFDakMsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWlzc2lvbi1sYXVuY2gtYnVybi1vci1nbG9yeS8uL25vZGVfbW9kdWxlcy9hbGNoZW15LXNkay9kaXN0L2Nqcy9pbmRleC0zODczZTdiOC5qcz81NjJlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9hcGkvdXRpbHMnKTtcbnZhciBiaWdudW1iZXIgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9iaWdudW1iZXInKTtcbnZhciBieXRlcyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2J5dGVzJyk7XG52YXIgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpO1xudmFyIGFic3RyYWN0UHJvdmlkZXIgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlcicpO1xudmFyIHdhbGxldCA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L3dhbGxldCcpO1xudmFyIGNvbnRyYWN0cyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIGF4aW9zX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShheGlvcyk7XG5cbi8qKlxyXG4gKiBUaGUgc3VwcG9ydGVkIG5ldHdvcmtzIGJ5IEFsY2hlbXkuIE5vdGUgdGhhdCBzb21lIGZ1bmN0aW9ucyBhcmUgbm90IGF2YWlsYWJsZVxyXG4gKiBvbiBhbGwgbmV0d29ya3MuIFBsZWFzZSByZWZlciB0byB0aGUgQWxjaGVteSBkb2N1bWVudGF0aW9uIGZvciB3aGljaCBBUElzIGFyZVxyXG4gKiBhdmFpbGFibGUgb24gd2hpY2ggbmV0d29ya3NcclxuICoge0BsaW5rIGh0dHBzOi8vZG9jcy5hbGNoZW15LmNvbS9hbGNoZW15L2FwaXMvZmVhdHVyZS1zdXBwb3J0LWJ5LWNoYWlufVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLk5ldHdvcmsgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoTmV0d29yaykge1xyXG4gICAgTmV0d29ya1tcIkVUSF9NQUlOTkVUXCJdID0gXCJldGgtbWFpbm5ldFwiO1xyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBOZXR3b3JrW1wiRVRIX0dPRVJMSVwiXSA9IFwiZXRoLWdvZXJsaVwiO1xyXG4gICAgTmV0d29ya1tcIkVUSF9TRVBPTElBXCJdID0gXCJldGgtc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIkVUSF9IT0xFU0tZXCJdID0gXCJldGgtaG9sZXNreVwiO1xyXG4gICAgTmV0d29ya1tcIkVUSF9IT09ESVwiXSA9IFwiZXRoLWhvb2RpXCI7XHJcbiAgICBOZXR3b3JrW1wiT1BUX01BSU5ORVRcIl0gPSBcIm9wdC1tYWlubmV0XCI7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cclxuICAgIE5ldHdvcmtbXCJPUFRfR09FUkxJXCJdID0gXCJvcHQtZ29lcmxpXCI7XHJcbiAgICBOZXR3b3JrW1wiT1BUX1NFUE9MSUFcIl0gPSBcIm9wdC1zZXBvbGlhXCI7XHJcbiAgICBOZXR3b3JrW1wiQVJCX01BSU5ORVRcIl0gPSBcImFyYi1tYWlubmV0XCI7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cclxuICAgIE5ldHdvcmtbXCJBUkJfR09FUkxJXCJdID0gXCJhcmItZ29lcmxpXCI7XHJcbiAgICBOZXR3b3JrW1wiQVJCX1NFUE9MSUFcIl0gPSBcImFyYi1zZXBvbGlhXCI7XHJcbiAgICBOZXR3b3JrW1wiTUFUSUNfTUFJTk5FVFwiXSA9IFwicG9seWdvbi1tYWlubmV0XCI7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cclxuICAgIE5ldHdvcmtbXCJNQVRJQ19NVU1CQUlcIl0gPSBcInBvbHlnb24tbXVtYmFpXCI7XHJcbiAgICBOZXR3b3JrW1wiTUFUSUNfQU1PWVwiXSA9IFwicG9seWdvbi1hbW95XCI7XHJcbiAgICBOZXR3b3JrW1wiQVNUQVJfTUFJTk5FVFwiXSA9IFwiYXN0YXItbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlBPTFlHT05aS0VWTV9NQUlOTkVUXCJdID0gXCJwb2x5Z29uemtldm0tbWFpbm5ldFwiO1xyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBOZXR3b3JrW1wiUE9MWUdPTlpLRVZNX1RFU1RORVRcIl0gPSBcInBvbHlnb256a2V2bS10ZXN0bmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiUE9MWUdPTlpLRVZNX0NBUkRPTkFcIl0gPSBcInBvbHlnb256a2V2bS1jYXJkb25hXCI7XHJcbiAgICBOZXR3b3JrW1wiQkFTRV9NQUlOTkVUXCJdID0gXCJiYXNlLW1haW5uZXRcIjtcclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgTmV0d29ya1tcIkJBU0VfR09FUkxJXCJdID0gXCJiYXNlLWdvZXJsaVwiO1xyXG4gICAgTmV0d29ya1tcIkJBU0VfU0VQT0xJQVwiXSA9IFwiYmFzZS1zZXBvbGlhXCI7XHJcbiAgICBOZXR3b3JrW1wiWktTWU5DX01BSU5ORVRcIl0gPSBcInprc3luYy1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiWktTWU5DX1NFUE9MSUFcIl0gPSBcInprc3luYy1zZXBvbGlhXCI7XHJcbiAgICBOZXR3b3JrW1wiU0hBUEVfTUFJTk5FVFwiXSA9IFwic2hhcGUtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlNIQVBFX1NFUE9MSUFcIl0gPSBcInNoYXBlLXNlcG9saWFcIjtcclxuICAgIE5ldHdvcmtbXCJMSU5FQV9NQUlOTkVUXCJdID0gXCJsaW5lYS1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiTElORUFfU0VQT0xJQVwiXSA9IFwibGluZWEtc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIkZBTlRPTV9NQUlOTkVUXCJdID0gXCJmYW50b20tbWFpbm5ldFwiO1xyXG4gICAgLyoqIEBkZXByZWNhdGVkICovXHJcbiAgICBOZXR3b3JrW1wiRkFOVE9NX1RFU1RORVRcIl0gPSBcImZhbnRvbS10ZXN0bmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiWkVUQUNIQUlOX01BSU5ORVRcIl0gPSBcInpldGFjaGFpbi1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiWkVUQUNIQUlOX1RFU1RORVRcIl0gPSBcInpldGFjaGFpbi10ZXN0bmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiQVJCTk9WQV9NQUlOTkVUXCJdID0gXCJhcmJub3ZhLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJCTEFTVF9NQUlOTkVUXCJdID0gXCJibGFzdC1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiQkxBU1RfU0VQT0xJQVwiXSA9IFwiYmxhc3Qtc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIk1BTlRMRV9NQUlOTkVUXCJdID0gXCJtYW50bGUtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIk1BTlRMRV9TRVBPTElBXCJdID0gXCJtYW50bGUtc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIlNDUk9MTF9NQUlOTkVUXCJdID0gXCJzY3JvbGwtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlNDUk9MTF9TRVBPTElBXCJdID0gXCJzY3JvbGwtc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIkdOT1NJU19NQUlOTkVUXCJdID0gXCJnbm9zaXMtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIkdOT1NJU19DSElBRE9cIl0gPSBcImdub3Npcy1jaGlhZG9cIjtcclxuICAgIE5ldHdvcmtbXCJCTkJfTUFJTk5FVFwiXSA9IFwiYm5iLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJCTkJfVEVTVE5FVFwiXSA9IFwiYm5iLXRlc3RuZXRcIjtcclxuICAgIE5ldHdvcmtbXCJBVkFYX01BSU5ORVRcIl0gPSBcImF2YXgtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIkFWQVhfRlVKSVwiXSA9IFwiYXZheC1mdWppXCI7XHJcbiAgICBOZXR3b3JrW1wiQ0VMT19NQUlOTkVUXCJdID0gXCJjZWxvLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJDRUxPX0FMRkFKT1JFU1wiXSA9IFwiY2Vsby1hbGZham9yZXNcIjtcclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgTmV0d29ya1tcIkNFTE9fQkFLTEFWQVwiXSA9IFwiY2Vsby1iYWtsYXZhXCI7XHJcbiAgICBOZXR3b3JrW1wiTUVUSVNfTUFJTk5FVFwiXSA9IFwibWV0aXMtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIk9QQk5CX01BSU5ORVRcIl0gPSBcIm9wYm5iLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJPUEJOQl9URVNUTkVUXCJdID0gXCJvcGJuYi10ZXN0bmV0XCI7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cclxuICAgIE5ldHdvcmtbXCJCRVJBQ0hBSU5fQkFSVElPXCJdID0gXCJiZXJhY2hhaW4tYmFydGlvXCI7XHJcbiAgICBOZXR3b3JrW1wiQkVSQUNIQUlOX01BSU5ORVRcIl0gPSBcImJlcmFjaGFpbi1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiQkVSQUNIQUlOX0JFUE9MSUFcIl0gPSBcImJlcmFjaGFpbi1iZXBvbGlhXCI7XHJcbiAgICBOZXR3b3JrW1wiU09ORUlVTV9NQUlOTkVUXCJdID0gXCJzb25laXVtLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJTT05FSVVNX01JTkFUT1wiXSA9IFwic29uZWl1bS1taW5hdG9cIjtcclxuICAgIE5ldHdvcmtbXCJXT1JMRENIQUlOX01BSU5ORVRcIl0gPSBcIndvcmxkY2hhaW4tbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIldPUkxEQ0hBSU5fU0VQT0xJQVwiXSA9IFwid29ybGRjaGFpbi1zZXBvbGlhXCI7XHJcbiAgICBOZXR3b3JrW1wiUk9PVFNUT0NLX01BSU5ORVRcIl0gPSBcInJvb3RzdG9jay1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiUk9PVFNUT0NLX1RFU1RORVRcIl0gPSBcInJvb3RzdG9jay10ZXN0bmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiRkxPV19NQUlOTkVUXCJdID0gXCJmbG93LW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJGTE9XX1RFU1RORVRcIl0gPSBcImZsb3ctdGVzdG5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlpPUkFfTUFJTk5FVFwiXSA9IFwiem9yYS1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiWk9SQV9TRVBPTElBXCJdID0gXCJ6b3JhLXNlcG9saWFcIjtcclxuICAgIE5ldHdvcmtbXCJGUkFYX01BSU5ORVRcIl0gPSBcImZyYXgtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIkZSQVhfU0VQT0xJQVwiXSA9IFwiZnJheC1zZXBvbGlhXCI7XHJcbiAgICBOZXR3b3JrW1wiUE9MWU5PTUlBTF9NQUlOTkVUXCJdID0gXCJwb2x5bm9taWFsLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJQT0xZTk9NSUFMX1NFUE9MSUFcIl0gPSBcInBvbHlub21pYWwtc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIkNST1NTRklfTUFJTk5FVFwiXSA9IFwiY3Jvc3NmaS1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiQ1JPU1NGSV9URVNUTkVUXCJdID0gXCJjcm9zc2ZpLXRlc3RuZXRcIjtcclxuICAgIE5ldHdvcmtbXCJBUEVDSEFJTl9NQUlOTkVUXCJdID0gXCJhcGVjaGFpbi1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiQVBFQ0hBSU5fQ1VSVElTXCJdID0gXCJhcGVjaGFpbi1jdXJ0aXNcIjtcclxuICAgIE5ldHdvcmtbXCJMRU5TX01BSU5ORVRcIl0gPSBcImxlbnMtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIkxFTlNfU0VQT0xJQVwiXSA9IFwibGVucy1zZXBvbGlhXCI7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cclxuICAgIE5ldHdvcmtbXCJHRUlTVF9NQUlOTkVUXCJdID0gXCJnZWlzdC1tYWlubmV0XCI7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cclxuICAgIE5ldHdvcmtbXCJHRUlTVF9QT0xURVJcIl0gPSBcImdlaXN0LXBvbHRlclwiO1xyXG4gICAgTmV0d29ya1tcIkxVTUlBX1BSSVNNXCJdID0gXCJsdW1pYS1wcmlzbVwiO1xyXG4gICAgTmV0d29ya1tcIkxVTUlBX1RFU1RORVRcIl0gPSBcImx1bWlhLXRlc3RuZXRcIjtcclxuICAgIE5ldHdvcmtbXCJVTklDSEFJTl9NQUlOTkVUXCJdID0gXCJ1bmljaGFpbi1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiVU5JQ0hBSU5fU0VQT0xJQVwiXSA9IFwidW5pY2hhaW4tc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIlNPTklDX01BSU5ORVRcIl0gPSBcInNvbmljLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJTT05JQ19CTEFaRVwiXSA9IFwic29uaWMtYmxhemVcIjtcclxuICAgIE5ldHdvcmtbXCJYTVRQX1RFU1RORVRcIl0gPSBcInhtdHAtdGVzdG5ldFwiO1xyXG4gICAgTmV0d29ya1tcIkFCU1RSQUNUX01BSU5ORVRcIl0gPSBcImFic3RyYWN0LW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJBQlNUUkFDVF9URVNUTkVUXCJdID0gXCJhYnN0cmFjdC10ZXN0bmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiREVHRU5fTUFJTk5FVFwiXSA9IFwiZGVnZW4tbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIklOS19NQUlOTkVUXCJdID0gXCJpbmstbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIklOS19TRVBPTElBXCJdID0gXCJpbmstc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIlNFSV9NQUlOTkVUXCJdID0gXCJzZWktbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlNFSV9URVNUTkVUXCJdID0gXCJzZWktdGVzdG5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlJPTklOX01BSU5ORVRcIl0gPSBcInJvbmluLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJST05JTl9TQUlHT05cIl0gPSBcInJvbmluLXNhaWdvblwiO1xyXG4gICAgTmV0d29ya1tcIk1PTkFEX1RFU1RORVRcIl0gPSBcIm1vbmFkLXRlc3RuZXRcIjtcclxuICAgIE5ldHdvcmtbXCJTRVRUTFVTX1NFUFRFU1RORVRcIl0gPSBcInNldHRsdXMtc2VwdGVzdG5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlNFVFRMVVNfTUFJTk5FVFwiXSA9IFwic2V0dGx1cy1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiU09MQU5BX01BSU5ORVRcIl0gPSBcInNvbGFuYS1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiU09MQU5BX0RFVk5FVFwiXSA9IFwic29sYW5hLWRldm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIkdFTlNZTl9URVNUTkVUXCJdID0gXCJnZW5zeW4tdGVzdG5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlNVUEVSU0VFRF9NQUlOTkVUXCJdID0gXCJzdXBlcnNlZWQtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlNVUEVSU0VFRF9TRVBPTElBXCJdID0gXCJzdXBlcnNlZWQtc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIlRFQV9TRVBPTElBXCJdID0gXCJ0ZWEtc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIkFOSU1FX01BSU5ORVRcIl0gPSBcImFuaW1lLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJBTklNRV9TRVBPTElBXCJdID0gXCJhbmltZS1zZXBvbGlhXCI7XHJcbiAgICBOZXR3b3JrW1wiU1RPUllfTUFJTk5FVFwiXSA9IFwic3RvcnktbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlNUT1JZX0FFTkVJRFwiXSA9IFwic3RvcnktYWVuZWlkXCI7XHJcbiAgICBOZXR3b3JrW1wiTUVHQUVUSF9URVNUTkVUXCJdID0gXCJtZWdhZXRoLXRlc3RuZXRcIjtcclxuICAgIE5ldHdvcmtbXCJCT1RBTklYX01BSU5ORVRcIl0gPSBcImJvdGFuaXgtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIkJPVEFOSVhfVEVTVE5FVFwiXSA9IFwiYm90YW5peC10ZXN0bmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiSFVNQU5JVFlfTUFJTk5FVFwiXSA9IFwiaHVtYW5pdHktbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIlJJU0VfVEVTVE5FVFwiXSA9IFwicmlzZS10ZXN0bmV0XCI7XHJcbn0pKGV4cG9ydHMuTmV0d29yayB8fCAoZXhwb3J0cy5OZXR3b3JrID0ge30pKTtcclxuLyoqIFRva2VuIFR5cGVzIGZvciB0aGUgYGdldFRva2VuQmFsYW5jZXMoKWAgZW5kcG9pbnQuICovXHJcbmV4cG9ydHMuVG9rZW5CYWxhbmNlVHlwZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChUb2tlbkJhbGFuY2VUeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbiB0byBmZXRjaCB0aGUgdG9wIDEwMCB0b2tlbnMgYnkgMjQtaG91ciB2b2x1bWUuIFRoaXMgb3B0aW9uIGlzIG9ubHlcclxuICAgICAqIGF2YWlsYWJsZSBvbiBNYWlubmV0IGluIEV0aGVyZXVtLCBQb2x5Z29uLCBhbmQgQXJiaXRydW0uXHJcbiAgICAgKi9cclxuICAgIFRva2VuQmFsYW5jZVR5cGVbXCJERUZBVUxUX1RPS0VOU1wiXSA9IFwiREVGQVVMVF9UT0tFTlNcIjtcclxuICAgIC8qKlxyXG4gICAgICogT3B0aW9uIHRvIGZldGNoIHRoZSBzZXQgb2YgRVJDLTIwIHRva2VucyB0aGF0IHRoZSBhZGRyZXNzIGFzIGV2ZXIgaGVsZC4gaGlzXHJcbiAgICAgKiBsaXN0IGlzIHByb2R1Y2VkIGJ5IGFuIGFkZHJlc3MncyBoaXN0b3JpY2FsIHRyYW5zZmVyIGFjdGl2aXR5IGFuZCBpbmNsdWRlc1xyXG4gICAgICogYWxsIHRva2VucyB0aGF0IHRoZSBhZGRyZXNzIGhhcyBldmVyIHJlY2VpdmVkLlxyXG4gICAgICovXHJcbiAgICBUb2tlbkJhbGFuY2VUeXBlW1wiRVJDMjBcIl0gPSBcImVyYzIwXCI7XHJcbn0pKGV4cG9ydHMuVG9rZW5CYWxhbmNlVHlwZSB8fCAoZXhwb3J0cy5Ub2tlbkJhbGFuY2VUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIENhdGVnb3JpZXMgb2YgdHJhbnNmZXJzIHRvIHVzZSB3aXRoIHRoZSB7QGxpbmsgQXNzZXRUcmFuc2ZlcnNQYXJhbXN9IHJlcXVlc3RcclxuICogb2JqZWN0IHdoZW4gdXNpbmcge0BsaW5rIENvcmVOYW1lc3BhY2UuZ2V0QXNzZXRUcmFuc2ZlcnN9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUb3AgbGV2ZWwgRVRIIHRyYW5zYWN0aW9ucyB0aGF0IG9jY3VyIHdoZXJlIHRoZSBgZnJvbUFkZHJlc3NgIGlzIGFuXHJcbiAgICAgKiBleHRlcm5hbCB1c2VyLWNyZWF0ZWQgYWRkcmVzcy4gRXh0ZXJuYWwgYWRkcmVzc2VzIGhhdmUgcHJpdmF0ZSBrZXlzIGFuZCBhcmVcclxuICAgICAqIGFjY2Vzc2VkIGJ5IHVzZXJzLlxyXG4gICAgICovXHJcbiAgICBBc3NldFRyYW5zZmVyc0NhdGVnb3J5W1wiRVhURVJOQUxcIl0gPSBcImV4dGVybmFsXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRvcCBsZXZlbCBFVEggdHJhbnNhY3Rpb25zIHRoYXQgb2NjdXIgd2hlcmUgdGhlIGBmcm9tQWRkcmVzc2AgaXMgYW5cclxuICAgICAqIGludGVybmFsLCBzbWFydCBjb250cmFjdCBhZGRyZXNzLiBGb3IgZXhhbXBsZSwgYSBzbWFydCBjb250cmFjdCBjYWxsaW5nXHJcbiAgICAgKiBhbm90aGVyIHNtYXJ0IGNvbnRyYWN0IG9yIHNlbmRpbmdcclxuICAgICAqL1xyXG4gICAgQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeVtcIklOVEVSTkFMXCJdID0gXCJpbnRlcm5hbFwiO1xyXG4gICAgLyoqIEVSQzIwIHRyYW5zZmVycy4gKi9cclxuICAgIEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnlbXCJFUkMyMFwiXSA9IFwiZXJjMjBcIjtcclxuICAgIC8qKiBFUkM3MjEgdHJhbnNmZXJzLiAqL1xyXG4gICAgQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeVtcIkVSQzcyMVwiXSA9IFwiZXJjNzIxXCI7XHJcbiAgICAvKiogRVJDMTE1NSB0cmFuc2ZlcnMuICovXHJcbiAgICBBc3NldFRyYW5zZmVyc0NhdGVnb3J5W1wiRVJDMTE1NVwiXSA9IFwiZXJjMTE1NVwiO1xyXG4gICAgLyoqIFNwZWNpYWwgY29udHJhY3RzIHRoYXQgZG9uJ3QgZm9sbG93IEVSQyA3MjEvMTE1NSwgKGV4OiBDcnlwdG9LaXR0aWVzKS4gKi9cclxuICAgIEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnlbXCJTUEVDSUFMTkZUXCJdID0gXCJzcGVjaWFsbmZ0XCI7XHJcbn0pKGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeSB8fCAoZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5ID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSB0eXBlIG9mIHRyYW5zZmVyIGZvciB0aGUgcmVxdWVzdC4gTm90ZSB0aGF0IHVzaW5nIGBUT2Agd2lsbCBhbHNvIGluY2x1ZGVcclxuICogTkZUcyB0aGF0IHdlcmUgbWludGVkIGJ5IHRoZSBvd25lci5cclxuICovXHJcbmV4cG9ydHMuR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGUgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGUpIHtcclxuICAgIEdldFRyYW5zZmVyc0Zvck93bmVyVHJhbnNmZXJUeXBlW1wiVE9cIl0gPSBcIlRPXCI7XHJcbiAgICBHZXRUcmFuc2ZlcnNGb3JPd25lclRyYW5zZmVyVHlwZVtcIkZST01cIl0gPSBcIkZST01cIjtcclxufSkoZXhwb3J0cy5HZXRUcmFuc2ZlcnNGb3JPd25lclRyYW5zZmVyVHlwZSB8fCAoZXhwb3J0cy5HZXRUcmFuc2ZlcnNGb3JPd25lclRyYW5zZmVyVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbnVtIGZvciByZXByZXNlbnRpbmcgdGhlIHN1cHBvcnRlZCBzb3J0aW5nIG9yZGVycyBvZiB0aGUgQVBJLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLlNvcnRpbmdPcmRlciA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChTb3J0aW5nT3JkZXIpIHtcclxuICAgIFNvcnRpbmdPcmRlcltcIkFTQ0VORElOR1wiXSA9IFwiYXNjXCI7XHJcbiAgICBTb3J0aW5nT3JkZXJbXCJERVNDRU5ESU5HXCJdID0gXCJkZXNjXCI7XHJcbn0pKGV4cG9ydHMuU29ydGluZ09yZGVyIHx8IChleHBvcnRzLlNvcnRpbmdPcmRlciA9IHt9KSk7XHJcbi8qKiBBbiBPcGVuU2VhIGNvbGxlY3Rpb24ncyBhcHByb3ZhbCBzdGF0dXMuICovXHJcbmV4cG9ydHMuT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1cyA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChPcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzKSB7XHJcbiAgICAvKiogVmVyaWZpZWQgY29sbGVjdGlvbi4gKi9cclxuICAgIE9wZW5TZWFTYWZlbGlzdFJlcXVlc3RTdGF0dXNbXCJWRVJJRklFRFwiXSA9IFwidmVyaWZpZWRcIjtcclxuICAgIC8qKiBDb2xsZWN0aW9ucyB0aGF0IGFyZSBhcHByb3ZlZCBvbiBvcGVuIHNlYSBhbmQgY2FuIGJlIGZvdW5kIGluIHNlYXJjaCByZXN1bHRzLiAqL1xyXG4gICAgT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1c1tcIkFQUFJPVkVEXCJdID0gXCJhcHByb3ZlZFwiO1xyXG4gICAgLyoqIENvbGxlY3Rpb25zIHRoYXQgcmVxdWVzdGVkIHNhZmVsaXN0aW5nIG9uIE9wZW5TZWEuICovXHJcbiAgICBPcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzW1wiUkVRVUVTVEVEXCJdID0gXCJyZXF1ZXN0ZWRcIjtcclxuICAgIC8qKiBCcmFuZCBuZXcgY29sbGVjdGlvbnMuICovXHJcbiAgICBPcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzW1wiTk9UX1JFUVVFU1RFRFwiXSA9IFwibm90X3JlcXVlc3RlZFwiO1xyXG59KShleHBvcnRzLk9wZW5TZWFTYWZlbGlzdFJlcXVlc3RTdGF0dXMgfHwgKGV4cG9ydHMuT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1cyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBNZXRob2QgbmFtZXMgZm9yIEFsY2hlbXkncyBjdXN0b20gU3Vic2NyaXB0aW9uIEFQSSBlbmRwb2ludHMuXHJcbiAqXHJcbiAqIFRoaXMgdmFsdWUgaXMgcHJvdmlkZWQgaW4gdGhlIGBtZXRob2RgIGZpZWxkIHdoZW4gY3JlYXRpbmcgYW4gZXZlbnQgZmlsdGVyIG9uXHJcbiAqIHRoZSBXZWJzb2NrZXQgTmFtZXNwYWNlLlxyXG4gKi9cclxuZXhwb3J0cy5BbGNoZW15U3Vic2NyaXB0aW9uID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKEFsY2hlbXlTdWJzY3JpcHRpb24pIHtcclxuICAgIEFsY2hlbXlTdWJzY3JpcHRpb25bXCJQRU5ESU5HX1RSQU5TQUNUSU9OU1wiXSA9IFwiYWxjaGVteV9wZW5kaW5nVHJhbnNhY3Rpb25zXCI7XHJcbiAgICBBbGNoZW15U3Vic2NyaXB0aW9uW1wiTUlORURfVFJBTlNBQ1RJT05TXCJdID0gXCJhbGNoZW15X21pbmVkVHJhbnNhY3Rpb25zXCI7XHJcbn0pKGV4cG9ydHMuQWxjaGVteVN1YnNjcmlwdGlvbiB8fCAoZXhwb3J0cy5BbGNoZW15U3Vic2NyaXB0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIEFzc2V0IHR5cGUgcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHtAbGluayBUcmFuc2FjdE5hbWVzcGFjZS5zaW11bGF0ZUFzc2V0Q2hhbmdlc30uXHJcbiAqIEFsbG93cyB5b3UgdG8gZGV0ZXJtaW5lIGlmIHRoZSBhc3NldHMgYXBwcm92ZWQgb3IgLyBhbmQgdHJhbnNmZXJyZWQgYXJlXHJcbiAqIG5hdGl2ZSwgdG9rZW5zIG9yIE5GVHMuXHJcbiAqL1xyXG5leHBvcnRzLlNpbXVsYXRlQXNzZXRUeXBlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKFNpbXVsYXRlQXNzZXRUeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIE5hdGl2ZSB0cmFuc2ZlcnMgdGhhdCBpbnZvbHZlIHRoZSBjdXJyZW5jeSBvZiB0aGUgY2hhaW4gdGhlIHNpbXVsYXRpb24gaXNcclxuICAgICAqIHJ1biBvbiAoZXg6IEVUSCBmb3IgRXRoZXJldW0sIE1BVElDIGZvciBQb2x5Z29uLCBFVEggZm9yIEFyYml0cnVtKS5cclxuICAgICAqL1xyXG4gICAgU2ltdWxhdGVBc3NldFR5cGVbXCJOQVRJVkVcIl0gPSBcIk5BVElWRVwiO1xyXG4gICAgLyoqIEVSQzIwIGFwcHJvdmFsIG9yIHRyYW5zZmVycy4gKi9cclxuICAgIFNpbXVsYXRlQXNzZXRUeXBlW1wiRVJDMjBcIl0gPSBcIkVSQzIwXCI7XHJcbiAgICAvKiogRVJDNzIxIGFwcHJvdmFsIG9yIHRyYW5zZmVycy4gKi9cclxuICAgIFNpbXVsYXRlQXNzZXRUeXBlW1wiRVJDNzIxXCJdID0gXCJFUkM3MjFcIjtcclxuICAgIC8qKiBFUkMxMTU1IGFwcHJvdmFsIG9yIHRyYW5zZmVycy4gKi9cclxuICAgIFNpbXVsYXRlQXNzZXRUeXBlW1wiRVJDMTE1NVwiXSA9IFwiRVJDMTE1NVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWFsIGNvbnRyYWN0cyB0aGF0IGRvbid0IGZvbGxvdyBFUkMgNzIxLzExNTUuQ3VycmVudGx5IGxpbWl0ZWQgdG9cclxuICAgICAqIENyeXB0b0tpdHRpZXMgYW5kIENyeXB0b1B1bmtzLlxyXG4gICAgICovXHJcbiAgICBTaW11bGF0ZUFzc2V0VHlwZVtcIlNQRUNJQUxfTkZUXCJdID0gXCJTUEVDSUFMX05GVFwiO1xyXG59KShleHBvcnRzLlNpbXVsYXRlQXNzZXRUeXBlIHx8IChleHBvcnRzLlNpbXVsYXRlQXNzZXRUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIENoYW5nZSB0eXBlIHJldHVybmVkIHdoZW4gY2FsbGluZyB7QGxpbmsgVHJhbnNhY3ROYW1lc3BhY2Uuc2ltdWxhdGVBc3NldENoYW5nZXN9LlxyXG4gKi9cclxuZXhwb3J0cy5TaW11bGF0ZUNoYW5nZVR5cGUgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoU2ltdWxhdGVDaGFuZ2VUeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFJlcHJlc2VudHMgYSB0cmFuc2FjdGlvbiB0aGF0IGFwcHJvdmVkIG9yIGRpc2FwcHJvdmVkIHBlcm1pc3Npb25zIGZvciBhXHJcbiAgICAgKiBjb250cmFjdC5cclxuICAgICAqXHJcbiAgICAgKiBBUFBST1ZFIHdpdGhvdXQgdG9rZW4gSUQg4oaSIGFwcHJvdmUgYWxsIHRva2Vuc1xyXG4gICAgICogQVBQUk9WRSB3aXRob3V0IGFtb3VudCDihpIgYXBwcm92ZSBhbGwgYW1vdW50XHJcbiAgICAgKiBBUFBST1ZFIHdpdGggemVybyBhbW91bnQg4oaSIGFwcHJvdmFsIGJlaW5nIGNsZWFyZWRcclxuICAgICAqL1xyXG4gICAgU2ltdWxhdGVDaGFuZ2VUeXBlW1wiQVBQUk9WRVwiXSA9IFwiQVBQUk9WRVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIGEgdHJhbnNhY3Rpb24gdGhhdCB0cmFuc2ZlcnJlZCB0b2tlbnMgZnJvbSBvbmUgYWRkcmVzcyB0byBhbm90aGVyLlxyXG4gICAgICovXHJcbiAgICBTaW11bGF0ZUNoYW5nZVR5cGVbXCJUUkFOU0ZFUlwiXSA9IFwiVFJBTlNGRVJcIjtcclxufSkoZXhwb3J0cy5TaW11bGF0ZUNoYW5nZVR5cGUgfHwgKGV4cG9ydHMuU2ltdWxhdGVDaGFuZ2VUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIEF1dGhvcml0eSB1c2VkIHRvIGRlY29kZSBjYWxscyBhbmQgbG9ncyB3aGVuIHVzaW5nIHRoZVxyXG4gKiB7QGxpbmsgVHJhbnNhY3ROYW1lc3BhY2Uuc2ltdWxhdGVFeGVjdXRpb259IG1ldGhvZC5cclxuICovXHJcbmV4cG9ydHMuRGVjb2RpbmdBdXRob3JpdHkgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoRGVjb2RpbmdBdXRob3JpdHkpIHtcclxuICAgIERlY29kaW5nQXV0aG9yaXR5W1wiRVRIRVJTQ0FOXCJdID0gXCJFVEhFUlNDQU5cIjtcclxufSkoZXhwb3J0cy5EZWNvZGluZ0F1dGhvcml0eSB8fCAoZXhwb3J0cy5EZWNvZGluZ0F1dGhvcml0eSA9IHt9KSk7XHJcbi8qKiBUaGUgdHlwZSBvZiBjYWxsIGluIGEgZGVidWcgY2FsbCB0cmFjZS4gKi9cclxuZXhwb3J0cy5EZWJ1Z0NhbGxUeXBlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKERlYnVnQ2FsbFR5cGUpIHtcclxuICAgIERlYnVnQ2FsbFR5cGVbXCJDUkVBVEVcIl0gPSBcIkNSRUFURVwiO1xyXG4gICAgRGVidWdDYWxsVHlwZVtcIkNBTExcIl0gPSBcIkNBTExcIjtcclxuICAgIERlYnVnQ2FsbFR5cGVbXCJTVEFUSUNDQUxMXCJdID0gXCJTVEFUSUNDQUxMXCI7XHJcbiAgICBEZWJ1Z0NhbGxUeXBlW1wiREVMRUdBVEVDQUxMXCJdID0gXCJERUxFR0FURUNBTExcIjtcclxufSkoZXhwb3J0cy5EZWJ1Z0NhbGxUeXBlIHx8IChleHBvcnRzLkRlYnVnQ2FsbFR5cGUgPSB7fSkpO1xyXG4vKipcclxuICogUG90ZW50aWFsIHRyYW5zYWN0aW9uIGpvYiBzdGF0dXNlcyBmb3IgYSB7QGxpbmsgR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25SZXNwb25zZX1cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBUT0RPKHR4am9iKTogUmVtb3ZlIGludGVybmFsIHRhZyBvbmNlIHRoaXMgZmVhdHVyZSBpcyByZWxlYXNlZC5cclxuZXhwb3J0cy5HYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1cyA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1cykge1xyXG4gICAgR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXNbXCJVTlNQRUNJRklFRFwiXSA9IFwiVFJBTlNBQ1RJT05fSk9CX1NUQVRVU19VTlNQRUNJRklFRFwiO1xyXG4gICAgR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXNbXCJJTl9QUk9HUkVTU1wiXSA9IFwiSU5fUFJPR1JFU1NcIjtcclxuICAgIEdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzW1wiQ09NUExFVEVcIl0gPSBcIkNPTVBMRVRFXCI7XHJcbiAgICBHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1c1tcIkFCQU5ET05FRFwiXSA9IFwiQUJBTkRPTkVEXCI7XHJcbn0pKGV4cG9ydHMuR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMgfHwgKGV4cG9ydHMuR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMgPSB7fSkpO1xyXG4vKiogVGhlIHZlcnNpb24gb2YgdGhlIHdlYmhvb2suIEFsbCBuZXdseSBjcmVhdGVkIHdlYmhvb2tzIGRlZmF1bHQgdG8gVjIuICovXHJcbmV4cG9ydHMuV2ViaG9va1ZlcnNpb24gPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoV2ViaG9va1ZlcnNpb24pIHtcclxuICAgIFdlYmhvb2tWZXJzaW9uW1wiVjFcIl0gPSBcIlYxXCI7XHJcbiAgICBXZWJob29rVmVyc2lvbltcIlYyXCJdID0gXCJWMlwiO1xyXG59KShleHBvcnRzLldlYmhvb2tWZXJzaW9uIHx8IChleHBvcnRzLldlYmhvb2tWZXJzaW9uID0ge30pKTtcclxuLyoqIFRoZSB0eXBlIG9mIHtAbGluayBXZWJob29rfS4gKi9cclxuZXhwb3J0cy5XZWJob29rVHlwZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChXZWJob29rVHlwZSkge1xyXG4gICAgV2ViaG9va1R5cGVbXCJNSU5FRF9UUkFOU0FDVElPTlwiXSA9IFwiTUlORURfVFJBTlNBQ1RJT05cIjtcclxuICAgIFdlYmhvb2tUeXBlW1wiRFJPUFBFRF9UUkFOU0FDVElPTlwiXSA9IFwiRFJPUFBFRF9UUkFOU0FDVElPTlwiO1xyXG4gICAgV2ViaG9va1R5cGVbXCJBRERSRVNTX0FDVElWSVRZXCJdID0gXCJBRERSRVNTX0FDVElWSVRZXCI7XHJcbiAgICBXZWJob29rVHlwZVtcIk5GVF9BQ1RJVklUWVwiXSA9IFwiTkZUX0FDVElWSVRZXCI7XHJcbiAgICBXZWJob29rVHlwZVtcIk5GVF9NRVRBREFUQV9VUERBVEVcIl0gPSBcIk5GVF9NRVRBREFUQV9VUERBVEVcIjtcclxuICAgIFdlYmhvb2tUeXBlW1wiR1JBUEhRTFwiXSA9IFwiR1JBUEhRTFwiO1xyXG59KShleHBvcnRzLldlYmhvb2tUeXBlIHx8IChleHBvcnRzLldlYmhvb2tUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIENvbW1pdG1lbnQgbGV2ZWwgb2YgdGhlIHRhcmdldCBibG9jayB3aXRoIHVzaW5nIG1ldGhvZHMgaW4gdGhlXHJcbiAqIHtAbGluayBEZWJ1Z05hbWVzcGFjZX1cclxuICovXHJcbmV4cG9ydHMuQ29tbWl0bWVudExldmVsID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKENvbW1pdG1lbnRMZXZlbCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTYW1wbGUgbmV4dCBibG9jayBpbmZlcnJlZCBieSBBbGNoZW15IGJ1aWx0IG9uIHRvcCBvZiB0aGUgbGF0ZXN0IGJsb2NrLlxyXG4gICAgICogVGhpcyBjb250YWlucyB0aGUgc2V0IG9mIHRyYW5zYWN0aW9ucyB0YWtlbiBmcm9tIHRoZSBsb2NhbCBtZW1wb29sIGFuZFxyXG4gICAgICogaXMgYSBwcm94eSBmb3IgYmxvY2tzIHRoYXQgaGF2ZSBub3QgYmVlbiBtaW5lZCB5ZXQuXHJcbiAgICAgKi9cclxuICAgIENvbW1pdG1lbnRMZXZlbFtcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vc3QgcmVjZW50IGJsb2NrIGluIHRoZSBjYW5vbmljYWwgY2hhaW4gb2JzZXJ2ZWQgYnkgQWxjaGVteS4gTm90ZSB0aGF0XHJcbiAgICAgKiB0aGlzIGJsb2NrIG1heSBiZSByZS1vcmdlZCBvdXQgb2YgdGhlIGNhbm9uaWNhbCBjaGFpbi5cclxuICAgICAqL1xyXG4gICAgQ29tbWl0bWVudExldmVsW1wiTEFURVNUXCJdID0gXCJsYXRlc3RcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vc3QgcmVjZW50IGNyeXB0by1lY29ub21pY2FsbHkgc2VjdXJlIGJsb2NrIHRoYXQgY2Fubm90IGJlIHJlLW9yZ2VkXHJcbiAgICAgKiBvdXRzaWRlIG9mIG1hbnVhbCBpbnRlcnZlbnRpb24gZHJpdmVuIGJ5IGNvbW11bml0eSBjb29yZGluYXRpb24uIFRoaXMgaXNcclxuICAgICAqIG9ubHkgYXZhaWxhYmxlIG9uIHtAbGluayBOZXR3b3JrLkVUSF9HT0VSTEl9IGFuZCB7QGxpbmsgTmV0d29yay5FVEhfU0VQT0xJQX0uXHJcbiAgICAgKi9cclxuICAgIENvbW1pdG1lbnRMZXZlbFtcIlNBRkVcIl0gPSBcInNhZmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vc3QgcmVjZW50IHNlY3VyZSBibG9jayB0aGF0IGhhcyBiZWVuIGFjY2VwdGVkIGJ5ID4yLzMgb2YgdmFsaWRhdG9ycy5cclxuICAgICAqIFRoaXMgYmxvY2sgaXMgdmVyeSB1bmxpa2VseSB0byBiZSByZS1vcmdlZC4gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBvblxyXG4gICAgICoge0BsaW5rIE5ldHdvcmsuRVRIX0dPRVJMSX0gYW5kIHtAbGluayBOZXR3b3JrLkVUSF9TRVBPTElBfS5cclxuICAgICAqL1xyXG4gICAgQ29tbWl0bWVudExldmVsW1wiRklOQUxJWkVEXCJdID0gXCJmaW5hbGl6ZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvd2VzdCBudW1iZXJlZCBibG9jayBhdmFpbGFibGUgdGhhdCBpcyB1c3VhbGx5IHRoZSBmaXJzdCBibG9jayBjcmVhdGVkLlxyXG4gICAgICovXHJcbiAgICBDb21taXRtZW50TGV2ZWxbXCJFQVJMSUVTVFwiXSA9IFwiZWFybGllc3RcIjtcclxufSkoZXhwb3J0cy5Db21taXRtZW50TGV2ZWwgfHwgKGV4cG9ydHMuQ29tbWl0bWVudExldmVsID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSB0eXBlIG9mIHRyYWNlciB0byB1c2Ugd2hlbiBydW5uaW5nIGRlYnVnIG1ldGhvZHMgaW4gdGhlXHJcbiAqIHtAbGluayBEZWJ1Z05hbWVzcGFjZX0uXHJcbiAqL1xyXG5leHBvcnRzLkRlYnVnVHJhY2VyVHlwZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChEZWJ1Z1RyYWNlclR5cGUpIHtcclxuICAgIERlYnVnVHJhY2VyVHlwZVtcIkNBTExfVFJBQ0VSXCJdID0gXCJjYWxsVHJhY2VyXCI7XHJcbiAgICBEZWJ1Z1RyYWNlclR5cGVbXCJQUkVTVEFURV9UUkFDRVJcIl0gPSBcInByZXN0YXRlVHJhY2VyXCI7XHJcbn0pKGV4cG9ydHMuRGVidWdUcmFjZXJUeXBlIHx8IChleHBvcnRzLkRlYnVnVHJhY2VyVHlwZSA9IHt9KSk7XG5cbi8qKlxyXG4gKiBBbiBlbnVtIGZvciBzcGVjaWZ5aW5nIHRoZSB0b2tlbiB0eXBlIG9uIE5GVHMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydHMuTmZ0VG9rZW5UeXBlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKE5mdFRva2VuVHlwZSkge1xyXG4gICAgTmZ0VG9rZW5UeXBlW1wiRVJDNzIxXCJdID0gXCJFUkM3MjFcIjtcclxuICAgIE5mdFRva2VuVHlwZVtcIkVSQzExNTVcIl0gPSBcIkVSQzExNTVcIjtcclxuICAgIE5mdFRva2VuVHlwZVtcIk5PX1NVUFBPUlRFRF9ORlRfU1RBTkRBUkRcIl0gPSBcIk5PX1NVUFBPUlRFRF9ORlRfU1RBTkRBUkRcIjtcclxuICAgIE5mdFRva2VuVHlwZVtcIk5PVF9BX0NPTlRSQUNUXCJdID0gXCJOT1RfQV9DT05UUkFDVFwiO1xyXG4gICAgTmZ0VG9rZW5UeXBlW1wiVU5LTk9XTlwiXSA9IFwiVU5LTk9XTlwiO1xyXG59KShleHBvcnRzLk5mdFRva2VuVHlwZSB8fCAoZXhwb3J0cy5OZnRUb2tlblR5cGUgPSB7fSkpO1xyXG4vKiogUG90ZW50aWFsIHJlYXNvbnMgd2h5IGFuIE5GVCBjb250cmFjdCB3YXMgY2xhc3NpZmllZCBhcyBzcGFtLiAqL1xyXG5leHBvcnRzLk5mdFNwYW1DbGFzc2lmaWNhdGlvbiA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChOZnRTcGFtQ2xhc3NpZmljYXRpb24pIHtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIkVyYzcyMVRvb01hbnlPd25lcnNcIl0gPSBcIkVyYzcyMVRvb01hbnlPd25lcnNcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIkVyYzcyMVRvb01hbnlUb2tlbnNcIl0gPSBcIkVyYzcyMVRvb01hbnlUb2tlbnNcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIkVyYzcyMURpc2hvbmVzdFRvdGFsU3VwcGx5XCJdID0gXCJFcmM3MjFEaXNob25lc3RUb3RhbFN1cHBseVwiO1xyXG4gICAgTmZ0U3BhbUNsYXNzaWZpY2F0aW9uW1wiTW9zdGx5SG9uZXlQb3RPd25lcnNcIl0gPSBcIk1vc3RseUhvbmV5UG90T3duZXJzXCI7XHJcbiAgICBOZnRTcGFtQ2xhc3NpZmljYXRpb25bXCJPd25lZEJ5TW9zdEhvbmV5UG90c1wiXSA9IFwiT3duZWRCeU1vc3RIb25leVBvdHNcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIkxvd0Rpc3RpbmN0T3duZXJzUGVyY2VudFwiXSA9IFwiTG93RGlzdGluY3RPd25lcnNQZXJjZW50XCI7XHJcbiAgICBOZnRTcGFtQ2xhc3NpZmljYXRpb25bXCJIaWdoSG9uZXlQb3RPd25lclBlcmNlbnRcIl0gPSBcIkhpZ2hIb25leVBvdE93bmVyUGVyY2VudFwiO1xyXG4gICAgTmZ0U3BhbUNsYXNzaWZpY2F0aW9uW1wiSGlnaEhvbmV5UG90UGVyY2VudFwiXSA9IFwiSGlnaEhvbmV5UG90UGVyY2VudFwiO1xyXG4gICAgTmZ0U3BhbUNsYXNzaWZpY2F0aW9uW1wiSG9uZXlQb3RzT3duTXVsdGlwbGVUb2tlbnNcIl0gPSBcIkhvbmV5UG90c093bk11bHRpcGxlVG9rZW5zXCI7XHJcbiAgICBOZnRTcGFtQ2xhc3NpZmljYXRpb25bXCJOb1NhbGVzQWN0aXZpdHlcIl0gPSBcIk5vU2FsZXNBY3Rpdml0eVwiO1xyXG4gICAgTmZ0U3BhbUNsYXNzaWZpY2F0aW9uW1wiSGlnaEFpcmRyb3BQZXJjZW50XCJdID0gXCJIaWdoQWlyZHJvcFBlcmNlbnRcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIlVua25vd25cIl0gPSBcIlVua25vd25cIjtcclxufSkoZXhwb3J0cy5OZnRTcGFtQ2xhc3NpZmljYXRpb24gfHwgKGV4cG9ydHMuTmZ0U3BhbUNsYXNzaWZpY2F0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gb2YgTkZUIGZpbHRlcnMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBhIHtAbGluayBnZXROZnRzRm9yT3duZXJ9IG9yIGFcclxuICoge0BsaW5rIGdldENvbnRyYWN0c0Zvck93bmVyfSByZXF1ZXN0LlxyXG4gKlxyXG4gKiBAYmV0YVxyXG4gKi9cclxuZXhwb3J0cy5OZnRGaWx0ZXJzID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKE5mdEZpbHRlcnMpIHtcclxuICAgIC8qKiBORlRzIHRoYXQgaGF2ZSBiZWVuIGNsYXNzaWZpZWQgYXMgc3BhbS4gKi9cclxuICAgIE5mdEZpbHRlcnNbXCJTUEFNXCJdID0gXCJTUEFNXCI7XHJcbiAgICAvKiogTkZUcyB0aGF0IGhhdmUgYmVlbiBhaXJkcm9wcGVkIHRvIGEgdXNlci4gKi9cclxuICAgIE5mdEZpbHRlcnNbXCJBSVJEUk9QU1wiXSA9IFwiQUlSRFJPUFNcIjtcclxufSkoZXhwb3J0cy5OZnRGaWx0ZXJzIHx8IChleHBvcnRzLk5mdEZpbHRlcnMgPSB7fSkpO1xyXG4vKipcclxuICogRW51bSBvZiBvcmRlcmluZyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIGEge0BsaW5rIGdldE5mdHNGb3JPd25lcn0gb3IgYVxyXG4gKiB7QGxpbmsgZ2V0Q29udHJhY3RzRm9yT3duZXJ9IHJlc3BvbnNlLlxyXG4gKlxyXG4gKiBAYmV0YVxyXG4gKi9cclxuZXhwb3J0cy5OZnRPcmRlcmluZyA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChOZnRPcmRlcmluZykge1xyXG4gICAgTmZ0T3JkZXJpbmdbXCJUUkFOU0ZFUlRJTUVcIl0gPSBcIlRSQU5TRkVSVElNRVwiO1xyXG59KShleHBvcnRzLk5mdE9yZGVyaW5nIHx8IChleHBvcnRzLk5mdE9yZGVyaW5nID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBzdXBwb3J0ZWQgTkZUIG1hcmtldHBsYWNlcyBieSB0aGVcclxuICoge0BsaW5rIE5mdE5hbWVzcGFjZS5nZXROZnRTYWxlc30gbWV0aG9kLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChOZnRTYWxlTWFya2V0cGxhY2UpIHtcclxuICAgIE5mdFNhbGVNYXJrZXRwbGFjZVtcIlNFQVBPUlRcIl0gPSBcInNlYXBvcnRcIjtcclxuICAgIE5mdFNhbGVNYXJrZXRwbGFjZVtcIkxPT0tTUkFSRVwiXSA9IFwibG9va3NyYXJlXCI7XHJcbiAgICBOZnRTYWxlTWFya2V0cGxhY2VbXCJYMlkyXCJdID0gXCJ4MnkyXCI7XHJcbiAgICBOZnRTYWxlTWFya2V0cGxhY2VbXCJXWVZFUk5cIl0gPSBcInd5dmVyblwiO1xyXG4gICAgTmZ0U2FsZU1hcmtldHBsYWNlW1wiQ1JZUFRPUFVOS1NcIl0gPSBcImNyeXB0b3B1bmtzXCI7XHJcbiAgICBOZnRTYWxlTWFya2V0cGxhY2VbXCJCTFVSXCJdID0gXCJibHVyXCI7XHJcbiAgICBOZnRTYWxlTWFya2V0cGxhY2VbXCJVTktOT1dOXCJdID0gXCJ1bmtub3duXCI7XHJcbn0pKGV4cG9ydHMuTmZ0U2FsZU1hcmtldHBsYWNlIHx8IChleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbnVtIGZvciBzcGVjaWZ5aW5nIHRoZSB0YWtlciB0eXBlIGZvciB0aGUge0BsaW5rIE5mdE5hbWVzcGFjZS5nZXROZnRTYWxlc31cclxuICogbWV0aG9kLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLk5mdFNhbGVUYWtlclR5cGUgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoTmZ0U2FsZVRha2VyVHlwZSkge1xyXG4gICAgTmZ0U2FsZVRha2VyVHlwZVtcIkJVWUVSXCJdID0gXCJidXllclwiO1xyXG4gICAgTmZ0U2FsZVRha2VyVHlwZVtcIlNFTExFUlwiXSA9IFwic2VsbGVyXCI7XHJcbn0pKGV4cG9ydHMuTmZ0U2FsZVRha2VyVHlwZSB8fCAoZXhwb3J0cy5OZnRTYWxlVGFrZXJUeXBlID0ge30pKTtcclxuLyoqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBORlQgY29udHJhY3QgcmVmcmVzaCBwcm9jZXNzLiAqL1xyXG5leHBvcnRzLk5mdFJlZnJlc2hTdGF0ZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChOZnRSZWZyZXNoU3RhdGUpIHtcclxuICAgIC8qKiBUaGUgcHJvdmlkZWQgY29udHJhY3QgaXMgbm90IGFuIE5GVCBvciBkb2VzIG5vdCBjb250YWluIG1ldGFkYXRhLiAqL1xyXG4gICAgTmZ0UmVmcmVzaFN0YXRlW1wiRE9FU19OT1RfRVhJU1RcIl0gPSBcImRvZXNfbm90X2V4aXN0XCI7XHJcbiAgICAvKiogVGhlIGNvbnRyYWN0IGhhcyBhbHJlYWR5IGJlZW4gcXVldWVkIGZvciByZWZyZXNoLiAqL1xyXG4gICAgTmZ0UmVmcmVzaFN0YXRlW1wiQUxSRUFEWV9RVUVVRURcIl0gPSBcImFscmVhZHlfcXVldWVkXCI7XHJcbiAgICAvKiogVGhlIGNvbnRyYWN0IGlzIGN1cnJlbnRseSBiZWluZyByZWZyZXNoZWQuICovXHJcbiAgICBOZnRSZWZyZXNoU3RhdGVbXCJJTl9QUk9HUkVTU1wiXSA9IFwiaW5fcHJvZ3Jlc3NcIjtcclxuICAgIC8qKiBUaGUgY29udHJhY3QgcmVmcmVzaCBpcyBjb21wbGV0ZS4gKi9cclxuICAgIE5mdFJlZnJlc2hTdGF0ZVtcIkZJTklTSEVEXCJdID0gXCJmaW5pc2hlZFwiO1xyXG4gICAgLyoqIFRoZSBjb250cmFjdCByZWZyZXNoIGhhcyBiZWVuIHF1ZXVlZCBhbmQgYXdhaXQgZXhlY3V0aW9uLiAqL1xyXG4gICAgTmZ0UmVmcmVzaFN0YXRlW1wiUVVFVUVEXCJdID0gXCJxdWV1ZWRcIjtcclxuICAgIC8qKiBUaGUgY29udHJhY3Qgd2FzIHVuYWJsZSB0byBiZSBxdWV1ZWQgZHVlIHRvIGFuIGludGVybmFsIGVycm9yLiAqL1xyXG4gICAgTmZ0UmVmcmVzaFN0YXRlW1wiUVVFVUVfRkFJTEVEXCJdID0gXCJxdWV1ZV9mYWlsZWRcIjtcclxufSkoZXhwb3J0cy5OZnRSZWZyZXNoU3RhdGUgfHwgKGV4cG9ydHMuTmZ0UmVmcmVzaFN0YXRlID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBzdXBwb3J0ZWQgTkZUIG1hcmtldHBsYWNlcyBvbiBhXHJcbiAqIHtAbGluayBOZnRDb2xsZWN0aW9uRmxvb3JQcmljZX0gb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0cy5OZnRDb2xsZWN0aW9uTWFya2V0cGxhY2UgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlKSB7XHJcbiAgICBOZnRDb2xsZWN0aW9uTWFya2V0cGxhY2VbXCJPUEVOU0VBXCJdID0gXCJPcGVuU2VhXCI7XHJcbn0pKGV4cG9ydHMuTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlIHx8IChleHBvcnRzLk5mdENvbGxlY3Rpb25NYXJrZXRwbGFjZSA9IHt9KSk7XG5cbi8qKlxyXG4gKiBWYWxpZCB0aW1lIGludGVydmFscyBmb3IgaGlzdG9yaWNhbCBwcmljZSBkYXRhLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLkhpc3RvcmljYWxQcmljZUludGVydmFsID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKEhpc3RvcmljYWxQcmljZUludGVydmFsKSB7XHJcbiAgICAvKiogNS1taW51dGUgaW50ZXJ2YWxzICovXHJcbiAgICBIaXN0b3JpY2FsUHJpY2VJbnRlcnZhbFtcIkZJVkVfTUlOVVRFXCJdID0gXCI1bVwiO1xyXG4gICAgLyoqIDEtaG91ciBpbnRlcnZhbHMgKi9cclxuICAgIEhpc3RvcmljYWxQcmljZUludGVydmFsW1wiT05FX0hPVVJcIl0gPSBcIjFoXCI7XHJcbiAgICAvKiogMS1kYXkgaW50ZXJ2YWxzICovXHJcbiAgICBIaXN0b3JpY2FsUHJpY2VJbnRlcnZhbFtcIk9ORV9EQVlcIl0gPSBcIjFkXCI7XHJcbn0pKGV4cG9ydHMuSGlzdG9yaWNhbFByaWNlSW50ZXJ2YWwgfHwgKGV4cG9ydHMuSGlzdG9yaWNhbFByaWNlSW50ZXJ2YWwgPSB7fSkpO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyJDEodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxuXG5jb25zdCBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSA9ICdkZW1vJztcclxuY29uc3QgREVGQVVMVF9ORVRXT1JLID0gZXhwb3J0cy5OZXR3b3JrLkVUSF9NQUlOTkVUO1xyXG5jb25zdCBERUZBVUxUX01BWF9SRVRSSUVTID0gNTtcclxuY29uc3QgREVGQVVMVF9SRVFVRVNUX1RJTUVPVVQgPSAwOyAvLyAwID0gbm8gdGltZW91dFxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYmFzZSBVUkwgZm9yIG1ha2luZyBBbGNoZW15IEFQSSByZXF1ZXN0cy4gVGhlIGBhbGNoZW15LmNvbWBcclxuICogZW5kcG9pbnRzIG9ubHkgd29yayB3aXRoIG5vbiBldGgganNvbi1ycGMgcmVxdWVzdHMuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWxjaGVteUh0dHBVcmwobmV0d29yaywgYXBpS2V5KSB7XHJcbiAgICByZXR1cm4gYGh0dHBzOi8vJHtuZXR3b3JrfS5nLmFsY2hlbXkuY29tL3YyLyR7YXBpS2V5fWA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWxjaGVteU5mdEh0dHBVcmwobmV0d29yaywgYXBpS2V5KSB7XHJcbiAgICByZXR1cm4gYGh0dHBzOi8vJHtuZXR3b3JrfS5nLmFsY2hlbXkuY29tL25mdC92My8ke2FwaUtleX1gO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFsY2hlbXlXc1VybChuZXR3b3JrLCBhcGlLZXkpIHtcclxuICAgIHJldHVybiBgd3NzOi8vJHtuZXR3b3JrfS5nLmFsY2hlbXkuY29tL3YyLyR7YXBpS2V5fWA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWxjaGVteVdlYmhvb2tIdHRwVXJsKCkge1xyXG4gICAgcmV0dXJuICdodHRwczovL2Rhc2hib2FyZC5hbGNoZW15LmNvbS9hcGknO1xyXG59XHJcbmZ1bmN0aW9uIGdldFByaWNlc0Jhc2VVcmwoYXBpS2V5KSB7XHJcbiAgICByZXR1cm4gYGh0dHBzOi8vYXBpLmcuYWxjaGVteS5jb20vcHJpY2VzL3YxLyR7YXBpS2V5fWA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGF0YUJhc2VVcmwoYXBpS2V5KSB7XHJcbiAgICByZXR1cm4gYGh0dHBzOi8vYXBpLmcuYWxjaGVteS5jb20vZGF0YS92MS8ke2FwaUtleX1gO1xyXG59XHJcbnZhciBBbGNoZW15QXBpVHlwZTtcclxuKGZ1bmN0aW9uIChBbGNoZW15QXBpVHlwZSkge1xyXG4gICAgQWxjaGVteUFwaVR5cGVbQWxjaGVteUFwaVR5cGVbXCJCQVNFXCJdID0gMF0gPSBcIkJBU0VcIjtcclxuICAgIEFsY2hlbXlBcGlUeXBlW0FsY2hlbXlBcGlUeXBlW1wiTkZUXCJdID0gMV0gPSBcIk5GVFwiO1xyXG4gICAgQWxjaGVteUFwaVR5cGVbQWxjaGVteUFwaVR5cGVbXCJXRUJIT09LXCJdID0gMl0gPSBcIldFQkhPT0tcIjtcclxuICAgIEFsY2hlbXlBcGlUeXBlW0FsY2hlbXlBcGlUeXBlW1wiUFJJQ0VTXCJdID0gM10gPSBcIlBSSUNFU1wiO1xyXG4gICAgQWxjaGVteUFwaVR5cGVbQWxjaGVteUFwaVR5cGVbXCJQT1JURk9MSU9cIl0gPSA0XSA9IFwiUE9SVEZPTElPXCI7XHJcbn0pKEFsY2hlbXlBcGlUeXBlIHx8IChBbGNoZW15QXBpVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBNYXBwaW5nIG9mIG5ldHdvcmsgbmFtZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBOZXR3b3JrIHN0cmluZ3MgdXNlZCB0b1xyXG4gKiBjcmVhdGUgYW4gRXRoZXJzLmpzIFByb3ZpZGVyIGluc3RhbmNlLlxyXG4gKi9cclxuY29uc3QgRXRoZXJzTmV0d29yayA9IHtcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuRVRIX01BSU5ORVRdOiAnbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkVUSF9HT0VSTEldOiAnZ29lcmxpJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuRVRIX1NFUE9MSUFdOiAnc2Vwb2xpYScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkVUSF9IT0xFU0tZXTogJ2hvbGVza3knLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5FVEhfSE9PREldOiAnaG9vZGknLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5PUFRfTUFJTk5FVF06ICdvcHQtbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLk9QVF9HT0VSTEldOiAnb3B0aW1pc20tZ29lcmxpJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuT1BUX1NFUE9MSUFdOiAnb3B0aW1pc20tc2Vwb2xpYScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkFSQl9NQUlOTkVUXTogJ2FyYml0cnVtJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQVJCX0dPRVJMSV06ICdhcmJpdHJ1bS1nb2VybGknLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5BUkJfU0VQT0xJQV06ICdhcmJpdHJ1bS1zZXBvbGlhJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuTUFUSUNfTUFJTk5FVF06ICdtYXRpYycsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLk1BVElDX01VTUJBSV06ICdtYXRpY211bScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLk1BVElDX0FNT1ldOiAnbWF0aWNhbW95JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuU09MQU5BX01BSU5ORVRdOiBudWxsLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5TT0xBTkFfREVWTkVUXTogbnVsbCxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQVNUQVJfTUFJTk5FVF06ICdhc3Rhci1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuUE9MWUdPTlpLRVZNX01BSU5ORVRdOiAncG9seWdvbnprZXZtLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5QT0xZR09OWktFVk1fVEVTVE5FVF06ICdwb2x5Z29uemtldm0tdGVzdG5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLlBPTFlHT05aS0VWTV9DQVJET05BXTogJ3BvbHlnb256a2V2bS1jYXJkb25hJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQkFTRV9NQUlOTkVUXTogJ2Jhc2UtbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkJBU0VfR09FUkxJXTogJ2Jhc2UtZ29lcmxpJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQkFTRV9TRVBPTElBXTogJ2Jhc2Utc2Vwb2xpYScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLlpLU1lOQ19NQUlOTkVUXTogJ3prc3luYy1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuWktTWU5DX1NFUE9MSUFdOiAnemtzeW5jLXNlcG9saWEnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5TSEFQRV9NQUlOTkVUXTogJ3NoYXBlLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5TSEFQRV9TRVBPTElBXTogJ3NoYXBlLXNlcG9saWEnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5MSU5FQV9NQUlOTkVUXTogJ2xpbmVhLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5MSU5FQV9TRVBPTElBXTogJ2xpbmVhLXNlcG9saWEnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5GQU5UT01fTUFJTk5FVF06ICdmYW50b20tbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkZBTlRPTV9URVNUTkVUXTogJ2ZhbnRvbS10ZXN0bmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuWkVUQUNIQUlOX01BSU5ORVRdOiAnemV0YWNoYWluLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5aRVRBQ0hBSU5fVEVTVE5FVF06ICd6ZXRhY2hhaW4tdGVzdG5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkFSQk5PVkFfTUFJTk5FVF06ICdhcmJub3ZhLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5CTEFTVF9NQUlOTkVUXTogJ2JsYXN0LW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5CTEFTVF9TRVBPTElBXTogJ2JsYXN0LXNlcG9saWEnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5NQU5UTEVfTUFJTk5FVF06ICdtYW50bGUtbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLk1BTlRMRV9TRVBPTElBXTogJ21hbnRsZS1zZXBvbGlhJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuU0NST0xMX01BSU5ORVRdOiAnc2Nyb2xsLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5TQ1JPTExfU0VQT0xJQV06ICdzY3JvbGwtc2Vwb2xpYScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkdOT1NJU19NQUlOTkVUXTogJ2dub3Npcy1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuR05PU0lTX0NISUFET106ICdnbm9zaXMtY2hpYWRvJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQk5CX01BSU5ORVRdOiAnYm5iLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5CTkJfVEVTVE5FVF06ICdibmItdGVzdG5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkFWQVhfTUFJTk5FVF06ICdhdmF4LW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5BVkFYX0ZVSkldOiAnYXZheC1mdWppJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQ0VMT19NQUlOTkVUXTogJ2NlbG8tbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkNFTE9fQUxGQUpPUkVTXTogJ2NlbG8tYWxmYWpvcmVzJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQ0VMT19CQUtMQVZBXTogJ2NlbG8tYmFrbGF2YScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLk1FVElTX01BSU5ORVRdOiAnbWV0aXMtbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLk9QQk5CX01BSU5ORVRdOiAnb3BibmItbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLk9QQk5CX1RFU1RORVRdOiAnb3BibmItdGVzdG5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkJFUkFDSEFJTl9CQVJUSU9dOiAnYmVyYWNoYWluLWJhcnRpbycsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkJFUkFDSEFJTl9NQUlOTkVUXTogJ2JlcmFjaGFpbi1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQkVSQUNIQUlOX0JFUE9MSUFdOiAnYmVyYWNoYWluLWJlcG9saWEnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5TT05FSVVNX01BSU5ORVRdOiAnc29uZWl1bS1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuU09ORUlVTV9NSU5BVE9dOiAnc29uZWl1bS1taW5hdG8nLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5XT1JMRENIQUlOX01BSU5ORVRdOiAnd29ybGRjaGFpbi1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuV09STERDSEFJTl9TRVBPTElBXTogJ3dvcmxkY2hhaW4tc2Vwb2xpYScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLlJPT1RTVE9DS19NQUlOTkVUXTogJ3Jvb3RzdG9jay1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuUk9PVFNUT0NLX1RFU1RORVRdOiAncm9vdHN0b2NrLXRlc3RuZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5GTE9XX01BSU5ORVRdOiAnZmxvdy1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuRkxPV19URVNUTkVUXTogJ2Zsb3ctdGVzdG5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLlpPUkFfTUFJTk5FVF06ICd6b3JhLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5aT1JBX1NFUE9MSUFdOiAnem9yYS1zZXBvbGlhJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuRlJBWF9NQUlOTkVUXTogJ2ZyYXgtbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkZSQVhfU0VQT0xJQV06ICdmcmF4LXNlcG9saWEnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5QT0xZTk9NSUFMX01BSU5ORVRdOiAncG9seW5vbWlhbC1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuUE9MWU5PTUlBTF9TRVBPTElBXTogJ3BvbHlub21pYWwtc2Vwb2xpYScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkNST1NTRklfTUFJTk5FVF06ICdjcm9zc2ZpLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5DUk9TU0ZJX1RFU1RORVRdOiAnY3Jvc3NmaS10ZXN0bmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQVBFQ0hBSU5fTUFJTk5FVF06ICdhcGVjaGFpbi1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQVBFQ0hBSU5fQ1VSVElTXTogJ2FwZWNoYWluLWN1cnRpcycsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkxFTlNfTUFJTk5FVF06ICdsZW5zLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5MRU5TX1NFUE9MSUFdOiAnbGVucy1zZXBvbGlhJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuR0VJU1RfTUFJTk5FVF06ICdnZWlzdC1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuR0VJU1RfUE9MVEVSXTogJ2dlaXN0LXBvbHRlcicsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkxVTUlBX1BSSVNNXTogJ2x1bWlhLXByaXNtJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuTFVNSUFfVEVTVE5FVF06ICdsdW1pYS10ZXN0bmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuVU5JQ0hBSU5fTUFJTk5FVF06ICd1bmljaGFpbi1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuVU5JQ0hBSU5fU0VQT0xJQV06ICd1bmljaGFpbi1zZXBvbGlhJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuU09OSUNfTUFJTk5FVF06ICdzb25pYy1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuU09OSUNfQkxBWkVdOiAnc29uaWMtYmxhemUnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5YTVRQX1RFU1RORVRdOiAneG10cC10ZXN0bmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQUJTVFJBQ1RfTUFJTk5FVF06ICdhYnN0cmFjdC1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQUJTVFJBQ1RfVEVTVE5FVF06ICdhYnN0cmFjdC10ZXN0bmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuREVHRU5fTUFJTk5FVF06ICdkZWdlbi1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuSU5LX01BSU5ORVRdOiAnaW5rLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5JTktfU0VQT0xJQV06ICdpbmstc2Vwb2xpYScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLlNFSV9NQUlOTkVUXTogJ3NlaS1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuU0VJX1RFU1RORVRdOiAnc2VpLXRlc3RuZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5ST05JTl9NQUlOTkVUXTogJ3JvbmluLW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5ST05JTl9TQUlHT05dOiAncm9uaW4tc2FpZ29uJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuTU9OQURfVEVTVE5FVF06ICdtb25hZC10ZXN0bmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuU0VUVExVU19NQUlOTkVUXTogJ3NldHRsdXMtbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLlNFVFRMVVNfU0VQVEVTVE5FVF06ICdzZXR0bHVzLXNlcHRlc3RuZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5HRU5TWU5fVEVTVE5FVF06ICdnZW5zeW4tdGVzdG5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLlNVUEVSU0VFRF9NQUlOTkVUXTogJ3N1cGVyc2VlZC1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuU1VQRVJTRUVEX1NFUE9MSUFdOiAnc3VwZXJzZWVkLXNlcG9saWEnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5URUFfU0VQT0xJQV06ICd0ZWEtc2Vwb2xpYScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkFOSU1FX01BSU5ORVRdOiAnYW5pbWUtbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkFOSU1FX1NFUE9MSUFdOiAnYW5pbWUtc2Vwb2xpYScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLlNUT1JZX01BSU5ORVRdOiAnc3RvcnktbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLlNUT1JZX0FFTkVJRF06ICdzdG9yeS1hZW5laWQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5NRUdBRVRIX1RFU1RORVRdOiAnbWVnYWV0aC10ZXN0bmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQk9UQU5JWF9NQUlOTkVUXTogJ2JvdGFuaXgtbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkJPVEFOSVhfVEVTVE5FVF06ICdib3Rhbml4LXRlc3RuZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5IVU1BTklUWV9NQUlOTkVUXTogJ2h1bWFuaXR5LW1haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5SSVNFX1RFU1RORVRdOiAncmlzZS10ZXN0bmV0J1xyXG59O1xyXG4vKipcclxuICogTWFwcGluZyBvZiBuZXR3b3JrIG5hbWVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgRXRoZXJzIE5ldHdvcmsgb2JqZWN0cy4gVGhlc2VcclxuICogbmV0d29ya3MgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGJ5IEV0aGVycyBhbmQgYXJlIGxpc3RlZCBoZXJlIHRvIGJlIG92ZXJyaWRlblxyXG4gKiBpbiB0aGUgcHJvdmlkZXIuXHJcbiAqL1xyXG5jb25zdCBDdXN0b21OZXR3b3JrcyA9IHtcclxuICAgICdhcmJpdHJ1bS1nb2VybGknOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNDIxNjEzLFxyXG4gICAgICAgIG5hbWU6ICdhcmJpdHJ1bS1nb2VybGknXHJcbiAgICB9LFxyXG4gICAgJ2FyYml0cnVtLXNlcG9saWEnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNDIxNjE0LFxyXG4gICAgICAgIG5hbWU6ICdhcmJpdHJ1bS1zZXBvbGlhJ1xyXG4gICAgfSxcclxuICAgICdhc3Rhci1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDU5MixcclxuICAgICAgICBuYW1lOiAnYXN0YXItbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICBzZXBvbGlhOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMTExNTUxMTEsXHJcbiAgICAgICAgbmFtZTogJ3NlcG9saWEnXHJcbiAgICB9LFxyXG4gICAgaG9sZXNreToge1xyXG4gICAgICAgIGNoYWluSWQ6IDE3MDAwLFxyXG4gICAgICAgIG5hbWU6ICdob2xlc2t5J1xyXG4gICAgfSxcclxuICAgIGhvb2RpOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNTYwMDQ4LFxyXG4gICAgICAgIG5hbWU6ICdob29kaSdcclxuICAgIH0sXHJcbiAgICAnb3B0LW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMTAsXHJcbiAgICAgICAgbmFtZTogJ29wdC1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdvcHRpbWlzbS1zZXBvbGlhJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDExMTU1NDIwLFxyXG4gICAgICAgIG5hbWU6ICdvcHRpbWlzbS1zZXBvbGlhJ1xyXG4gICAgfSxcclxuICAgICdwb2x5Z29uemtldm0tbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAxMTAxLFxyXG4gICAgICAgIG5hbWU6ICdwb2x5Z29uemtldm0tbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAncG9seWdvbnprZXZtLXRlc3RuZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMTQ0MixcclxuICAgICAgICBuYW1lOiAncG9seWdvbnprZXZtLXRlc3RuZXQnXHJcbiAgICB9LFxyXG4gICAgJ3BvbHlnb256a2V2bS1jYXJkb25hJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDI0NDIsXHJcbiAgICAgICAgbmFtZTogJ3BvbHlnb256a2V2bS1jYXJkb25hJ1xyXG4gICAgfSxcclxuICAgICdiYXNlLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogODQ1MyxcclxuICAgICAgICBuYW1lOiAnYmFzZS1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdiYXNlLWdvZXJsaSc6IHtcclxuICAgICAgICBjaGFpbklkOiA4NDUzMSxcclxuICAgICAgICBuYW1lOiAnYmFzZS1nb2VybGknXHJcbiAgICB9LFxyXG4gICAgJ2Jhc2Utc2Vwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiA4NDUzMixcclxuICAgICAgICBuYW1lOiAnYmFzZS1zZXBvbGlhJ1xyXG4gICAgfSxcclxuICAgIG1hdGljYW1veToge1xyXG4gICAgICAgIGNoYWluSWQ6IDgwMDAyLFxyXG4gICAgICAgIG5hbWU6ICdtYXRpY2Ftb3knXHJcbiAgICB9LFxyXG4gICAgJ3prc3luYy1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDMyNCxcclxuICAgICAgICBuYW1lOiAnemtzeW5jLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ3prc3luYy1zZXBvbGlhJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDMwMCxcclxuICAgICAgICBuYW1lOiAnemtzeW5jLXNlcG9saWEnXHJcbiAgICB9LFxyXG4gICAgJ3NoYXBlLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMzYwLFxyXG4gICAgICAgIG5hbWU6ICdzaGFwZS1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdzaGFwZS1zZXBvbGlhJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDExMDExLFxyXG4gICAgICAgIG5hbWU6ICdzaGFwZS1zZXBvbGlhJ1xyXG4gICAgfSxcclxuICAgICdsaW5lYS1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDU5MTQ0LFxyXG4gICAgICAgIG5hbWU6ICdsaW5lYS1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdsaW5lYS1zZXBvbGlhJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDU5MTQxLFxyXG4gICAgICAgIG5hbWU6ICdsaW5lYS1zZXBvbGlhJ1xyXG4gICAgfSxcclxuICAgICdmYW50b20tbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAyNTAsXHJcbiAgICAgICAgbmFtZTogJ2ZhbnRvbS1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdmYW50b20tdGVzdG5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA0MDAyLFxyXG4gICAgICAgIG5hbWU6ICdmYW50b20tdGVzdG5ldCdcclxuICAgIH0sXHJcbiAgICAnemV0YWNoYWluLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNzAwMCxcclxuICAgICAgICBuYW1lOiAnemV0YWNoYWluLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ3pldGFjaGFpbi10ZXN0bmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDcwMDEsXHJcbiAgICAgICAgbmFtZTogJ3pldGFjaGFpbi10ZXN0bmV0J1xyXG4gICAgfSxcclxuICAgICdhcmJub3ZhLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNDIxNzAsXHJcbiAgICAgICAgbmFtZTogJ2FyYm5vdmEtbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAnYmxhc3QtbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA4MTQ1NyxcclxuICAgICAgICBuYW1lOiAnYmxhc3QtbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAnYmxhc3Qtc2Vwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiAxNjg1ODc3NzMsXHJcbiAgICAgICAgbmFtZTogJ2JsYXN0LXNlcG9saWEnXHJcbiAgICB9LFxyXG4gICAgJ21hbnRsZS1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDUwMDAsXHJcbiAgICAgICAgbmFtZTogJ21hbnRsZS1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdtYW50bGUtc2Vwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiA1MDAzLFxyXG4gICAgICAgIG5hbWU6ICdtYW50bGUtc2Vwb2xpYSdcclxuICAgIH0sXHJcbiAgICAnc2Nyb2xsLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNTM0MzUyLFxyXG4gICAgICAgIG5hbWU6ICdzY3JvbGwtbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAnc2Nyb2xsLXNlcG9saWEnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNTM0MzUxLFxyXG4gICAgICAgIG5hbWU6ICdzY3JvbGwtc2Vwb2xpYSdcclxuICAgIH0sXHJcbiAgICAnZ25vc2lzLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMTAwLFxyXG4gICAgICAgIG5hbWU6ICdnbm9zaXMtbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAnZ25vc2lzLWNoaWFkbyc6IHtcclxuICAgICAgICBjaGFpbklkOiAxMDIwMCxcclxuICAgICAgICBuYW1lOiAnZ25vc2lzLWNoaWFkbydcclxuICAgIH0sXHJcbiAgICAnYm5iLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNTYsXHJcbiAgICAgICAgbmFtZTogJ2JuYi1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdibmItdGVzdG5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA5NyxcclxuICAgICAgICBuYW1lOiAnYm5iLXRlc3RuZXQnXHJcbiAgICB9LFxyXG4gICAgJ2F2YXgtbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA0MzExNCxcclxuICAgICAgICBuYW1lOiAnYXZheC1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdhdmF4LWZ1amknOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNDMxMTMsXHJcbiAgICAgICAgbmFtZTogJ2F2YXgtZnVqaSdcclxuICAgIH0sXHJcbiAgICAnY2Vsby1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDQyMjIwLFxyXG4gICAgICAgIG5hbWU6ICdjZWxvLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ2NlbG8tYWxmYWpvcmVzJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDQ0Nzg3LFxyXG4gICAgICAgIG5hbWU6ICdjZWxvLWFsZmFqb3JlcydcclxuICAgIH0sXHJcbiAgICAnY2Vsby1iYWtsYXZhJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDYyMzIwLFxyXG4gICAgICAgIG5hbWU6ICdjZWxvLWJha2xhdmEnXHJcbiAgICB9LFxyXG4gICAgJ21ldGlzLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMTA4OCxcclxuICAgICAgICBuYW1lOiAnbWV0aXMtbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAnb3BibmItbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAyMDQsXHJcbiAgICAgICAgbmFtZTogJ29wYm5iLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ29wYm5iLXRlc3RuZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNTYxMSxcclxuICAgICAgICBuYW1lOiAnb3BibmItdGVzdG5ldCdcclxuICAgIH0sXHJcbiAgICAnYmVyYWNoYWluLWJhcnRpbyc6IHtcclxuICAgICAgICBjaGFpbklkOiA4MDA4NCxcclxuICAgICAgICBuYW1lOiAnYmVyYWNoYWluLWJhcnRpbydcclxuICAgIH0sXHJcbiAgICAnYmVyYWNoYWluLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogODAwOTQsXHJcbiAgICAgICAgbmFtZTogJ2JlcmFjaGFpbi1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdiZXJhY2hhaW4tYmVwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiA4MDA2OSxcclxuICAgICAgICBuYW1lOiAnYmVyYWNoYWluLWJlcG9saWEnXHJcbiAgICB9LFxyXG4gICAgJ3NvbmVpdW0tbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAxODY4LFxyXG4gICAgICAgIG5hbWU6ICdzb25laXVtLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ3NvbmVpdW0tbWluYXRvJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDB4NzlhLFxyXG4gICAgICAgIG5hbWU6ICdzb25laXVtLW1pbmF0bydcclxuICAgIH0sXHJcbiAgICAnd29ybGRjaGFpbi1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDB4MWUwLFxyXG4gICAgICAgIG5hbWU6ICd3b3JsZGNoYWluLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ3dvcmxkY2hhaW4tc2Vwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiAweDEyYzEsXHJcbiAgICAgICAgbmFtZTogJ3dvcmxkY2hhaW4tc2Vwb2xpYSdcclxuICAgIH0sXHJcbiAgICAncm9vdHN0b2NrLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMHgxZSxcclxuICAgICAgICBuYW1lOiAncm9vdHN0b2NrLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ3Jvb3RzdG9jay10ZXN0bmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDB4MWYsXHJcbiAgICAgICAgbmFtZTogJ3Jvb3RzdG9jay10ZXN0bmV0J1xyXG4gICAgfSxcclxuICAgICdmbG93LW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNzQ3LFxyXG4gICAgICAgIG5hbWU6ICdmbG93LW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ2Zsb3ctdGVzdG5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA1NDUsXHJcbiAgICAgICAgbmFtZTogJ2Zsb3ctdGVzdG5ldCdcclxuICAgIH0sXHJcbiAgICAnem9yYS1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDc3Nzc3NzcsXHJcbiAgICAgICAgbmFtZTogJ3pvcmEtbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAnem9yYS1zZXBvbGlhJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDk5OTk5OTk5OSxcclxuICAgICAgICBuYW1lOiAnem9yYS1zZXBvbGlhJ1xyXG4gICAgfSxcclxuICAgICdmcmF4LW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMjUyLFxyXG4gICAgICAgIG5hbWU6ICdmcmF4LW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ2ZyYXgtc2Vwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiAyNTIyLFxyXG4gICAgICAgIG5hbWU6ICdmcmF4LXNlcG9saWEnXHJcbiAgICB9LFxyXG4gICAgJ3BvbHlub21pYWwtbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA4MDA4LFxyXG4gICAgICAgIG5hbWU6ICdwb2x5bm9taWFsLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ3BvbHlub21pYWwtc2Vwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiA4MDA5LFxyXG4gICAgICAgIG5hbWU6ICdwb2x5bm9taWFsLXNlcG9saWEnXHJcbiAgICB9LFxyXG4gICAgJ2Nyb3NzZmktbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA0MTU4LFxyXG4gICAgICAgIG5hbWU6ICdjcm9zc2ZpLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ2Nyb3NzZmktdGVzdG5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA0MTU3LFxyXG4gICAgICAgIG5hbWU6ICdjcm9zc2ZpLXRlc3RuZXQnXHJcbiAgICB9LFxyXG4gICAgJ2FwZWNoYWluLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMzMxMzksXHJcbiAgICAgICAgbmFtZTogJ2FwZWNoYWluLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ2FwZWNoYWluLWN1cnRpcyc6IHtcclxuICAgICAgICBjaGFpbklkOiAzMzExMSxcclxuICAgICAgICBuYW1lOiAnYXBlY2hhaW4tY3VydGlzJ1xyXG4gICAgfSxcclxuICAgICdsZW5zLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMjMyLFxyXG4gICAgICAgIG5hbWU6ICdsZW5zLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ2xlbnMtc2Vwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiAweDkwZjcsXHJcbiAgICAgICAgbmFtZTogJ2xlbnMtc2Vwb2xpYSdcclxuICAgIH0sXHJcbiAgICAnZ2Vpc3QtbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA2MzE1NyxcclxuICAgICAgICBuYW1lOiAnZ2Vpc3QtbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAnZ2Vpc3QtcG9sdGVyJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDYzMTU3MSxcclxuICAgICAgICBuYW1lOiAnZ2Vpc3QtcG9sdGVyJ1xyXG4gICAgfSxcclxuICAgICdsdW1pYS1wcmlzbSc6IHtcclxuICAgICAgICBjaGFpbklkOiAweDNiNGM4ZWI5LFxyXG4gICAgICAgIG5hbWU6ICdsdW1pYS1wcmlzbSdcclxuICAgIH0sXHJcbiAgICAnbHVtaWEtdGVzdG5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAweDc0NjdjYmY4LFxyXG4gICAgICAgIG5hbWU6ICdsdW1pYS10ZXN0bmV0J1xyXG4gICAgfSxcclxuICAgICd1bmljaGFpbi1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDEzMCxcclxuICAgICAgICBuYW1lOiAndW5pY2hhaW4tbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAndW5pY2hhaW4tc2Vwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiAweDUxNSxcclxuICAgICAgICBuYW1lOiAndW5pY2hhaW4tc2Vwb2xpYSdcclxuICAgIH0sXHJcbiAgICAnc29uaWMtbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAweDkyLFxyXG4gICAgICAgIG5hbWU6ICdzb25pYy1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdzb25pYy1ibGF6ZSc6IHtcclxuICAgICAgICBjaGFpbklkOiAweGRlZGUsXHJcbiAgICAgICAgbmFtZTogJ3NvbmljLWJsYXplJ1xyXG4gICAgfSxcclxuICAgICd4bXRwLXRlc3RuZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMjQxMzIwMTYxLFxyXG4gICAgICAgIG5hbWU6ICd4bXRwLXRlc3RuZXQnXHJcbiAgICB9LFxyXG4gICAgJ2Fic3RyYWN0LW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMjc0MSxcclxuICAgICAgICBuYW1lOiAnYWJzdHJhY3QtbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAnYWJzdHJhY3QtdGVzdG5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAxMTEyNCxcclxuICAgICAgICBuYW1lOiAnYWJzdHJhY3QtdGVzdG5ldCdcclxuICAgIH0sXHJcbiAgICAnZGVnZW4tbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAweDI3YmM4NmFhLFxyXG4gICAgICAgIG5hbWU6ICdkZWdlbi1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdpbmstbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAweGRlZjEsXHJcbiAgICAgICAgbmFtZTogJ2luay1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdpbmstc2Vwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiAweGJhNWVkLFxyXG4gICAgICAgIG5hbWU6ICdpbmstc2Vwb2xpYSdcclxuICAgIH0sXHJcbiAgICAnc2VpLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMTMyOSxcclxuICAgICAgICBuYW1lOiAnc2VpLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ3NlaS10ZXN0bmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDEzMjgsXHJcbiAgICAgICAgbmFtZTogJ3NlaS10ZXN0bmV0J1xyXG4gICAgfSxcclxuICAgICdyb25pbi1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDIwMjAsXHJcbiAgICAgICAgbmFtZTogJ3JvbmluLW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ3JvbmluLXNhaWdvbic6IHtcclxuICAgICAgICBjaGFpbklkOiAyMDIxLFxyXG4gICAgICAgIG5hbWU6ICdyb25pbi1zYWlnb24nXHJcbiAgICB9LFxyXG4gICAgJ21vbmFkLXRlc3RuZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMHgyNzlmLFxyXG4gICAgICAgIG5hbWU6ICdtb25hZC10ZXN0bmV0J1xyXG4gICAgfSxcclxuICAgICdzZXR0bHVzLW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNTM3MSxcclxuICAgICAgICBuYW1lOiAnc2V0dGx1cy1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdzZXR0bHVzLXNlcHRlc3RuZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMHgxNGZkLFxyXG4gICAgICAgIG5hbWU6ICdzZXR0bHVzLXNlcHRlc3RuZXQnXHJcbiAgICB9LFxyXG4gICAgJ2dlbnN5bi10ZXN0bmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDY4NTY4NSxcclxuICAgICAgICBuYW1lOiAnZ2Vuc3luLXRlc3RuZXQnXHJcbiAgICB9LFxyXG4gICAgJ3N1cGVyc2VlZC1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDUzMzAsXHJcbiAgICAgICAgbmFtZTogJ3N1cGVyc2VlZC1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdzdXBlcnNlZWQtc2Vwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiA1MzMwMixcclxuICAgICAgICBuYW1lOiAnc3VwZXJzZWVkLXNlcG9saWEnXHJcbiAgICB9LFxyXG4gICAgJ3RlYS1zZXBvbGlhJzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDEwMjE4LFxyXG4gICAgICAgIG5hbWU6ICd0ZWEtc2Vwb2xpYSdcclxuICAgIH0sXHJcbiAgICAnYW5pbWUtbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiA2OTAwMCxcclxuICAgICAgICBuYW1lOiAnYW5pbWUtbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAnYW5pbWUtc2Vwb2xpYSc6IHtcclxuICAgICAgICBjaGFpbklkOiAweDFhZjQsXHJcbiAgICAgICAgbmFtZTogJ2FuaW1lLXNlcG9saWEnXHJcbiAgICB9LFxyXG4gICAgJ3N0b3J5LW1haW5uZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMHg1ZWEsXHJcbiAgICAgICAgbmFtZTogJ3N0b3J5LW1haW5uZXQnXHJcbiAgICB9LFxyXG4gICAgJ3N0b3J5LWFlbmVpZCc6IHtcclxuICAgICAgICBjaGFpbklkOiAweDUyMyxcclxuICAgICAgICBuYW1lOiAnc3RvcnktYWVuZWlkJ1xyXG4gICAgfSxcclxuICAgICdtZWdhZXRoLXRlc3RuZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMHgxOGM2LFxyXG4gICAgICAgIG5hbWU6ICdtZWdhZXRoLXRlc3RuZXQnXHJcbiAgICB9LFxyXG4gICAgJ2JvdGFuaXgtbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAweGUzNCxcclxuICAgICAgICBuYW1lOiAnYm90YW5peC1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdib3Rhbml4LXRlc3RuZXQnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMHhlMzUsXHJcbiAgICAgICAgbmFtZTogJ2JvdGFuaXgtdGVzdG5ldCdcclxuICAgIH0sXHJcbiAgICAnaHVtYW5pdHktbWFpbm5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAweDZhOTZhOSxcclxuICAgICAgICBuYW1lOiAnaHVtYW5pdHktbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAncmlzZS10ZXN0bmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDB4YWEzOWRiLFxyXG4gICAgICAgIG5hbWU6ICdyaXNlLXRlc3RuZXQnXHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIG5vb3AoKSB7XHJcbiAgICAvLyBJdCdzIGEgbm8tb3BcclxufVxyXG5jb25zdCBFVEhfTlVMTF9WQUxVRSA9ICcweCc7XHJcbmNvbnN0IEVUSF9OVUxMX0FERFJFU1MgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcblxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaG9sZHMgdGhlIGNvbmZpZyBpbmZvcm1hdGlvbiBmb3IgdGhlIFNESyBjbGllbnQgaW5zdGFuY2UgYW5kXHJcbiAqIGV4cG9zZXMgdGhlIHVuZGVybHlpbmcgcHJvdmlkZXJzIGZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlcy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQWxjaGVteUNvbmZpZyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmFwaUtleSA9IChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXBpS2V5KSB8fCBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWTtcclxuICAgICAgICB0aGlzLm5ldHdvcmsgPSAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLm5ldHdvcmspIHx8IERFRkFVTFRfTkVUV09SSztcclxuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLm1heFJldHJpZXMpIHx8IERFRkFVTFRfTUFYX1JFVFJJRVM7XHJcbiAgICAgICAgdGhpcy51cmwgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudXJsO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dGhUb2tlbjtcclxuICAgICAgICB0aGlzLmJhdGNoUmVxdWVzdHMgPSAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmJhdGNoUmVxdWVzdHMpIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnJlcXVlc3RUaW1lb3V0KSB8fCBERUZBVUxUX1JFUVVFU1RfVElNRU9VVDtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25JbmZvT3ZlcnJpZGVzID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmNvbm5lY3Rpb25JbmZvT3ZlcnJpZGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBVUkwgZW5kcG9pbnQgdG8gc2VuZCB0aGUgSFRUUCByZXF1ZXN0IHRvLiBJZiBhIGN1c3RvbSBVUkwgd2FzXHJcbiAgICAgKiBwcm92aWRlZCBpbiB0aGUgY29uZmlnLCB0aGF0IFVSTCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGUgZGVmYXVsdCBVUkwgaXNcclxuICAgICAqIGZyb20gdGhlIG5ldHdvcmsgYW5kIEFQSSBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFwaVR5cGUgLSBUaGUgdHlwZSBvZiBBUEkgdG8gZ2V0IHRoZSBVUkwgZm9yLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9nZXRSZXF1ZXN0VXJsKGFwaVR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy51cmwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFwaVR5cGUgPT09IEFsY2hlbXlBcGlUeXBlLk5GVCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0QWxjaGVteU5mdEh0dHBVcmwodGhpcy5uZXR3b3JrLCB0aGlzLmFwaUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFwaVR5cGUgPT09IEFsY2hlbXlBcGlUeXBlLldFQkhPT0spIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEFsY2hlbXlXZWJob29rSHR0cFVybCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhcGlUeXBlID09PSBBbGNoZW15QXBpVHlwZS5QUklDRVMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFByaWNlc0Jhc2VVcmwodGhpcy5hcGlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhcGlUeXBlID09PSBBbGNoZW15QXBpVHlwZS5QT1JURk9MSU8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldERhdGFCYXNlVXJsKHRoaXMuYXBpS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRBbGNoZW15SHR0cFVybCh0aGlzLm5ldHdvcmssIHRoaXMuYXBpS2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gQWxjaGVteVByb3ZpZGVyIGluc3RhbmNlLiBPbmx5IG9uZSBwcm92aWRlciBpcyBjcmVhdGVkIHBlclxyXG4gICAgICogQWxjaGVteSBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgQWxjaGVteVByb3ZpZGVyIGlzIGEgd3JhcHBlciBhcm91bmQgZXRoZXIncyBgQWxjaGVteVByb3ZpZGVyYCBjbGFzcyBhbmRcclxuICAgICAqIGhhcyBiZWVuIGV4cGFuZGVkIHRvIHN1cHBvcnQgQWxjaGVteSdzIEVuaGFuY2VkIEFQSXMuXHJcbiAgICAgKlxyXG4gICAgICogTW9zdCBjb21tb24gbWV0aG9kcyBvbiB0aGUgcHJvdmlkZXIgYXJlIGF2YWlsYWJsZSBhcyB0b3AtbGV2ZWwgbWV0aG9kcyBvblxyXG4gICAgICogdGhlIHtAbGluayBBbGNoZW15fSBpbnN0YW5jZSwgYnV0IHRoZSBwcm92aWRlciBpcyBleHBvc2VkIGhlcmUgdG8gYWNjZXNzXHJcbiAgICAgKiBvdGhlciBsZXNzLWNvbW1vbiBtZXRob2RzLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0UHJvdmlkZXIoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9iYXNlQWxjaGVteVByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Jhc2VBbGNoZW15UHJvdmlkZXIgPSAoKCkgPT4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IEFsY2hlbXlQcm92aWRlciB9ID0geWllbGQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCcuL2FsY2hlbXktcHJvdmlkZXItYjAwNmE0YmMuanMnKTsgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFsY2hlbXlQcm92aWRlcih0aGlzKTtcclxuICAgICAgICAgICAgfSkpKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9iYXNlQWxjaGVteVByb3ZpZGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIEFsY2hlbXlXZWJzb2NrZXRQcm92aWRlciBpbnN0YW5jZS4gT25seSBvbmUgcHJvdmlkZXIgaXMgY3JlYXRlZFxyXG4gICAgICogcGVyIEFsY2hlbXkgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciBpcyBhIHdyYXBwZXIgYXJvdW5kIGV0aGVyJ3NcclxuICAgICAqIGBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXJgIGNsYXNzIGFuZCBoYXMgYmVlbiBleHBhbmRlZCB0byBzdXBwb3J0IEFsY2hlbXknc1xyXG4gICAgICogU3Vic2NyaXB0aW9uIEFQSXMsIGF1dG9tYXRpYyBiYWNrZmlsbGluZywgYW5kIG90aGVyIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBNb3N0IGNvbW1vbiBtZXRob2RzIG9uIHRoZSBwcm92aWRlciBhcmUgYXZhaWxhYmxlIGFzIHRvcC1sZXZlbCBtZXRob2RzIG9uXHJcbiAgICAgKiB0aGUge0BsaW5rIEFsY2hlbXl9IGluc3RhbmNlLCBidXQgdGhlIHByb3ZpZGVyIGlzIGV4cG9zZWQgaGVyZSB0byBhY2Nlc3NcclxuICAgICAqIG90aGVyIGxlc3MtY29tbW9uIG1ldGhvZHMuXHJcbiAgICAgKi9cclxuICAgIGdldFdlYlNvY2tldFByb3ZpZGVyKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fYmFzZUFsY2hlbXlXc3NQcm92aWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9iYXNlQWxjaGVteVdzc1Byb3ZpZGVyID0gKCgpID0+IF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIgfSA9IHlpZWxkIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnLi9hbGNoZW15LXdlYnNvY2tldC1wcm92aWRlci0yZGFmYTllNC5qcycpOyB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyKHRoaXMpO1xyXG4gICAgICAgICAgICB9KSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VBbGNoZW15V3NzUHJvdmlkZXI7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdmVyc2lvbiQxID0gXCJsb2dnZXIvNS43LjBcIjtcblxubGV0IF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSBmYWxzZTtcbmxldCBfY2Vuc29yRXJyb3JzID0gZmFsc2U7XG5jb25zdCBMb2dMZXZlbHMgPSB7IGRlYnVnOiAxLCBcImRlZmF1bHRcIjogMiwgaW5mbzogMiwgd2FybmluZzogMywgZXJyb3I6IDQsIG9mZjogNSB9O1xubGV0IF9sb2dMZXZlbCA9IExvZ0xldmVsc1tcImRlZmF1bHRcIl07XG5sZXQgX2dsb2JhbExvZ2dlciA9IG51bGw7XG5mdW5jdGlvbiBfY2hlY2tOb3JtYWxpemUoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGZvcm1zIG9mIG5vcm1hbGl6YXRpb24gYXJlIHN1cHBvcnRlZFxuICAgICAgICBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5mb3JFYWNoKChmb3JtKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBub3JtYWxpemVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaChmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBcIiArIG1pc3Npbmcuam9pbihcIiwgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIikgIT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuIGltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBfbm9ybWFsaXplRXJyb3IgPSBfY2hlY2tOb3JtYWxpemUoKTtcbnZhciBMb2dMZXZlbCQxO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW1wiREVCVUdcIl0gPSBcIkRFQlVHXCI7XG4gICAgTG9nTGV2ZWxbXCJJTkZPXCJdID0gXCJJTkZPXCI7XG4gICAgTG9nTGV2ZWxbXCJXQVJOSU5HXCJdID0gXCJXQVJOSU5HXCI7XG4gICAgTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IFwiRVJST1JcIjtcbiAgICBMb2dMZXZlbFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG59KShMb2dMZXZlbCQxIHx8IChMb2dMZXZlbCQxID0ge30pKTtcbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBHZW5lcmljIEVycm9yc1xuICAgIC8vIFVua25vd24gRXJyb3JcbiAgICBFcnJvckNvZGVbXCJVTktOT1dOX0VSUk9SXCJdID0gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgLy8gTm90IEltcGxlbWVudGVkXG4gICAgRXJyb3JDb2RlW1wiTk9UX0lNUExFTUVOVEVEXCJdID0gXCJOT1RfSU1QTEVNRU5URURcIjtcbiAgICAvLyBVbnN1cHBvcnRlZCBPcGVyYXRpb25cbiAgICAvLyAgIC0gb3BlcmF0aW9uXG4gICAgRXJyb3JDb2RlW1wiVU5TVVBQT1JURURfT1BFUkFUSU9OXCJdID0gXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIjtcbiAgICAvLyBOZXR3b3JrIEVycm9yIChpLmUuIEV0aGVyZXVtIE5ldHdvcmssIHN1Y2ggYXMgYW4gaW52YWxpZCBjaGFpbiBJRClcbiAgICAvLyAgIC0gZXZlbnQgKFwibm9OZXR3b3JrXCIgaXMgbm90IHJlLXRocm93biBpbiBwcm92aWRlci5yZWFkeTsgb3RoZXJ3aXNlIHRocm93bilcbiAgICBFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJORVRXT1JLX0VSUk9SXCI7XG4gICAgLy8gU29tZSBzb3J0IG9mIGJhZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICBFcnJvckNvZGVbXCJTRVJWRVJfRVJST1JcIl0gPSBcIlNFUlZFUl9FUlJPUlwiO1xuICAgIC8vIFRpbWVvdXRcbiAgICBFcnJvckNvZGVbXCJUSU1FT1VUXCJdID0gXCJUSU1FT1VUXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIE9wZXJhdGlvbmFsICBFcnJvcnNcbiAgICAvLyBCdWZmZXIgT3ZlcnJ1blxuICAgIEVycm9yQ29kZVtcIkJVRkZFUl9PVkVSUlVOXCJdID0gXCJCVUZGRVJfT1ZFUlJVTlwiO1xuICAgIC8vIE51bWVyaWMgRmF1bHRcbiAgICAvLyAgIC0gb3BlcmF0aW9uOiB0aGUgb3BlcmF0aW9uIGJlaW5nIGV4ZWN1dGVkXG4gICAgLy8gICAtIGZhdWx0OiB0aGUgcmVhc29uIHRoaXMgZmF1bHRlZFxuICAgIEVycm9yQ29kZVtcIk5VTUVSSUNfRkFVTFRcIl0gPSBcIk5VTUVSSUNfRkFVTFRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQXJndW1lbnQgRXJyb3JzXG4gICAgLy8gTWlzc2luZyBuZXcgb3BlcmF0b3IgdG8gYW4gb2JqZWN0XG4gICAgLy8gIC0gbmFtZTogVGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19ORVdcIl0gPSBcIk1JU1NJTkdfTkVXXCI7XG4gICAgLy8gSW52YWxpZCBhcmd1bWVudCAoZS5nLiB2YWx1ZSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0eXBlKSB0byBhIGZ1bmN0aW9uOlxuICAgIC8vICAgLSBhcmd1bWVudDogVGhlIGFyZ3VtZW50IG5hbWUgdGhhdCB3YXMgaW52YWxpZFxuICAgIC8vICAgLSB2YWx1ZTogVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICAgIEVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICAvLyBNaXNzaW5nIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGNvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyByZWNlaXZlZFxuICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfQVJHVU1FTlRcIl0gPSBcIk1JU1NJTkdfQVJHVU1FTlRcIjtcbiAgICAvLyBUb28gbWFueSBhcmd1bWVudHNcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiXSA9IFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBCbG9ja2NoYWluIEVycm9yc1xuICAgIC8vIENhbGwgZXhjZXB0aW9uXG4gICAgLy8gIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvblxuICAgIC8vICAtIGFkZHJlc3M/OiB0aGUgY29udHJhY3QgYWRkcmVzc1xuICAgIC8vICAtIGFyZ3M/OiBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgIC8vICAtIG1ldGhvZD86IFRoZSBTb2xpZGl0eSBtZXRob2Qgc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JTaWduYXR1cmU/OiBUaGUgRUlQODQ4IGVycm9yIHNpZ25hdHVyZVxuICAgIC8vICAtIGVycm9yQXJncz86IFRoZSBFSVA4NDggZXJyb3IgcGFyYW1ldGVyc1xuICAgIC8vICAtIHJlYXNvbjogVGhlIHJlYXNvbiAob25seSBmb3IgRUlQODQ4IFwiRXJyb3Ioc3RyaW5nKVwiKVxuICAgIEVycm9yQ29kZVtcIkNBTExfRVhDRVBUSU9OXCJdID0gXCJDQUxMX0VYQ0VQVElPTlwiO1xuICAgIC8vIEluc3VmZmljaWVudCBmdW5kcyAoPCB2YWx1ZSArIGdhc0xpbWl0ICogZ2FzUHJpY2UpXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX0ZVTkRTXCJdID0gXCJJTlNVRkZJQ0lFTlRfRlVORFNcIjtcbiAgICAvLyBOb25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJOT05DRV9FWFBJUkVEXCJdID0gXCJOT05DRV9FWFBJUkVEXCI7XG4gICAgLy8gVGhlIHJlcGxhY2VtZW50IGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGlzIHRvbyBsb3dcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiXSA9IFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIjtcbiAgICAvLyBUaGUgZ2FzIGxpbWl0IGNvdWxkIG5vdCBiZSBlc3RpbWF0ZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBwYXNzZWQgdG8gZXN0aW1hdGVHYXNcbiAgICBFcnJvckNvZGVbXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiXSA9IFwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIjtcbiAgICAvLyBUaGUgdHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkIGJ5IG9uZSB3aXRoIGEgaGlnaGVyIGdhcyBwcmljZVxuICAgIC8vICAgLSByZWFzb246IFwiY2FuY2VsbGVkXCIsIFwicmVwbGFjZWRcIiBvciBcInJlcHJpY2VkXCJcbiAgICAvLyAgIC0gY2FuY2VsbGVkOiB0cnVlIGlmIHJlYXNvbiA9PSBcImNhbmNlbGxlZFwiIG9yIHJlYXNvbiA9PSBcInJlcGxhY2VkXCIpXG4gICAgLy8gICAtIGhhc2g6IG9yaWdpbmFsIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAvLyAgIC0gcmVwbGFjZW1lbnQ6IHRoZSBmdWxsIFRyYW5zYWN0aW9uc1Jlc3BvbnNlIGZvciB0aGUgcmVwbGFjZW1lbnRcbiAgICAvLyAgIC0gcmVjZWlwdDogdGhlIHJlY2VpcHQgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgRXJyb3JDb2RlW1wiVFJBTlNBQ1RJT05fUkVQTEFDRURcIl0gPSBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEludGVyYWN0aW9uIEVycm9yc1xuICAgIC8vIFRoZSB1c2VyIHJlamVjdGVkIHRoZSBhY3Rpb24sIHN1Y2ggYXMgc2lnbmluZyBhIG1lc3NhZ2Ugb3Igc2VuZGluZ1xuICAgIC8vIGEgdHJhbnNhY3Rpb25cbiAgICBFcnJvckNvZGVbXCJBQ1RJT05fUkVKRUNURURcIl0gPSBcIkFDVElPTl9SRUpFQ1RFRFwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xuY29uc3QgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5jbGFzcyBMb2dnZXIkMSB7XG4gICAgY29uc3RydWN0b3IodmVyc2lvbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmVyc2lvbixcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2xvZyhsb2dMZXZlbCwgYXJncykge1xuICAgICAgICBjb25zdCBsZXZlbCA9IGxvZ0xldmVsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChMb2dMZXZlbHNbbGV2ZWxdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsb2cgbGV2ZWwgbmFtZVwiLCBcImxvZ0xldmVsXCIsIGxvZ0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2xvZ0xldmVsID4gTG9nTGV2ZWxzW2xldmVsXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIkMS5sZXZlbHMuREVCVUcsIGFyZ3MpO1xuICAgIH1cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlciQxLmxldmVscy5JTkZPLCBhcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIkMS5sZXZlbHMuV0FSTklORywgYXJncyk7XG4gICAgfVxuICAgIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gRXJyb3JzIGFyZSBiZWluZyBjZW5zb3JlZFxuICAgICAgICBpZiAoX2NlbnNvckVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUVycm9yKFwiY2Vuc29yZWQgZXJyb3JcIiwgY29kZSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgY29kZSA9IExvZ2dlciQxLmVycm9ycy5VTktOT1dOX0VSUk9SO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlRGV0YWlscyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gJiAweDBmXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVVpbnQ4QXJyYXkoMHhcIiArIGhleCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbXNba2V5XS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgdmVyc2lvbj0ke3RoaXMudmVyc2lvbn1gKTtcbiAgICAgICAgY29uc3QgcmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgbGV0IHVybCA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTlVNRVJJQ19GQVVMVDoge1xuICAgICAgICAgICAgICAgIHVybCA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdmVyZmxvd1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5kZXJmbG93XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaXZpc2lvbi1ieS16ZXJvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItXCIgKyBmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtcG93ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXdpZHRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItdW5zdXBwb3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLXVuYm91bmQtcmVzdWx0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5DQUxMX0VYQ0VQVElPTjpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLklOU1VGRklDSUVOVF9GVU5EUzpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk1JU1NJTkdfTkVXOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTk9OQ0VfRVhQSVJFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuVFJBTlNBQ1RJT05fUkVQTEFDRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVDpcbiAgICAgICAgICAgICAgICB1cmwgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgWyBTZWU6IGh0dHBzOi9cXC9saW5rcy5ldGhlcnMub3JnL3Y1LWVycm9ycy1cIiArIHVybCArIFwiIF1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZURldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIG1lc3NhZ2VEZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBBbnk/P1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgZXJyb3IucmVhc29uID0gcmVhc29uO1xuICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGVycm9yW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5tYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgdGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyJDEuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgIGFyZ3VtZW50OiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGNvbmRpdGlvbiwgbWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBjaGVja05vcm1hbGl6ZShtZXNzYWdlKSB7XG4gICAgICAgIGlmIChfbm9ybWFsaXplRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgTG9nZ2VyJDEuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBmb3JtOiBfbm9ybWFsaXplRXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJ2YWx1ZSBub3Qgc2FmZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMHgxZmZmZmZmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlciQxLmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcbiAgICAgICAgICAgICAgICBmYXVsdDogXCJvdXQtb2Ytc2FmZS1yYW5nZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICUgMSkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlciQxLmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcbiAgICAgICAgICAgICAgICBmYXVsdDogXCJub24taW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCI6IFwiICsgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA8IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgYXJndW1lbnRcIiArIG1lc3NhZ2UsIExvZ2dlciQxLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgTG9nZ2VyJDEuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tOZXcodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyJDEuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0Fic3RyYWN0KHRhcmdldCwga2luZCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBraW5kKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJjYW5ub3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3MgXCIgKyBKU09OLnN0cmluZ2lmeShraW5kLm5hbWUpICsgXCIgZGlyZWN0bHk7IHVzZSBhIHN1Yi1jbGFzc1wiLCBMb2dnZXIkMS5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG5hbWU6IHRhcmdldC5uYW1lLCBvcGVyYXRpb246IFwibmV3XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlciQxLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdsb2JhbExvZ2dlcigpIHtcbiAgICAgICAgaWYgKCFfZ2xvYmFsTG9nZ2VyKSB7XG4gICAgICAgICAgICBfZ2xvYmFsTG9nZ2VyID0gbmV3IExvZ2dlciQxKHZlcnNpb24kMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9nbG9iYWxMb2dnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRDZW5zb3JzaGlwKGNlbnNvcnNoaXAsIHBlcm1hbmVudCkge1xuICAgICAgICBpZiAoIWNlbnNvcnNoaXAgJiYgcGVybWFuZW50KSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZ2dlcigpLnRocm93RXJyb3IoXCJjYW5ub3QgcGVybWFuZW50bHkgZGlzYWJsZSBjZW5zb3JzaGlwXCIsIExvZ2dlciQxLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3Blcm1hbmVudENlbnNvckVycm9ycykge1xuICAgICAgICAgICAgaWYgKCFjZW5zb3JzaGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIiwgTG9nZ2VyJDEuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9jZW5zb3JFcnJvcnMgPSAhIWNlbnNvcnNoaXA7XG4gICAgICAgIF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSAhIXBlcm1hbmVudDtcbiAgICB9XG4gICAgc3RhdGljIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gTG9nTGV2ZWxzW2xvZ0xldmVsLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgTG9nZ2VyJDEuZ2xvYmFsTG9nZ2VyKCkud2FybihcImludmFsaWQgbG9nIGxldmVsIC0gXCIgKyBsb2dMZXZlbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX2xvZ0xldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dnZXIkMSh2ZXJzaW9uKTtcbiAgICB9XG59XG5Mb2dnZXIkMS5lcnJvcnMgPSBFcnJvckNvZGU7XG5Mb2dnZXIkMS5sZXZlbHMgPSBMb2dMZXZlbCQxO1xuXG5jb25zdCB2ZXJzaW9uID0gXCJwcm9wZXJ0aWVzLzUuNy4wXCI7XG5cbnZhciBfX2F3YWl0ZXIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIkMSh2ZXJzaW9uKTtcbmZ1bmN0aW9uIGRlZmluZVJlYWRPbmx5KG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3Qua2V5cyhvYmplY3QpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbigodikgPT4gKHsga2V5OiBrZXksIHZhbHVlOiB2IH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB5aWVsZCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0sIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgYWNjdW1bKHJlc3VsdC5rZXkpXSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgIH0pO1xufVxuY29uc3Qgb3BhcXVlID0geyBiaWdpbnQ6IHRydWUsIGJvb2xlYW46IHRydWUsIFwiZnVuY3Rpb25cIjogdHJ1ZSwgbnVtYmVyOiB0cnVlLCBzdHJpbmc6IHRydWUgfTtcbmZ1bmN0aW9uIF9pc0Zyb3plbihvYmplY3QpIHtcbiAgICAvLyBPcGFxdWUgb2JqZWN0cyBhcmUgbm90IG11dGFibGUsIHNvIHNhZmUgdG8gY29weSBieSBhc3NpZ25tZW50XG4gICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCA9PT0gbnVsbCB8fCBvcGFxdWVbdHlwZW9mIChvYmplY3QpXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSB8fCB0eXBlb2YgKG9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKCFPYmplY3QuaXNGcm96ZW4ob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYWNjZXNzaW5nIGEgdmFsdWUgdHJpZ2dlcnMgYW4gZXJyb3IsIGl0IGlzIGEgZ2V0dGVyXG4gICAgICAgICAgICAgICAgLy8gZGVzaWduZWQgdG8gZG8gc28gKGUuZy4gUmVzdWx0KSBhbmQgaXMgdGhlcmVmb3JlIFwiZnJvemVuXCJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX2lzRnJvemVuKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYENhbm5vdCBkZWVwQ29weSAke3R5cGVvZiAob2JqZWN0KX1gLCBcIm9iamVjdFwiLCBvYmplY3QpO1xufVxuLy8gUmV0dXJucyBhIG5ldyBjb3B5IG9mIG9iamVjdCwgc3VjaCB0aGF0IG5vIHByb3BlcnRpZXMgbWF5IGJlIHJlcGxhY2VkLlxuLy8gTmV3IHByb3BlcnRpZXMgbWF5IGJlIGFkZGVkIG9ubHkgdG8gb2JqZWN0cy5cbmZ1bmN0aW9uIF9kZWVwQ29weShvYmplY3QpIHtcbiAgICBpZiAoX2lzRnJvemVuKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgLy8gQXJyYXlzIGFyZSBtdXRhYmxlLCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGNvcHlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKG9iamVjdC5tYXAoKGl0ZW0pID0+IGRlZXBDb3B5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKG9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seShyZXN1bHQsIGtleSwgZGVlcENvcHkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgQ2Fubm90IGRlZXBDb3B5ICR7dHlwZW9mIChvYmplY3QpfWAsIFwib2JqZWN0XCIsIG9iamVjdCk7XG59XG5mdW5jdGlvbiBkZWVwQ29weShvYmplY3QpIHtcbiAgICByZXR1cm4gX2RlZXBDb3B5KG9iamVjdCk7XG59XG5cbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSBkZWNpbWFsIG51bWJlci5cclxuICpcclxuICogQHBhcmFtIGhleFN0cmluZyAtIFRoZSBoZXggc3RyaW5nIHRvIGNvbnZlcnQuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGZyb21IZXgoaGV4U3RyaW5nKSB7XHJcbiAgICByZXR1cm4gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGhleFN0cmluZykudG9OdW1iZXIoKTtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgYSBudW1iZXIgdG8gYSBoZXggc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gbnVtIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGhleC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdG9IZXgobnVtKSB7XHJcbiAgICByZXR1cm4gYnl0ZXMuaGV4VmFsdWUobnVtKTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYSBoZXggc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gcG9zc2libGVIZXhTdHJpbmcgLSBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGlzSGV4KHBvc3NpYmxlSGV4U3RyaW5nKSB7XHJcbiAgICByZXR1cm4gL14weFswLTlhLWZBLUZdKyQvLnRlc3QocG9zc2libGVIZXhTdHJpbmcpO1xyXG59XG5cbmZ1bmN0aW9uIGZvcm1hdEJsb2NrKGJsb2NrKSB7XHJcbiAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBibG9jaztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoYmxvY2spKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvSGV4KGJsb2NrKTtcclxuICAgIH1cclxuICAgIHJldHVybiBibG9jay50b1N0cmluZygpO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ1RvRW51bSh4LCBlbnVtYikge1xyXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZW51bWIpLmluY2x1ZGVzKHgpID8geCA6IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0Q29udHJhY3RGb3JOZnRGcm9tUmF3KHJhd05mdENvbnRyYWN0KSB7XHJcbiAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldE5mdENvbnRyYWN0RnJvbVJhdyhyYXdOZnRDb250cmFjdCkpLCB7IHNwYW1DbGFzc2lmaWNhdGlvbnM6IHJhd05mdENvbnRyYWN0LnNwYW1DbGFzc2lmaWNhdGlvbnMubWFwKHBhcnNlTmZ0U3BhbUNsYXNzaWZpY2F0aW9uKSB9KSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0Q29udHJhY3RzRm9yT3duZXJGcm9tUmF3KHJhd05mdENvbnRyYWN0KSB7XHJcbiAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldE5mdENvbnRyYWN0RnJvbVJhdyhyYXdOZnRDb250cmFjdCkpLCB7IGRpc3BsYXlOZnQ6IHJhd05mdENvbnRyYWN0LmRpc3BsYXlOZnQsIGltYWdlOiByYXdOZnRDb250cmFjdC5pbWFnZSwgdG90YWxCYWxhbmNlOiByYXdOZnRDb250cmFjdC50b3RhbEJhbGFuY2UsIG51bURpc3RpbmN0VG9rZW5zT3duZWQ6IHJhd05mdENvbnRyYWN0Lm51bURpc3RpbmN0VG9rZW5zT3duZWQsIGlzU3BhbTogcmF3TmZ0Q29udHJhY3QuaXNTcGFtIH0pKTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRDb250cmFjdEZyb21SYXcocmF3TmZ0Q29udHJhY3QpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmF3TmZ0Q29udHJhY3QpLCB7IHRva2VuVHlwZTogcGFyc2VOZnRUb2tlblR5cGUocmF3TmZ0Q29udHJhY3QudG9rZW5UeXBlKSwgb3BlblNlYU1ldGFkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd05mdENvbnRyYWN0Lm9wZW5TZWFNZXRhZGF0YSksIHsgc2FmZWxpc3RSZXF1ZXN0U3RhdHVzOiAoKF9hID0gcmF3TmZ0Q29udHJhY3Qub3BlblNlYU1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2FmZWxpc3RSZXF1ZXN0U3RhdHVzKVxyXG4gICAgICAgICAgICAgICAgPyBzdHJpbmdUb0VudW0ocmF3TmZ0Q29udHJhY3Qub3BlblNlYU1ldGFkYXRhLnNhZmVsaXN0UmVxdWVzdFN0YXR1cywgZXhwb3J0cy5PcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzKVxyXG4gICAgICAgICAgICAgICAgOiBudWxsIH0pIH0pKTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRDb2xsZWN0aW9uRnJvbVJhdyhyYXdOZnRDb2xsZWN0aW9uKSB7XHJcbiAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd05mdENvbGxlY3Rpb24pLCB7IGZsb29yUHJpY2U6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmF3TmZ0Q29sbGVjdGlvbi5mbG9vclByaWNlKSwgeyBtYXJrZXRwbGFjZTogcGFyc2VOZnRDb2xsZWN0aW9uTWFya2V0cGxhY2UocmF3TmZ0Q29sbGVjdGlvbi5mbG9vclByaWNlLm1hcmtldHBsYWNlKSB9KSB9KSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QmFzZU5mdEZyb21SYXcocmF3QmFzZU5mdCwgY29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udHJhY3RBZGRyZXNzXHJcbiAgICAgICAgICAgID8gY29udHJhY3RBZGRyZXNzXHJcbiAgICAgICAgICAgIDogcmF3QmFzZU5mdC5jb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgdG9rZW5JZDogcmF3QmFzZU5mdC50b2tlbklkXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldE5mdEZyb21SYXcocmF3TmZ0KSB7XHJcbiAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd05mdCksIHsgY29udHJhY3Q6IGdldE5mdENvbnRyYWN0Rm9yTmZ0RnJvbVJhdyhyYXdOZnQuY29udHJhY3QpLCB0b2tlblR5cGU6IHBhcnNlTmZ0VG9rZW5UeXBlKHJhd05mdC50b2tlblR5cGUpLCBhY3F1aXJlZEF0OiByYXdOZnQuYWNxdWlyZWRBdCwgY29sbGVjdGlvbjogcmF3TmZ0LmNvbGxlY3Rpb24sIG1pbnQ6IHJhd05mdC5taW50IH0pKTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRTYWxlc0Zyb21SYXcocmF3TmZ0U2FsZXMpIHtcclxuICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHtcclxuICAgICAgICBuZnRTYWxlczogcmF3TmZ0U2FsZXMubmZ0U2FsZXMubWFwKHJhd05mdFNhbGUgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmF3TmZ0U2FsZSksIHsgbWFya2V0cGxhY2U6IHBhcnNlTmZ0U2FsZU1hcmtldHBsYWNlKHJhd05mdFNhbGUubWFya2V0cGxhY2UpLCB0YWtlcjogcGFyc2VOZnRUYWtlcihyYXdOZnRTYWxlLnRha2VyKSB9KSkpLFxyXG4gICAgICAgIHZhbGlkQXQ6IHJhd05mdFNhbGVzLnZhbGlkQXQsXHJcbiAgICAgICAgcGFnZUtleTogcmF3TmZ0U2FsZXMucGFnZUtleVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VOZnRTYWxlTWFya2V0cGxhY2UobWFya2V0cGxhY2UpIHtcclxuICAgIHN3aXRjaCAobWFya2V0cGxhY2UpIHtcclxuICAgICAgICBjYXNlICdsb29rc3JhcmUnOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRTYWxlTWFya2V0cGxhY2UuTE9PS1NSQVJFO1xyXG4gICAgICAgIGNhc2UgJ3NlYXBvcnQnOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRTYWxlTWFya2V0cGxhY2UuU0VBUE9SVDtcclxuICAgICAgICBjYXNlICd4MnkyJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0U2FsZU1hcmtldHBsYWNlLlgyWTI7XHJcbiAgICAgICAgY2FzZSAnd3l2ZXJuJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0U2FsZU1hcmtldHBsYWNlLldZVkVSTjtcclxuICAgICAgICBjYXNlICdjcnlwdG9wdW5rcyc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZS5DUllQVE9QVU5LUztcclxuICAgICAgICBjYXNlICdibHVyJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0U2FsZU1hcmtldHBsYWNlLkJMVVI7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0U2FsZU1hcmtldHBsYWNlLlVOS05PV047XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VOZnRDb2xsZWN0aW9uTWFya2V0cGxhY2UobWFya2V0cGxhY2UpIHtcclxuICAgIHN3aXRjaCAobWFya2V0cGxhY2UpIHtcclxuICAgICAgICBjYXNlICdPcGVuU2VhJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlLk9QRU5TRUE7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZU5mdFRha2VyKHRha2VyKSB7XHJcbiAgICAvLyBUaGUgYC50b0xvd2VyQ2FzZSgpYCBjYWxsIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBBUEkgcmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgdmFsdWVzXHJcbiAgICBzd2l0Y2ggKHRha2VyLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICBjYXNlICdidXllcic6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVUYWtlclR5cGUuQlVZRVI7XHJcbiAgICAgICAgY2FzZSAnc2VsbGVyJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0U2FsZVRha2VyVHlwZS5TRUxMRVI7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBOZnRTYWxlVGFrZXJUeXBlICR7dGFrZXJ9YCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VOZnRTcGFtQ2xhc3NpZmljYXRpb24ocykge1xyXG4gICAgY29uc3QgcmVzID0gc3RyaW5nVG9FbnVtKHMsIGV4cG9ydHMuTmZ0U3BhbUNsYXNzaWZpY2F0aW9uKTtcclxuICAgIGlmIChyZXMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNwYW1DbGFzc2lmaWNhdGlvbi5Vbmtub3duO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBwYXJzZU5mdFRva2VuVHlwZSh0b2tlblR5cGUpIHtcclxuICAgIHN3aXRjaCAodG9rZW5UeXBlKSB7XHJcbiAgICAgICAgY2FzZSAnZXJjNzIxJzpcclxuICAgICAgICBjYXNlICdFUkM3MjEnOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRUb2tlblR5cGUuRVJDNzIxO1xyXG4gICAgICAgIGNhc2UgJ2VyYzExNTUnOlxyXG4gICAgICAgIGNhc2UgJ0VSQzExNTUnOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRUb2tlblR5cGUuRVJDMTE1NTtcclxuICAgICAgICBjYXNlICdub19zdXBwb3J0ZWRfbmZ0X3N0YW5kYXJkJzpcclxuICAgICAgICBjYXNlICdOT19TVVBQT1JURURfTkZUX1NUQU5EQVJEJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0VG9rZW5UeXBlLk5PX1NVUFBPUlRFRF9ORlRfU1RBTkRBUkQ7XHJcbiAgICAgICAgY2FzZSAnbm90X2FfY29udHJhY3QnOlxyXG4gICAgICAgIGNhc2UgJ05PVF9BX0NPTlRSQUNUJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0VG9rZW5UeXBlLk5PVF9BX0NPTlRSQUNUO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFRva2VuVHlwZS5VTktOT1dOO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IElTX0JST1dTRVIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgIT09IG51bGw7XHJcbmZ1bmN0aW9uIG51bGxzVG9VbmRlZmluZWQob2JqKSB7XHJcbiAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGlmIChvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIG9ialtrZXldID0gbnVsbHNUb1VuZGVmaW5lZChvYmpba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxufVxuXG4vKipcclxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSB1bmRlcmx5aW5nIGltcGxlbWVudGF0aW9ucyBmb3IgZXhwb3NlZCBBUEkgc3VyZmFjZSBpblxyXG4gKiB0aGUge0BsaW5rIENvcmVOYW1lc3BhY2V9LiBCeSBtb3ZpbmcgdGhlIG1ldGhvZHMgb3V0IGludG8gYSBzZXBhcmF0ZSBmaWxlLFxyXG4gKiBvdGhlciBuYW1lc3BhY2VzIGNhbiBhY2Nlc3MgdGhlc2UgbWV0aG9kcyB3aXRob3V0IGRlcGVuZGluZyBvbiB0aGUgZW50aXJlXHJcbiAqIENvcmVOYW1lc3BhY2UsIG9yIG92ZXJyaWRlIHRoZSBgc3JjTWV0aG9kYCBwYXJhbSB1c2VkIGZvciBsb2dnaW5nLlxyXG4gKi9cclxuLyoqXHJcbiAqIEdldHMgdGhlIGFzc2V0IHRyYW5zZmVycyBmb3IgdGhlIHByb3ZpZGVkIHBhcmFtcy5cclxuICovXHJcbmZ1bmN0aW9uIGdldEFzc2V0VHJhbnNmZXJzKGNvbmZpZywgcGFyYW1zLCBzcmNNZXRob2QgPSAnZ2V0QXNzZXRUcmFuc2ZlcnMnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBjb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICBpZiAocGFyYW1zLmZyb21BZGRyZXNzKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5mcm9tQWRkcmVzcyA9IHlpZWxkIHByb3ZpZGVyLl9nZXRBZGRyZXNzKHBhcmFtcy5mcm9tQWRkcmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJhbXMudG9BZGRyZXNzKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy50b0FkZHJlc3MgPSB5aWVsZCBwcm92aWRlci5fZ2V0QWRkcmVzcyhwYXJhbXMudG9BZGRyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X2dldEFzc2V0VHJhbnNmZXJzJywgW1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgZnJvbUJsb2NrOiBwYXJhbXMuZnJvbUJsb2NrICE9IG51bGwgPyBmb3JtYXRCbG9jayhwYXJhbXMuZnJvbUJsb2NrKSA6IHVuZGVmaW5lZCwgdG9CbG9jazogcGFyYW1zLnRvQmxvY2sgIT0gbnVsbCA/IGZvcm1hdEJsb2NrKHBhcmFtcy50b0Jsb2NrKSA6IHVuZGVmaW5lZCwgbWF4Q291bnQ6IHBhcmFtcy5tYXhDb3VudCAhPSBudWxsID8gdG9IZXgocGFyYW1zLm1heENvdW50KSA6IHVuZGVmaW5lZCB9KVxyXG4gICAgICAgIF0sIHNyY01ldGhvZCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvblJlY2VpcHRzKGNvbmZpZywgcGFyYW1zLCBzcmNNZXRob2QgPSAnZ2V0VHJhbnNhY3Rpb25SZWNlaXB0cycpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIGNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9nZXRUcmFuc2FjdGlvblJlY2VpcHRzJywgW3BhcmFtc10sIHNyY01ldGhvZCk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIGV0aGVycyBpbXBsZW1lbnRhdGlvbiBvZiBnZXRMb2dzLCBidXQgaXMgZXhwYW5kZWRcclxuICogdG8gc3VwcG9ydCBzcGVjaWZ5aW5nIGFuIGFkZHJlc3MgYXJyYXkgaW4gdGhlIGZpbHRlci5cclxuICpcclxuICogVGhlIG1haW4gbW9kaWZpY2F0aW9ucyBtYWRlIHRvIHN1cHBvcnQgYW4gYWRkcmVzcyBhcnJheSBhcmU6XHJcbiAqIC0gQ3VzdG9tIGBnZXRGaWx0ZXIoKWAgbWV0aG9kIHRoYXQgc3VwcG9ydHMgYW4gYWRkcmVzcyBhcnJheVxyXG4gKiAtIFVzZSBvZiBgYXJyYXlPZigpYCBmb3JtYXR0ZXIgdG8gZm9ybWF0IHRoZSBsb2dzIHRvIGF2b2lkIHRoZSBgRm9ybWF0dGVyYCBpbXBvcnQuXHJcbiAqIC0gVXNlIG9mIGBwcm92aWRlci5zZW5kKClgIHRvIGF2b2lkIGZvcm1hdHRpbmcgbG9naWMgaW4gYHByb3ZpZGVyLnBlcmZvcm0oKWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRMb2dzKGNvbmZpZywgZmlsdGVyKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBjb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICB5aWVsZCBwcm92aWRlci5nZXROZXR3b3JrKCk7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICBmaWx0ZXI6IGdldEZpbHRlcihjb25maWcsIGZpbHRlcilcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBsb2dzID0geWllbGQgcHJvdmlkZXIuc2VuZCgnZXRoX2dldExvZ3MnLCBbcGFyYW1zLmZpbHRlcl0pO1xyXG4gICAgICAgIGxvZ3MuZm9yRWFjaChsb2cgPT4ge1xyXG4gICAgICAgICAgICBpZiAobG9nLnJlbW92ZWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbG9nLnJlbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhcnJheU9mKHByb3ZpZGVyLmZvcm1hdHRlci5maWx0ZXJMb2cuYmluZChwcm92aWRlci5mb3JtYXR0ZXIpKShsb2dzKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiBhbmQgY29waWVkIGZyb20gdGhlIGV0aGVycyBpbXBsZW1lbnRhdGlvbiBvZlxyXG4gKiBgSnNvblJwY1Byb3ZpZGVyLl9nZXRGaWx0ZXIoKWAsIGJ1dCBpcyBleHRlbmRlZCB0byBzdXBwb3J0IGFuIGFkZHJlc3MgYXJyYXkuXHJcbiAqXHJcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYSBoYWNreSB3YXkgdG8gZ2V0IGFyb3VuZCB0aGUgZXRoZXJzIGZvcm1hdHRlci4gVGhlXHJcbiAqIGZvcm1hdHRlciBpcyB1c2VkIHRvIGNoZWNrIHRoZSB0eXBlcyBvZiB0aGUgYGZpbHRlcmAgcGFyYW1zLCBidXQgZXRoZXJzIGRvZXNcclxuICogbm90IGFsbG93IGFuIGFycmF5IGluIHRoZSBgYWRkcmVzc2AgZmllbGQuIFRvIHByZXNlcnZlIHRoZSBldGhlcnMgZm9ybWF0dGVyXHJcbiAqIG9uIHRoZSBvdGhlciBmaWVsZHMsIHdlIHVzZSB0aGUgZm9ybWF0dGVyIHRvIGNoZWNrIHRoZSB0eXBlcyBvZiB0aG9zZSBvdGhlclxyXG4gKiBmaWVsZHMsIGFuZCB0aGVuIG1hbnVhbGx5IGNoZWNrIHRoZSBgYWRkcmVzc2AgZmllbGQgbGFzdC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEZpbHRlcihjb25maWcsIGZpbHRlcikge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIC8vIFNUQVJUIE1PRElGSUVEIENPREVcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIGNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkRmlsdGVyID0geWllbGQgZmlsdGVyO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcclxuICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIFsnYmxvY2tIYXNoJywgJ3RvcGljcyddLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkRmlsdGVyW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcmVzb2x2ZWRGaWx0ZXJba2V5XTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBbJ2Zyb21CbG9jaycsICd0b0Jsb2NrJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRGaWx0ZXJba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBwcm92aWRlci5fZ2V0QmxvY2tUYWcocmVzb2x2ZWRGaWx0ZXJba2V5XSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQkVHSU4gTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIC8vIEZvcm1hdCB0aGUgYHJlc3VsdGAgb2JqZWN0IHVzaW5nIHRoZSBldGhlcnMgZm9ybWF0dGVyIHdpdGhvdXQgdGhlIGBhZGRyZXNzYFxyXG4gICAgICAgIC8vIGZpZWxkLlxyXG4gICAgICAgIHJlc3VsdCA9IHByb3ZpZGVyLmZvcm1hdHRlci5maWx0ZXIoeWllbGQgcmVzb2x2ZVByb3BlcnRpZXMocmVzdWx0KSk7XHJcbiAgICAgICAgLy8gQWZ0ZXIgZm9ybWF0dGluZyB0aGUgb3RoZXIgZmllbGRzLCBtYW51YWxseSBmb3JtYXQgdGhlIGBhZGRyZXNzYCBmaWVsZFxyXG4gICAgICAgIC8vIGJlZm9yZSBhZGRpbmcgaXQgdG8gdGhlIGByZXN1bHRgIG9iamVjdC5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNvbHZlZEZpbHRlci5hZGRyZXNzKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuYWRkcmVzcyA9IHlpZWxkIFByb21pc2UuYWxsKHJlc29sdmVkRmlsdGVyLmFkZHJlc3MubWFwKChhZGRyZXNzKSA9PiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIHByb3ZpZGVyLl9nZXRBZGRyZXNzKGFkZHJlc3MpOyB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXNvbHZlZEZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFkZHJlc3MgPSB5aWVsZCBwcm92aWRlci5fZ2V0QWRkcmVzcyhyZXNvbHZlZEZpbHRlci5hZGRyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIERPIE5PVCBNT0RJRlkuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZGlyZWN0bHkgY29waWVkIG92ZXIgZnJvbSBldGhlcnMgaW1wbGVtZW50YXRpb24gb2ZcclxuICogYEZvcm1hdHRlci5hcnJheU9mKClgLiBJdCBpcyBjb3BpZWQgaGVyZSB0byBhdm9pZCBoYXZpbmcgdG8gaW1wb3J0IHRoZVxyXG4gKiBgRm9ybWF0dGVyYCBjbGFzcyBvciBgRm9ybWF0dGVyRnVuY2AgdHlwZSBmcm9tIGV0aGVycywgdGhhdCBhcmUgbm90IHBhcnQgb2ZcclxuICogdGhlIGRlZmF1bHQgZXhwb3J0LlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgdGhlIGZvcm1hdHRlciB0byBhbiBhcnJheSBvZlxyXG4gKiB2YWx1ZXMsIGFuZCBpcyB1c2VkIHRvIGZvcm1hdCB0aGUgbG9ncyByZXR1cm5lZCBieSBgZ2V0TG9ncygpYC5cclxuICovXHJcbmZ1bmN0aW9uIGFycmF5T2YoZm9ybWF0KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhbiBhcnJheScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBhcnJheS5mb3JFYWNoKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZm9ybWF0KHZhbHVlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIFRoZSBjb3JlIG5hbWVzcGFjZSBjb250YWlucyBhbGwgY29tbW9ubHktdXNlZCBbRXRoZXJzLmpzXHJcbiAqIFByb3ZpZGVyXShodHRwczovL2RvY3MuZXRoZXJzLmlvL3Y1L2FwaS9wcm92aWRlcnMvYXBpLXByb3ZpZGVycy8jQWxjaGVteVByb3ZpZGVyKVxyXG4gKiBtZXRob2RzLiBJZiB5b3UgYXJlIGFscmVhZHkgdXNpbmcgRXRoZXJzLmpzLCB5b3Ugc2hvdWxkIGJlIHNpbXBseSBhYmxlIHRvXHJcbiAqIHJlcGxhY2UgdGhlIEV0aGVycy5qcyBQcm92aWRlciBvYmplY3Qgd2l0aCBgYWxjaGVteS5jb3JlYCB3aGVuIGFjY2Vzc2luZ1xyXG4gKiBwcm92aWRlciBtZXRob2RzIGFuZCBpdCBzaG91bGQganVzdCB3b3JrLlxyXG4gKlxyXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCBpbnN0YW50aWF0ZSBhbiBBbGNoZW15IG9iamVjdFxyXG4gKiB3aXRoIGBjb25zdCBhbGNoZW15ID0gbmV3IEFsY2hlbXkoY29uZmlnKWAgYW5kIHRoZW4gYWNjZXNzIHRoZSBjb3JlIG5hbWVzcGFjZVxyXG4gKiB2aWEgYGFsY2hlbXkuY29yZWAuXHJcbiAqL1xyXG5jbGFzcyBDb3JlTmFtZXNwYWNlIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiYWxhbmNlIG9mIGEgZ2l2ZW4gYWRkcmVzcyBhcyBvZiB0aGUgcHJvdmlkZWQgYmxvY2suXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFkZHJlc3NPck5hbWUgVGhlIGFkZHJlc3Mgb3IgbmFtZSBvZiB0aGUgYWNjb3VudCB0byBnZXQgdGhlIGJhbGFuY2UgZm9yLlxyXG4gICAgICogQHBhcmFtIGJsb2NrVGFnIFRoZSBvcHRpb25hbCBibG9jayBudW1iZXIgb3IgaGFzaCB0byBnZXQgdGhlIGJhbGFuY2UgZm9yLlxyXG4gICAgICogICBEZWZhdWx0cyB0byAnbGF0ZXN0JyBpZiB1bnNwZWNpZmllZC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0QmFsYW5jZShhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0QmFsYW5jZShhZGRyZXNzT3JOYW1lLCBibG9ja1RhZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYWRkcmVzcyBpcyBhIHNtYXJ0IGNvbnRyYWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzIHRvIGNoZWNrIHR5cGUgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBpc0NvbnRyYWN0QWRkcmVzcyhhZGRyZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB5aWVsZCBwcm92aWRlci5nZXRDb2RlKGFkZHJlc3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29kZSAhPT0gJzB4JztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29udHJhY3QgY29kZSBvZiB0aGUgcHJvdmlkZWQgYWRkcmVzcyBhdCB0aGUgYmxvY2suIElmIHRoZXJlIGlzXHJcbiAgICAgKiBubyBjb250cmFjdCBkZXBsb3llZCwgdGhlIHJlc3VsdCBpcyBgMHhgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzT3JOYW1lIFRoZSBhZGRyZXNzIG9yIG5hbWUgb2YgdGhlIGFjY291bnQgdG8gZ2V0IHRoZSBjb2RlIGZvci5cclxuICAgICAqIEBwYXJhbSBibG9ja1RhZyBUaGUgb3B0aW9uYWwgYmxvY2sgbnVtYmVyIG9yIGhhc2ggdG8gZ2V0IHRoZSBjb2RlIGZvci5cclxuICAgICAqICAgRGVmYXVsdHMgdG8gJ2xhdGVzdCcgaWYgdW5zcGVjaWZpZWQuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldENvZGUoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldENvZGUoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBwb3NpdGlvbiBhdCB0aGUgcHJvdmlkZWQgYWRkcmVzcywgYXQgdGhlXHJcbiAgICAgKiBwcm92aWRlZCBibG9jayBpbiBgQnl0ZXMzMmAgZm9ybWF0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzT3JOYW1lIFRoZSBhZGRyZXNzIG9yIG5hbWUgb2YgdGhlIGFjY291bnQgdG8gZ2V0IHRoZSBjb2RlIGZvci5cclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gb2YgdGhlIHN0b3JhZ2Ugc2xvdCB0byBnZXQuXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tUYWcgVGhlIG9wdGlvbmFsIGJsb2NrIG51bWJlciBvciBoYXNoIHRvIGdldCB0aGUgY29kZSBmb3IuXHJcbiAgICAgKiAgIERlZmF1bHRzIHRvICdsYXRlc3QnIGlmIHVuc3BlY2lmaWVkLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRTdG9yYWdlQXQoYWRkcmVzc09yTmFtZSwgcG9zaXRpb24sIGJsb2NrVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRTdG9yYWdlQXQoYWRkcmVzc09yTmFtZSwgcG9zaXRpb24sIGJsb2NrVGFnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyBldmVyIHNlbnQgZnJvbSB0aGUgcHJvdmlkZWQgYWRkcmVzcywgYXNcclxuICAgICAqIG9mIHRoZSBwcm92aWRlZCBibG9jayB0YWcuIFRoaXMgdmFsdWUgaXMgdXNlZCBhcyB0aGUgbm9uY2UgZm9yIHRoZSBuZXh0XHJcbiAgICAgKiB0cmFuc2FjdGlvbiBmcm9tIHRoZSBhZGRyZXNzIHNlbnQgdG8gdGhlIG5ldHdvcmsuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFkZHJlc3NPck5hbWUgVGhlIGFkZHJlc3Mgb3IgbmFtZSBvZiB0aGUgYWNjb3VudCB0byBnZXQgdGhlIG5vbmNlIGZvci5cclxuICAgICAqIEBwYXJhbSBibG9ja1RhZyBUaGUgb3B0aW9uYWwgYmxvY2sgbnVtYmVyIG9yIGhhc2ggdG8gZ2V0IHRoZSBub25jZSBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldFRyYW5zYWN0aW9uQ291bnQoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBibG9jayBmcm9tIHRoZSBuZXR3b3JrIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBibG9jayBudW1iZXIgb3JcclxuICAgICAqIGhhc2guIFRyYW5zYWN0aW9ucyBvbiB0aGUgYmxvY2sgYXJlIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIHRyYW5zYWN0aW9uXHJcbiAgICAgKiBoYXNoZXMuIFRvIGdldCB0aGUgZnVsbCB0cmFuc2FjdGlvbiBkZXRhaWxzIG9uIHRoZSBibG9jaywgdXNlXHJcbiAgICAgKiB7QGxpbmsgZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zfSBpbnN0ZWFkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBibG9ja0hhc2hPckJsb2NrVGFnIFRoZSBibG9jayBudW1iZXIgb3IgaGFzaCB0byBnZXQgdGhlIGJsb2NrIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJsb2NrIGZyb20gdGhlIG5ldHdvcmsgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGJsb2NrIG51bWJlciBvclxyXG4gICAgICogaGFzaC4gVHJhbnNhY3Rpb25zIG9uIHRoZSBibG9jayBhcmUgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2ZcclxuICAgICAqIHtAbGluayBUcmFuc2FjdGlvblJlc3BvbnNlfSBvYmplY3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBibG9ja0hhc2hPckJsb2NrVGFnIFRoZSBibG9jayBudW1iZXIgb3IgaGFzaCB0byBnZXQgdGhlIGJsb2NrIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zKGJsb2NrSGFzaE9yQmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9ja0hhc2hPckJsb2NrVGFnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIEV0aGVyc05ldHdvcmtBbGlhc30gQWxjaGVteSBpcyBjb25uZWN0ZWQgdG8uXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXROZXR3b3JrKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBibG9jayBudW1iZXIgb2YgdGhlIG1vc3QgcmVjZW50bHkgbWluZWQgYmxvY2suXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRCbG9ja051bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJlc3QgZ3Vlc3Mgb2YgdGhlIGN1cnJlbnQgZ2FzIHByaWNlIHRvIHVzZSBpbiBhIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0R2FzUHJpY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRHYXNQcmljZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZWNvbW1lbmRlZCBmZWUgZGF0YSB0byB1c2UgaW4gYSB0cmFuc2FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgYW4gRUlQLTE1NTkgdHJhbnNhY3Rpb24sIHRoZSBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzXHJcbiAgICAgKiBzaG91bGQgYmUgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgbGVnYWN5IHRyYW5zYWN0aW9ucyBhbmQgbmV0d29ya3Mgd2hpY2ggZG8gbm90IHN1cHBvcnQgRUlQLTE1NTksIHRoZVxyXG4gICAgICogZ2FzUHJpY2Ugc2hvdWxkIGJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRGZWVEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgUHJvbWlzZSB3aGljaCB3aWxsIHN0YWxsIHVudGlsIHRoZSBuZXR3b3JrIGhhcyBoZWVuIGVzdGFibGlzaGVkLFxyXG4gICAgICogaWdub3JpbmcgZXJyb3JzIGR1ZSB0byB0aGUgdGFyZ2V0IG5vZGUgbm90IGJlaW5nIGFjdGl2ZSB5ZXQuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCBmb3IgdGVzdGluZyBvciBhdHRhY2hpbmcgc2NyaXB0cyB0byB3YWl0IHVudGlsIHRoZSBub2RlIGlzXHJcbiAgICAgKiB1cCBhbmQgcnVubmluZyBzbW9vdGhseS5cclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHJlYWR5KCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIucmVhZHk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgdGhlIHRyYW5zYWN0aW9uLCB1c2luZyBjYWxsLiBBIGNhbGwgZG9lc1xyXG4gICAgICogbm90IHJlcXVpcmUgYW55IGV0aGVyLCBidXQgY2Fubm90IGNoYW5nZSBhbnkgc3RhdGUuIFRoaXMgaXMgdXNlZnVsIGZvclxyXG4gICAgICogY2FsbGluZyBnZXR0ZXJzIG9uIENvbnRyYWN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIHRvIGV4ZWN1dGUuXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tUYWcgVGhlIG9wdGlvbmFsIGJsb2NrIG51bWJlciBvciBoYXNoIHRvIGdldCB0aGUgY2FsbCBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGNhbGwodHJhbnNhY3Rpb24sIGJsb2NrVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5jYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gZXN0aW1hdGUgb2YgdGhlIGFtb3VudCBvZiBnYXMgdGhhdCB3b3VsZCBiZSByZXF1aXJlZCB0byBzdWJtaXRcclxuICAgICAqIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrLlxyXG4gICAgICpcclxuICAgICAqIEFuIGVzdGltYXRlIG1heSBub3QgYmUgYWNjdXJhdGUgc2luY2UgdGhlcmUgY291bGQgYmUgYW5vdGhlciB0cmFuc2FjdGlvbiBvblxyXG4gICAgICogdGhlIG5ldHdvcmsgdGhhdCB3YXMgbm90IGFjY291bnRlZCBmb3IsIGJ1dCBhZnRlciBiZWluZyBtaW5lZCBhZmZlY3RzIHRoZVxyXG4gICAgICogcmVsZXZhbnQgc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFRyYW5zYWN0TmFtZXNwYWNlLmVzdGltYXRlR2FzfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIHRvIGVzdGltYXRlIGdhcyBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5lc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHdpdGggaGFzaCBvciBudWxsIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyB1bmtub3duLlxyXG4gICAgICpcclxuICAgICAqIElmIGEgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCB0aGlzIG1ldGhvZCB3aWxsIHNlYXJjaCB0aGVcclxuICAgICAqIHRyYW5zYWN0aW9uIHBvb2wuIFZhcmlvdXMgYmFja2VuZHMgbWF5IGhhdmUgbW9yZSByZXN0cmljdGl2ZSB0cmFuc2FjdGlvblxyXG4gICAgICogcG9vbCBhY2Nlc3MgKGUuZy4gaWYgdGhlIGdhcyBwcmljZSBpcyB0b28gbG93IG9yIHRoZSB0cmFuc2FjdGlvbiB3YXMgb25seVxyXG4gICAgICogcmVjZW50bHkgc2VudCBhbmQgbm90IHlldCBpbmRleGVkKSBpbiB3aGljaCBjYXNlIHRoaXMgbWV0aG9kIG1heSBhbHNvIHJldHVybiBudWxsLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBUcmFuc2FjdE5hbWVzcGFjZS5nZXRUcmFuc2FjdGlvbn0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSGFzaCBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gZ2V0LlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQgZm9yIGhhc2ggb3IgbnVsbCBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdFxyXG4gICAgICogYmVlbiBtaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBUbyBzdGFsbCB1bnRpbCB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQsIGNvbnNpZGVyIHRoZVxyXG4gICAgICogd2FpdEZvclRyYW5zYWN0aW9uIG1ldGhvZCBiZWxvdy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25IYXNoIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBnZXQuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJtaXRzIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrIHRvIGJlIG1pbmVkLiBUaGUgdHJhbnNhY3Rpb24gbXVzdCBiZVxyXG4gICAgICogc2lnbmVkLCBhbmQgYmUgdmFsaWQgKGkuZS4gdGhlIG5vbmNlIGlzIGNvcnJlY3QgYW5kIHRoZSBhY2NvdW50IGhhc1xyXG4gICAgICogc3VmZmljaWVudCBiYWxhbmNlIHRvIHBheSBmb3IgdGhlIHRyYW5zYWN0aW9uKS5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgVHJhbnNhY3ROYW1lc3BhY2UuZ2V0VHJhbnNhY3Rpb259LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzaWduZWRUcmFuc2FjdGlvbiBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uIHRvIHNlbmQuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggd2lsbCBub3QgcmVzb2x2ZSB1bnRpbCBzcGVjaWZpZWQgdHJhbnNhY3Rpb24gaGFzaCBpcyBtaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBJZiB7QGxpbmsgY29uZmlybWF0aW9uc30gaXMgMCwgdGhpcyBtZXRob2QgaXMgbm9uLWJsb2NraW5nIGFuZCBpZiB0aGVcclxuICAgICAqIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCByZXR1cm5zIG51bGwuIE90aGVyd2lzZSwgdGhpcyBtZXRob2Qgd2lsbFxyXG4gICAgICogYmxvY2sgdW50aWwgdGhlIHRyYW5zYWN0aW9uIGhhcyBjb25maXJtZWQgYmxvY2tzIG1pbmVkIG9uIHRvcCBvZiB0aGUgYmxvY2tcclxuICAgICAqIGluIHdoaWNoIGl0IHdhcyBtaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgVHJhbnNhY3ROYW1lc3BhY2UuZ2V0VHJhbnNhY3Rpb259LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbkhhc2ggVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRvIHdhaXQgZm9yLlxyXG4gICAgICogQHBhcmFtIGNvbmZpcm1hdGlvbnMgVGhlIG51bWJlciBvZiBibG9ja3MgdG8gd2FpdCBmb3IuXHJcbiAgICAgKiBAcGFyYW0gdGltZW91dCBUaGUgbWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb25maXJtLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICB3YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsb2dzIHRoYXQgbWF0Y2ggdGhlIHByb3ZpZGVkIGZpbHRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmlsdGVyIFRoZSBmaWx0ZXIgb2JqZWN0IHRvIHVzZS5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0TG9ncyhmaWx0ZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRMb2dzKHRoaXMuY29uZmlnLCBmaWx0ZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvd3Mgc2VuZGluZyBhIHJhdyBtZXNzYWdlIHRvIHRoZSBBbGNoZW15IGJhY2tlbmQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1ldGhvZCBUaGUgbWV0aG9kIHRvIGNhbGwuXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIHRoZSBhZGRyZXNzIHRoYXQgZGVwbG95ZWQgdGhlIHByb3ZpZGVkIGNvbnRyYWN0IGFuZCBibG9jayBudW1iZXIgaXRcclxuICAgICAqIHdhcyBkZXBsb3llZCBpbi5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggYWNyb3NzIGFsbCBibG9ja3Mgc2luY2UgZ2VuZXNpc1xyXG4gICAgICogYW5kIGNhbiB0YWtlIGEgbG9uZyB0aW1lIHRvIGNvbXBsZXRlLiBUaGlzIG1ldGhvZCBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZFxyXG4gICAgICogdGhhdCB3aWxsIGV2ZW50dWFsbHkgYmUgcmVwbGFjZWQgYnkgYSBzaW5nbGUgY2FsbCB0byBhbiBBbGNoZW15IGVuZHBvaW50XHJcbiAgICAgKiB3aXRoIHRoaXMgaW5mb3JtYXRpb24gY2FjaGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcyB0byBmaW5kIHRoZSBkZXBsb3llciBmb3IuXHJcbiAgICAgKiBAYmV0YVxyXG4gICAgICovXHJcbiAgICBmaW5kQ29udHJhY3REZXBsb3llcihjb250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCbG9ja051bSA9IHlpZWxkIHByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmICgoeWllbGQgcHJvdmlkZXIuZ2V0Q29kZShjb250cmFjdEFkZHJlc3MsIGN1cnJlbnRCbG9ja051bSkpID09PVxyXG4gICAgICAgICAgICAgICAgRVRIX05VTExfVkFMVUUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3QgJyR7Y29udHJhY3RBZGRyZXNzfScgZG9lcyBub3QgZXhpc3RgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBCaW5hcnkgc2VhcmNoIGZvciB0aGUgYmxvY2sgbnVtYmVyIHRoYXQgdGhlIGNvbnRyYWN0IHdhcyBkZXBsb3llZCBpbi5cclxuICAgICAgICAgICAgY29uc3QgZmlyc3RCbG9jayA9IHlpZWxkIGJpbmFyeVNlYXJjaEZpcnN0QmxvY2soMCwgY3VycmVudEJsb2NrTnVtICsgMSwgY29udHJhY3RBZGRyZXNzLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHRyYW5zYWN0aW9uIGluIHRoZSBibG9jayB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIGFkZHJlc3MuXHJcbiAgICAgICAgICAgIGNvbnN0IHR4UmVjZWlwdHMgPSB5aWVsZCBnZXRUcmFuc2FjdGlvblJlY2VpcHRzKHRoaXMuY29uZmlnLCB7XHJcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdG9IZXgoZmlyc3RCbG9jaylcclxuICAgICAgICAgICAgfSwgJ2ZpbmRDb250cmFjdERlcGxveWVyJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nUmVjZWlwdCA9IChfYSA9IHR4UmVjZWlwdHMucmVjZWlwdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maW5kKHJlY2VpcHQgPT4gcmVjZWlwdC5jb250cmFjdEFkZHJlc3MgPT09IGNvbnRyYWN0QWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRlcGxveWVyQWRkcmVzczogbWF0Y2hpbmdSZWNlaXB0ID09PSBudWxsIHx8IG1hdGNoaW5nUmVjZWlwdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2hpbmdSZWNlaXB0LmZyb20sXHJcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogZmlyc3RCbG9ja1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW5CYWxhbmNlcyhhZGRyZXNzT3JOYW1lLCBjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgcHJvdmlkZXIuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zLmxlbmd0aCA+IDE1MDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgcGFzcyBpbiBtb3JlIHRoYW4gMTUwMCBjb250cmFjdCBhZGRyZXNzZXMgdG8gZ2V0VG9rZW5CYWxhbmNlcygpJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRUb2tlbkJhbGFuY2VzKCkgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGNvbnRyYWN0QWRkcmVzcyB3aGVuIHVzaW5nIGFuIGFycmF5Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfZ2V0VG9rZW5CYWxhbmNlcycsIFthZGRyZXNzLCBjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9uc10sICdnZXRUb2tlbkJhbGFuY2VzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblR5cGUgPSBjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucyA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRzLlRva2VuQmFsYW5jZVR5cGUuRVJDMjBcclxuICAgICAgICAgICAgICAgICAgICA6IGNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zLnR5cGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBbYWRkcmVzcywgdG9rZW5UeXBlXTtcclxuICAgICAgICAgICAgICAgIGlmICgoY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnMgPT09IG51bGwgfHwgY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zLnR5cGUpID09PSBleHBvcnRzLlRva2VuQmFsYW5jZVR5cGUuRVJDMjAgJiZcclxuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucy5wYWdlS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goeyBwYWdlS2V5OiBjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucy5wYWdlS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X2dldFRva2VuQmFsYW5jZXMnLCBwYXJhbXMsICdnZXRUb2tlbkJhbGFuY2VzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdG9rZW5zIHRoYXQgdGhlIHNwZWNpZmllZCBhZGRyZXNzIG93bnMsIGFsb25nIHdpdGggdGhlIGFtb3VudFxyXG4gICAgICogb2YgZWFjaCB0b2tlbiBhbmQgdGhlIHJlbGV2YW50IG1ldGFkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzT3JOYW1lIFRoZSBvd25lciBhZGRyZXNzIHRvIGdldCB0aGUgdG9rZW5zIHdpdGggYmFsYW5jZXMgZm9yLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldFRva2Vuc0Zvck93bmVyKGFkZHJlc3NPck5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCBwcm92aWRlci5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW1xyXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250cmFjdEFkZHJlc3NlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhwb3J0cy5Ub2tlbkJhbGFuY2VUeXBlLkVSQzIwXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleSkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goeyBwYWdlS2V5OiBvcHRpb25zLnBhZ2VLZXkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoeWllbGQgcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfZ2V0VG9rZW5CYWxhbmNlcycsIHBhcmFtcywgJ2dldFRva2Vuc0Zvck93bmVyJykpO1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRCYWxhbmNlcyA9IHJlc3BvbnNlLnRva2VuQmFsYW5jZXMubWFwKGJhbGFuY2UgPT4gKHtcclxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogYmFsYW5jZS5jb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICByYXdCYWxhbmNlOiBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oYmFsYW5jZS50b2tlbkJhbGFuY2UpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YVByb21pc2VzID0geWllbGQgUHJvbWlzZS5hbGxTZXR0bGVkKHJlc3BvbnNlLnRva2VuQmFsYW5jZXMubWFwKHRva2VuID0+IHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X2dldFRva2VuTWV0YWRhdGEnLCBbdG9rZW4uY29udHJhY3RBZGRyZXNzXSwgJ2dldFRva2Vuc0Zvck93bmVyJykpKTtcclxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YVByb21pc2VzLm1hcChwID0+IHAuc3RhdHVzID09PSAnZnVsZmlsbGVkJ1xyXG4gICAgICAgICAgICAgICAgPyBwLnZhbHVlXHJcbiAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBsb2dvOiBudWxsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3Qgb3duZWRUb2tlbnMgPSBmb3JtYXR0ZWRCYWxhbmNlcy5tYXAoKGJhbGFuY2UsIGluZGV4KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhbGFuY2UpLCBtZXRhZGF0YVtpbmRleF0pLCB7IGJhbGFuY2U6IG1ldGFkYXRhW2luZGV4XS5kZWNpbWFscyAhPT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgID8gdXRpbHMuZm9ybWF0VW5pdHMoYmFsYW5jZS5yYXdCYWxhbmNlLCBtZXRhZGF0YVtpbmRleF0uZGVjaW1hbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQgfSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHRva2Vuczogb3duZWRUb2tlbnMubWFwKHQgPT4gbnVsbHNUb1VuZGVmaW5lZCh0KSksXHJcbiAgICAgICAgICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdlS2V5XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbWV0YWRhdGEgZm9yIGEgZ2l2ZW4gdG9rZW4gY29udHJhY3QgYWRkcmVzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgY29udHJhY3QgYWRkcmVzcyB0byBnZXQgbWV0YWRhdGEgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUb2tlbk1ldGFkYXRhKGFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X2dldFRva2VuTWV0YWRhdGEnLCBbYWRkcmVzc10sICdnZXRUb2tlbk1ldGFkYXRhJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRBc3NldFRyYW5zZmVycyhwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRBc3NldFRyYW5zZmVycyh0aGlzLmNvbmZpZywgcGFyYW1zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgdHJhbnNhY3Rpb24gcmVjZWlwdHMgZm9yIGEgZ2l2ZW4gYmxvY2sgYnkgbnVtYmVyIG9yIGJsb2NrIGhhc2guXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3QgY29udGFpbmluZyBmaWVsZHMgZm9yIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IHF1ZXJ5LlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUcmFuc2FjdGlvblJlY2VpcHRzKHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFRyYW5zYWN0aW9uUmVjZWlwdHModGhpcy5jb25maWcsIHBhcmFtcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgb3duZXIgYWRkcmVzcyBmb3IgdGhlIHByb3ZpZGVkIEVOUyBhZGRyZXNzLCBvciBgbnVsbGBcclxuICAgICAqIGlmIHRoZSBFTlMgbmFtZSBkb2VzIG5vdCBoYXZlIGFuIHVuZGVybHlpbmcgYWRkcmVzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgRU5TIGFkZHJlc3MgbmFtZSB0byByZXNvbHZlLlxyXG4gICAgICovXHJcbiAgICByZXNvbHZlTmFtZShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSByZXZlcnNlIGxvb2t1cCBvZiB0aGUgYWRkcmVzcyBpbiBFTlMgdXNpbmcgdGhlIFJldmVyc2UgUmVnaXN0cmFyLiBJZiB0aGUgbmFtZSBkb2VzIG5vdCBleGlzdCwgb3IgdGhlIGZvcndhcmQgbG9va3VwIGRvZXMgbm90IG1hdGNoLCBudWxsIGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEFuIEVOUyBuYW1lIHJlcXVpcmVzIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiB0byBzZXR1cCBhIHJldmVyc2UgcmVjb3JkLCBzbyBub3QgYWxsIEVOUyBhZGRyZXNzZXMgd2lsbCBtYXAgYmFjayB0byB0aGUgb3JpZ2luYWwgRU5TIGRvbWFpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBsb29rIHVwIHRoZSBFTlMgZG9tYWluIG5hbWUgZm9yLlxyXG4gICAgICovXHJcbiAgICBsb29rdXBBZGRyZXNzKGFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmxvb2t1cEFkZHJlc3MoYWRkcmVzcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIGJldHdlZW4gYW4gaW50ZWdlciByYW5nZSBvZiBibG9jayBudW1iZXJzIHRvIGZpbmQgdGhlXHJcbiAqIGJsb2NrIG51bWJlciB3aGVyZSB0aGUgY29udHJhY3Qgd2FzIGRlcGxveWVkLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaEZpcnN0QmxvY2soc3RhcnQsIGVuZCwgYWRkcmVzcywgY29uZmlnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID49IGVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIGNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgIGNvbnN0IGNvZGUgPSB5aWVsZCBwcm92aWRlci5nZXRDb2RlKGFkZHJlc3MsIG1pZCk7XHJcbiAgICAgICAgaWYgKGNvZGUgPT09IEVUSF9OVUxMX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5hcnlTZWFyY2hGaXJzdEJsb2NrKG1pZCArIDEsIGVuZCwgYWRkcmVzcywgY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaEZpcnN0QmxvY2soc3RhcnQsIG1pZCwgYWRkcmVzcywgY29uZmlnKTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBUaGUgRGVidWcgbmFtZXNwYWNlIGNvbnRhaW5zIG1ldGhvZHMgdG8gYWNjZXNzIHRoZSBub24tc3RhbmRhcmQgUlBDIG1ldGhvZHNcclxuICogZm9yIGluc3BlY3RpbmcgYW5kIGRlYnVnZ2luZyB0cmFuc2FjdGlvbnMuXHJcbiAqXHJcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBkaWZmZXJlbnQgbWV0aG9kcyBhbmQgdXNlIGNhc2VzIHBsZWFzZSByZWFkIG91clxyXG4gKiBbZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLmFsY2hlbXkuY29tL3JlZmVyZW5jZS9kZWJ1Zy1hcGktcXVpY2tzdGFydCkuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIEFsY2hlbXkgb2JqZWN0XHJcbiAqIHdpdGggYGNvbnN0IGFsY2hlbXkgPSBuZXcgQWxjaGVteShjb25maWcpYCBhbmQgdGhlbiBhY2Nlc3MgdGhlIGRlYnVnIG5hbWVzcGFjZVxyXG4gKiB2aWEgYGFsY2hlbXkuZGVidWdgLlxyXG4gKi9cclxuY2xhc3MgRGVidWdOYW1lc3BhY2Uge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcbiAgICB0cmFjZUNhbGwodHJhbnNhY3Rpb24sIGJsb2NrSWRlbnRpZmllciwgdHJhY2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFt0cmFuc2FjdGlvbiwgYmxvY2tJZGVudGlmaWVyLCBwYXJzZVRyYWNlclBhcmFtcyh0cmFjZXIpXTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdkZWJ1Z190cmFjZUNhbGwnLCBwYXJhbXMsICd0cmFjZUNhbGwnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRyYWNlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCB0cmFjZXIsIHRpbWVvdXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW3RyYW5zYWN0aW9uSGFzaCwgcGFyc2VUcmFjZXJQYXJhbXModHJhY2VyLCB0aW1lb3V0KV07XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZCgnZGVidWdfdHJhY2VUcmFuc2FjdGlvbicsIHBhcmFtcywgJ3RyYWNlVHJhbnNhY3Rpb24nKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRyYWNlQmxvY2soYmxvY2tJZGVudGlmaWVyLCB0cmFjZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgbGV0IG1ldGhvZDtcclxuICAgICAgICAgICAgbGV0IHBhcmFtcztcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzSGV4U3RyaW5nKGJsb2NrSWRlbnRpZmllciwgMzIpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnZGVidWdfdHJhY2VCbG9ja0J5SGFzaCc7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBbYmxvY2tJZGVudGlmaWVyLCBwYXJzZVRyYWNlclBhcmFtcyh0cmFjZXIpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdkZWJ1Z190cmFjZUJsb2NrQnlOdW1iZXInO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0eXBlb2YgYmxvY2tJZGVudGlmaWVyID09PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gdXRpbHMuaGV4U3RyaXBaZXJvcyh1dGlscy5oZXhWYWx1ZShibG9ja0lkZW50aWZpZXIpKVxyXG4gICAgICAgICAgICAgICAgICAgIDogYmxvY2tJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gW2Jsb2NrLCBwYXJzZVRyYWNlclBhcmFtcyh0cmFjZXIpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQobWV0aG9kLCBwYXJhbXMsICd0cmFjZUJsb2NrJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VUcmFjZXJQYXJhbXModHJhY2VyLCB0aW1lb3V0KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHRyYWNlcjogdHJhY2VyLnR5cGUgfSwgKHRyYWNlci5vbmx5VG9wQ2FsbCAhPT0gdW5kZWZpbmVkICYmIHtcclxuICAgICAgICB0cmFjZXJDb25maWc6IHtcclxuICAgICAgICAgICAgb25seVRvcENhbGw6IHRyYWNlci5vbmx5VG9wQ2FsbCxcclxuICAgICAgICAgICAgdGltZW91dFxyXG4gICAgICAgIH1cclxuICAgIH0pKTtcclxufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZVRva2VuVHlwZSh0b2tlblR5cGUpIHtcclxuICAgIGlmICh0b2tlblR5cGUgPT09IGV4cG9ydHMuTmZ0VG9rZW5UeXBlLkVSQzExNTUgfHwgdG9rZW5UeXBlID09PSBleHBvcnRzLk5mdFRva2VuVHlwZS5FUkM3MjEpIHtcclxuICAgICAgICByZXR1cm4gdG9rZW5UeXBlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxuXG4vKipcclxuICogVGhlIFNESyBoYXMgNCBsb2cgbGV2ZWxzIGFuZCBhIDV0aCBvcHRpb24gZm9yIGRpc2FibGluZyBhbGwgbG9nZ2luZy4gQnlcclxuICogZGVmYXVsdCwgdGhlIGxvZyBsZXZlbCBpcyBzZXQgdG8gSU5GTy5cclxuICpcclxuICogVGhlIG9yZGVyIGlzIGEgZm9sbG93czogREVCVUcgPCBJTkZPIDwgV0FSTiA8IEVSUk9SXHJcbiAqXHJcbiAqIEFsbCBsb2cgdHlwZXMgYWJvdmUgdGhlIGN1cnJlbnQgbG9nIGxldmVsIHdpbGwgYmUgb3V0cHV0dGVkLlxyXG4gKi9cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIklORk9cIl0gPSAxXSA9IFwiSU5GT1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXQVJOXCJdID0gMl0gPSBcIldBUk5cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRVJST1JcIl0gPSAzXSA9IFwiRVJST1JcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiU0lMRU5UXCJdID0gNF0gPSBcIlNJTEVOVFwiO1xyXG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xyXG5jb25zdCBsb2dMZXZlbFN0cmluZ1RvRW51bSA9IHtcclxuICAgIGRlYnVnOiBMb2dMZXZlbC5ERUJVRyxcclxuICAgIGluZm86IExvZ0xldmVsLklORk8sXHJcbiAgICB3YXJuOiBMb2dMZXZlbC5XQVJOLFxyXG4gICAgZXJyb3I6IExvZ0xldmVsLkVSUk9SLFxyXG4gICAgc2lsZW50OiBMb2dMZXZlbC5TSUxFTlRcclxufTtcclxuLy8gSEFDS1k6IFVzZSB0aGUgY29uc29sZSBtZXRob2QgYXMgYSBzdHJpbmcgcmF0aGVyIHRoYW4gdGhlIGZ1bmN0aW9uIGl0c2VsZlxyXG4vLyBpbiBvcmRlciB0byBhbGxvdyBmb3IgbW9ja2luZyBpbiB0ZXN0cy5cclxuY29uc3QgbG9nTGV2ZWxUb0NvbnNvbGVGbiA9IHtcclxuICAgIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxyXG4gICAgW0xvZ0xldmVsLklORk9dOiAnaW5mbycsXHJcbiAgICBbTG9nTGV2ZWwuV0FSTl06ICd3YXJuJyxcclxuICAgIFtMb2dMZXZlbC5FUlJPUl06ICdlcnJvcidcclxufTtcclxuY29uc3QgREVGQVVMVF9MT0dfTEVWRUwgPSBMb2dMZXZlbC5JTkZPO1xyXG4vKipcclxuICogQ29uZmlndXJlcyB0aGUgdmVyYm9zaXR5IG9mIGxvZ2dpbmcuIFRoZSBkZWZhdWx0IGxvZyBsZXZlbCBpcyBgaW5mb2AuXHJcbiAqXHJcbiAqIEBwYXJhbSBsb2dMZXZlbCAtIFRoZSB2ZXJib3NpdHkgb2YgbG9nZ2luZy4gQ2FuIGJlIGFueSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcclxuICpcclxuICogICAtIGBkZWJ1Z2A6IFRoZSBtb3N0IHZlcmJvc2UgbG9nZ2luZyBsZXZlbC5cclxuICogICAtIGBpbmZvYDogVGhlIGRlZmF1bHQgbG9nZ2luZyBsZXZlbC5cclxuICogICAtIGB3YXJuYDogQSBsb2dnaW5nIGxldmVsIGZvciBub24tY3JpdGljYWwgaXNzdWVzLlxyXG4gKiAgIC0gYGVycm9yYDogQSBsb2dnaW5nIGxldmVsIGZvciBjcml0aWNhbCBpc3N1ZXMuXHJcbiAqICAgLSBgc2lsZW50YDogVHVybiBvZmYgYWxsIGxvZ2dpbmcuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XHJcbiAgICBsb2dnZXJDbGllbnQubG9nTGV2ZWwgPSBsb2dMZXZlbFN0cmluZ1RvRW51bVtsb2dMZXZlbF07XHJcbn1cclxuZnVuY3Rpb24gbG9nRGVidWcobWVzc2FnZSwgLi4uYXJncykge1xyXG4gICAgbG9nZ2VyQ2xpZW50LmRlYnVnKG1lc3NhZ2UsIGFyZ3MpO1xyXG59XHJcbmZ1bmN0aW9uIGxvZ0luZm8obWVzc2FnZSwgLi4uYXJncykge1xyXG4gICAgbG9nZ2VyQ2xpZW50LmluZm8obWVzc2FnZSwgYXJncyk7XHJcbn1cclxuZnVuY3Rpb24gbG9nV2FybihtZXNzYWdlLCAuLi5hcmdzKSB7XHJcbiAgICBsb2dnZXJDbGllbnQud2FybihtZXNzYWdlLCBhcmdzKTtcclxufVxyXG5jbGFzcyBMb2dnZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqIFRoZSBsb2cgbGV2ZWwgb2YgdGhlIGdpdmVuIExvZ2dlciBpbnN0YW5jZS4gKi9cclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IERFRkFVTFRfTE9HX0xFVkVMO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvZ0xldmVsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcclxuICAgIH1cclxuICAgIHNldCBsb2dMZXZlbCh2YWwpIHtcclxuICAgICAgICBpZiAoISh2YWwgaW4gTG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWUgXCIke3ZhbH1cIiBhc3NpZ25lZCB0byBcXGBsb2dMZXZlbFxcYGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbDtcclxuICAgIH1cclxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuREVCVUcsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgaW5mbyguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgd2FybiguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvcndhcmRzIGxvZyBtZXNzYWdlcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIGlmIHRoZVxyXG4gICAgICogbG9nIGxldmVsIGFsbG93cyBpdC5cclxuICAgICAqL1xyXG4gICAgX2xvZyhsb2dMZXZlbCwgLi4uYXJncykge1xyXG4gICAgICAgIGlmIChsb2dMZXZlbCA8IHRoaXMuX2xvZ0xldmVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGxvZ0xldmVsVG9Db25zb2xlRm5bbG9nTGV2ZWxdO1xyXG4gICAgICAgIGlmIChtZXRob2QpIHtcclxuICAgICAgICAgICAgY29uc29sZVttZXRob2RdKGBbJHtub3d9XSBBbGNoZW15OmAsIC4uLmFyZ3MubWFwKHN0cmluZ2lmeSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb2dnZXIgcmVjZWl2ZWQgYW4gaW52YWxpZCBsb2dMZXZlbCAodmFsdWU6ICR7bG9nTGV2ZWx9KWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqKSB7XHJcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIEZhaWxlZCB0byBjb252ZXJ0IHRvIEpTT04sIGxvZyB0aGUgb2JqZWN0IGRpcmVjdGx5LlxyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyBJbnN0YW50aWF0ZSBkZWZhdWx0IGxvZ2dlciBmb3IgdGhlIFNESy5cclxuY29uc3QgbG9nZ2VyQ2xpZW50ID0gbmV3IExvZ2dlcigpO1xuXG4vLyBUaGlzIGZpbGUgaXMgYXV0b2dlbmVyYXRlZCBieSBpbmplY3RWZXJzaW9uLmpzLiBBbnkgY2hhbmdlcyB3aWxsIGJlXHJcbi8vIG92ZXJ3cml0dGVuIG9uIGNvbW1pdCFcclxuY29uc3QgVkVSU0lPTiA9ICczLjYuMic7XG5cbi8qKlxyXG4gKiBHaXZlbiBhIFJFU1QgZW5kcG9pbnQsIG1ldGhvZCwgYW5kIHBhcmFtcywgc2VuZHMgdGhlIHJlcXVlc3Qgd2l0aCBheGlvcyBhbmRcclxuICogcmV0dXJucyB0aGUgcmVzcG9uc2UuXHJcbiAqL1xyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHNlbmQgaHR0cCByZXF1ZXN0cyB1c2luZyBBeGlzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2VuZEF4aW9zUmVxdWVzdChiYXNlVXJsLCByZXN0QXBpTmFtZSwgbWV0aG9kTmFtZSwgcGFyYW1zLCBvdmVycmlkZXMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHJlcXVlc3RVcmwgPSBiYXNlVXJsICsgJy8nICsgcmVzdEFwaU5hbWU7XHJcbiAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcyksIHsgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcyA9PT0gbnVsbCB8fCBvdmVycmlkZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJyaWRlcy5oZWFkZXJzKSwgKCFJU19CUk9XU0VSICYmIHsgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwJyB9KSksIHsgJ0FsY2hlbXktRXRoZXJzLVNkay1WZXJzaW9uJzogVkVSU0lPTiwgJ0FsY2hlbXktRXRoZXJzLVNkay1NZXRob2QnOiBtZXRob2ROYW1lIH0pLCBtZXRob2Q6IChfYSA9IG92ZXJyaWRlcyA9PT0gbnVsbCB8fCBvdmVycmlkZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJyaWRlcy5tZXRob2QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdHRVQnLCB1cmw6IHJlcXVlc3RVcmwsIHBhcmFtcyB9KTtcclxuICAgIHJldHVybiBheGlvc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY29uZmlnKTtcclxufVxuXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfSU5JVElBTF9ERUxBWV9NUyA9IDEwMDA7XHJcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9NVUxUSVBMSUVSID0gMS41O1xyXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TID0gMzAgKiAxMDAwO1xyXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfTUFYX0FUVEVNUFRTID0gNTtcclxuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIGV4cG9uZW50aWFsIGJhY2tvZmYgYW5kIG1heCByZXRyeSBhdHRlbXB0cy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBFeHBvbmVudGlhbEJhY2tvZmYge1xyXG4gICAgY29uc3RydWN0b3IobWF4QXR0ZW1wdHMgPSBERUZBVUxUX0JBQ0tPRkZfTUFYX0FUVEVNUFRTKSB7XHJcbiAgICAgICAgdGhpcy5tYXhBdHRlbXB0cyA9IG1heEF0dGVtcHRzO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbERlbGF5TXMgPSBERUZBVUxUX0JBQ0tPRkZfSU5JVElBTF9ERUxBWV9NUztcclxuICAgICAgICB0aGlzLmJhY2tvZmZNdWx0aXBsaWVyID0gREVGQVVMVF9CQUNLT0ZGX01VTFRJUExJRVI7XHJcbiAgICAgICAgdGhpcy5tYXhEZWxheU1zID0gREVGQVVMVF9CQUNLT0ZGX01BWF9ERUxBWV9NUztcclxuICAgICAgICB0aGlzLm51bUF0dGVtcHRzID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnREZWxheU1zID0gMDtcclxuICAgICAgICB0aGlzLmlzSW5CYWNrb2ZmID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIHRoZSBiYWNrb2ZmIGRlbGF5LiBUaGUgZGVsYXkgaXNcclxuICAgICAqIGluY3JlYXNlZCBmb3IgZWFjaCBhdHRlbXB0LiBUaGUgcHJvbWlzZSBpcyByZWplY3RlZCBpZiB0aGUgbWF4aW11bSBudW1iZXJcclxuICAgICAqIG9mIGF0dGVtcHRzIGlzIGV4Y2VlZGVkLlxyXG4gICAgICovXHJcbiAgICAvLyBUT0RPOiBiZWF1dGlmeSB0aGlzIGludG8gYW4gYXN5bmMgaXRlcmF0b3IuXHJcbiAgICBiYWNrb2ZmKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm51bUF0dGVtcHRzID49IHRoaXMubWF4QXR0ZW1wdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgRXhjZWVkZWQgbWF4aW11bSBudW1iZXIgb2YgYXR0ZW1wdHM6ICR7dGhpcy5tYXhBdHRlbXB0c31gKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzSW5CYWNrb2ZmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0EgYmFja29mZiBvcGVyYXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcycpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmFja29mZkRlbGF5V2l0aEppdHRlck1zID0gdGhpcy53aXRoSml0dGVyTXModGhpcy5jdXJyZW50RGVsYXlNcyk7XHJcbiAgICAgICAgaWYgKGJhY2tvZmZEZWxheVdpdGhKaXR0ZXJNcyA+IDApIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoJ0V4cG9uZW50aWFsQmFja29mZi5iYWNrb2ZmJywgYEJhY2tpbmcgb2ZmIGZvciAke2JhY2tvZmZEZWxheVdpdGhKaXR0ZXJNc31tc2ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5leHQgZGVsYXkuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGVsYXlNcyAqPSB0aGlzLmJhY2tvZmZNdWx0aXBsaWVyO1xyXG4gICAgICAgIHRoaXMuY3VycmVudERlbGF5TXMgPSBNYXRoLm1heCh0aGlzLmN1cnJlbnREZWxheU1zLCB0aGlzLmluaXRpYWxEZWxheU1zKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnREZWxheU1zID0gTWF0aC5taW4odGhpcy5jdXJyZW50RGVsYXlNcywgdGhpcy5tYXhEZWxheU1zKTtcclxuICAgICAgICB0aGlzLm51bUF0dGVtcHRzICs9IDE7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmlzSW5CYWNrb2ZmID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzSW5CYWNrb2ZmID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0sIGJhY2tvZmZEZWxheVdpdGhKaXR0ZXJNcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgKy8tIDUwJSBqaXR0ZXIgdG8gdGhlIGJhY2tvZmYgZGVsYXksIHVwIHRvIHRoZSBtYXggZGVsYXkgY2FwLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gZGVsYXlNc1xyXG4gICAgICovXHJcbiAgICB3aXRoSml0dGVyTXMoZGVsYXlNcykge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbihkZWxheU1zICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogZGVsYXlNcywgdGhpcy5tYXhEZWxheU1zKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQSB3cmFwcGVyIGZ1bmN0aW9uIHRvIG1ha2UgaHR0cCByZXF1ZXN0cyBhbmQgcmV0cnkgaWYgdGhlIHJlcXVlc3QgZmFpbHMuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuLy8gVE9ETzogV3JhcCBBeGlvcyBlcnJvciBpbiBBbGNoZW15RXJyb3IuXHJcbmZ1bmN0aW9uIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBhcGlUeXBlLCByZXN0QXBpTmFtZSwgbWV0aG9kTmFtZSwgcGFyYW1zLCBvdmVycmlkZXMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBsZXQgbGFzdEVycm9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKGNvbmZpZy5tYXhSZXRyaWVzKTtcclxuICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IGNvbmZpZy5tYXhSZXRyaWVzICsgMTsgYXR0ZW1wdCsrKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdEVycm9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dJbmZvKCdyZXF1ZXN0SHR0cCcsIGBSZXRyeWluZyBhZnRlciBlcnJvcjogJHtsYXN0RXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgYmFja29mZi5iYWNrb2ZmKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFja29mZiBlcnJvcnMgd2hlbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgYXR0ZW1wdHMgaXMgcmVhY2hlZC4gQnJlYWtcclxuICAgICAgICAgICAgICAgICAgICAvLyBvdXQgb2YgdGhlIGxvb3AgdG8gcHJlc2VydmUgdGhlIGxhc3QgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHNlbmRBeGlvc1JlcXVlc3QoY29uZmlnLl9nZXRSZXF1ZXN0VXJsKGFwaVR5cGUpLCByZXN0QXBpTmFtZSwgbWV0aG9kTmFtZSwgcGFyYW1zLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcyksIHsgdGltZW91dDogY29uZmlnLnJlcXVlc3RUaW1lb3V0IH0pKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKHJlc3RBcGlOYW1lLCBgU3VjY2Vzc2Z1bCByZXF1ZXN0OiAke3Jlc3RBcGlOYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nSW5mbyhyZXN0QXBpTmFtZSwgYFJlcXVlc3QgZmFpbGVkOiAke3Jlc3RBcGlOYW1lfSwgJHtyZXNwb25zZS5zdGF0dXN9LCAke3Jlc3BvbnNlLmRhdGF9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArICc6ICcgKyByZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWF4aW9zX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5pc0F4aW9zRXJyb3IoZXJyKSB8fCBlcnIucmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFN0YW5kYXJkaXplIGFsbCBlcnJvcnMgaW50byBBbGNoZW15RXJyb3JcclxuICAgICAgICAgICAgICAgIGxhc3RFcnJvciA9IG5ldyBFcnJvcihlcnIucmVzcG9uc2Uuc3RhdHVzICsgJzogJyArIEpTT04uc3RyaW5naWZ5KGVyci5yZXNwb25zZS5kYXRhKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cnlhYmxlSHR0cEVycm9yKGVyciwgYXBpVHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobGFzdEVycm9yKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmV0cnlhYmxlSHR0cEVycm9yKGVyciwgYXBpVHlwZSkge1xyXG4gICAgLy8gVE9ETzogcmVtb3ZlIDUwMHMgYWZ0ZXIgd2ViaG9va3MgYXJlIG1vcmUgc3RhYmxlLlxyXG4gICAgY29uc3QgcmV0cnlhYmxlQ29kZXMgPSBhcGlUeXBlID09PSBBbGNoZW15QXBpVHlwZS5XRUJIT09LID8gWzQyOSwgNTAwXSA6IFs0MjldO1xyXG4gICAgcmV0dXJuIChlcnIucmVzcG9uc2UgIT09IHVuZGVmaW5lZCAmJiByZXRyeWFibGVDb2Rlcy5pbmNsdWRlcyhlcnIucmVzcG9uc2Uuc3RhdHVzKSk7XHJcbn1cclxuLyoqXHJcbiAqIEZldGNoZXMgYWxsIHBhZ2VzIGluIGEgcGFnaW5hdGVkIGVuZHBvaW50LCBnaXZlbiBhIGBwYWdlS2V5YCBmaWVsZCB0aGF0XHJcbiAqIHJlcHJlc2VudHMgdGhlIHByb3BlcnR5IG5hbWUgY29udGFpbmluZyB0aGUgbmV4dCBwYWdlIHRva2VuLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHBhZ2luYXRlRW5kcG9pbnQoY29uZmlnLCBhcGlUeXBlLCByZXN0QXBpTmFtZSwgbWV0aG9kTmFtZSwgcmVxUGFnZUtleSwgcmVzUGFnZUtleSwgcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBwYWdpbmF0ZUVuZHBvaW50XzEoKSB7XHJcbiAgICAgICAgbGV0IGhhc05leHQgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xyXG4gICAgICAgIHdoaWxlIChoYXNOZXh0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgX19hd2FpdChyZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgYXBpVHlwZSwgcmVzdEFwaU5hbWUsIG1ldGhvZE5hbWUsIHJlcXVlc3RQYXJhbXMpKTtcclxuICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChyZXNwb25zZSk7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVtyZXNQYWdlS2V5XSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtc1tyZXFQYWdlS2V5XSA9IHJlc3BvbnNlW3Jlc1BhZ2VLZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGFzTmV4dCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbnMgZm9yIGV4cG9zZWQgQVBJIHN1cmZhY2UgaW5cclxuICogdGhlIHtAbGluayBOZnROYW1lc3BhY2V9LiBCeSBtb3ZpbmcgdGhlIG1ldGhvZHMgb3V0IGludG8gYSBzZXBhcmF0ZSBmaWxlLFxyXG4gKiBvdGhlciBuYW1lc3BhY2VzIGNhbiBhY2Nlc3MgdGhlc2UgbWV0aG9kcyB3aXRob3V0IGRlcGVuZGluZyBvbiB0aGUgZW50aXJlXHJcbiAqIE5mdE5hbWVzcGFjZS5cclxuICovXHJcbi8qKlxyXG4gKiBHZXQgdGhlIE5GVCBtZXRhZGF0YSBmb3IgdGhlIHByb3ZpZGVkIGNvbnRyYWN0IGFkZHJlc3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXROZnRNZXRhZGF0YShjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCwgb3B0aW9ucywgc3JjTWV0aG9kID0gJ2dldE5mdE1ldGFkYXRhJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldE5GVE1ldGFkYXRhJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgdG9rZW5JZDogYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHRva2VuSWQpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHRva2VuVHlwZTogc2FuaXRpemVUb2tlblR5cGUob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuVHlwZSksXHJcbiAgICAgICAgICAgIHRva2VuVXJpVGltZW91dEluTXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b2tlblVyaVRpbWVvdXRJbk1zLFxyXG4gICAgICAgICAgICByZWZyZXNoQ2FjaGU6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWZyZXNoQ2FjaGVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0RnJvbVJhdyhyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRNZXRhZGF0YUJhdGNoKGNvbmZpZywgdG9rZW5zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICAgICAgdG9rZW5zLFxyXG4gICAgICAgICAgICB0b2tlblVyaVRpbWVvdXRJbk1zOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9rZW5VcmlUaW1lb3V0SW5NcyxcclxuICAgICAgICAgICAgcmVmcmVzaENhY2hlOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVmcmVzaENhY2hlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRORlRNZXRhZGF0YUJhdGNoJywgJ2dldE5mdE1ldGFkYXRhQmF0Y2gnLCB7fSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZGF0YVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5mdHM6IHJlc3BvbnNlLm5mdHMubWFwKG5mdCA9PiBnZXROZnRGcm9tUmF3KG5mdCkpXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbnRyYWN0TWV0YWRhdGEoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHNyY01ldGhvZCA9ICdnZXRDb250cmFjdE1ldGFkYXRhJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldENvbnRyYWN0TWV0YWRhdGEnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdENvbnRyYWN0RnJvbVJhdyhyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb250cmFjdE1ldGFkYXRhQmF0Y2goY29uZmlnLCBjb250cmFjdEFkZHJlc3Nlcykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldENvbnRyYWN0TWV0YWRhdGFCYXRjaCcsICdnZXRDb250cmFjdE1ldGFkYXRhQmF0Y2gnLCB7fSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZGF0YTogeyBjb250cmFjdEFkZHJlc3NlcyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udHJhY3RzOiByZXNwb25zZS5jb250cmFjdHMubWFwKGdldE5mdENvbnRyYWN0RnJvbVJhdylcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbk1ldGFkYXRhKGNvbmZpZywgY29sbGVjdGlvblNsdWcsIHNyY01ldGhvZCA9ICdnZXRDb2xsZWN0aW9uTWV0YWRhdGEnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0Q29sbGVjdGlvbk1ldGFkYXRhJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25TbHVnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdENvbGxlY3Rpb25Gcm9tUmF3KHJlc3BvbnNlKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5mdHNGb3JPd25lckl0ZXJhdG9yKGNvbmZpZywgb3duZXIsIG9wdGlvbnMsIHNyY01ldGhvZCA9ICdnZXROZnRzRm9yT3duZXJJdGVyYXRvcicpIHtcclxuICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIGdldE5mdHNGb3JPd25lckl0ZXJhdG9yXzEoKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgY29uc3Qgd2l0aE1ldGFkYXRhID0gb21pdE1ldGFkYXRhVG9XaXRoTWV0YWRhdGEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9taXRNZXRhZGF0YSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX2FzeW5jVmFsdWVzKHBhZ2luYXRlRW5kcG9pbnQoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRORlRzRm9yT3duZXInLCBzcmNNZXRob2QsICdwYWdlS2V5JywgJ3BhZ2VLZXknLCB7XHJcbiAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3Nlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRyYWN0QWRkcmVzc2VzLFxyXG4gICAgICAgICAgICAgICAgcGFnZUtleTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VLZXksXHJcbiAgICAgICAgICAgICAgICBleGNsdWRlRmlsdGVyczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV4Y2x1ZGVGaWx0ZXJzLFxyXG4gICAgICAgICAgICAgICAgaW5jbHVkZUZpbHRlcnM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbmNsdWRlRmlsdGVycyxcclxuICAgICAgICAgICAgICAgIG93bmVyLFxyXG4gICAgICAgICAgICAgICAgd2l0aE1ldGFkYXRhLFxyXG4gICAgICAgICAgICAgICAgdG9rZW5VcmlUaW1lb3V0SW5Nczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuVXJpVGltZW91dEluTXMsXHJcbiAgICAgICAgICAgICAgICBvcmRlckJ5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3JkZXJCeVxyXG4gICAgICAgICAgICB9KSksIF9jOyBfYyA9IHlpZWxkIF9fYXdhaXQoX2IubmV4dCgpKSwgIV9jLmRvbmU7KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IF9jLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvd25lZE5mdCBvZiByZXNwb25zZS5vd25lZE5mdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmZ0RnJvbUdldE5mdFJlc3BvbnNlKG93bmVkTmZ0KSksIHsgYmFsYW5jZTogb3duZWROZnQuYmFsYW5jZSB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9hLmNhbGwoX2IpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0c0Zvck93bmVyKGNvbmZpZywgb3duZXIsIG9wdGlvbnMsIHNyY01ldGhvZCA9ICdnZXROZnRzRm9yT3duZXInKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3Qgd2l0aE1ldGFkYXRhID0gb21pdE1ldGFkYXRhVG9XaXRoTWV0YWRhdGEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9taXRNZXRhZGF0YSk7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0TkZUc0Zvck93bmVyJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc2VzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udHJhY3RBZGRyZXNzZXMsXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlS2V5LFxyXG4gICAgICAgICAgICBleGNsdWRlRmlsdGVyczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV4Y2x1ZGVGaWx0ZXJzLFxyXG4gICAgICAgICAgICBpbmNsdWRlRmlsdGVyczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluY2x1ZGVGaWx0ZXJzLFxyXG4gICAgICAgICAgICBvd25lcixcclxuICAgICAgICAgICAgcGFnZVNpemU6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlU2l6ZSxcclxuICAgICAgICAgICAgd2l0aE1ldGFkYXRhLFxyXG4gICAgICAgICAgICB0b2tlblVyaVRpbWVvdXRJbk1zOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9rZW5VcmlUaW1lb3V0SW5NcyxcclxuICAgICAgICAgICAgb3JkZXJCeTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9yZGVyQnlcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAod2l0aE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHtcclxuICAgICAgICAgICAgICAgIG93bmVkTmZ0czogcmVzcG9uc2Uub3duZWROZnRzLm1hcChyZXMgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0TmZ0RnJvbVJhdyhyZXMpKSwgeyBiYWxhbmNlOiByZXMuYmFsYW5jZSB9KSkpLFxyXG4gICAgICAgICAgICAgICAgcGFnZUtleTogcmVzcG9uc2UucGFnZUtleSxcclxuICAgICAgICAgICAgICAgIHRvdGFsQ291bnQ6IHJlc3BvbnNlLnRvdGFsQ291bnQsXHJcbiAgICAgICAgICAgICAgICB2YWxpZEF0OiByZXNwb25zZS52YWxpZEF0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZCh7XHJcbiAgICAgICAgICAgIG93bmVkTmZ0czogcmVzcG9uc2Uub3duZWROZnRzLm1hcChyZXMgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0QmFzZU5mdEZyb21SYXcocmVzKSksIHsgYmFsYW5jZTogcmVzLmJhbGFuY2UgfSkpKSxcclxuICAgICAgICAgICAgcGFnZUtleTogcmVzcG9uc2UucGFnZUtleSxcclxuICAgICAgICAgICAgdG90YWxDb3VudDogcmVzcG9uc2UudG90YWxDb3VudCxcclxuICAgICAgICAgICAgdmFsaWRBdDogcmVzcG9uc2UudmFsaWRBdFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0c0ZvckNvbnRyYWN0KGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBvcHRpb25zLCBzcmNNZXRob2QgPSAnZ2V0TmZ0c0ZvckNvbnRyYWN0Jykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHdpdGhNZXRhZGF0YSA9IG9taXRNZXRhZGF0YVRvV2l0aE1ldGFkYXRhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbWl0TWV0YWRhdGEpO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldE5GVHNGb3JDb250cmFjdCcsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlS2V5LFxyXG4gICAgICAgICAgICB3aXRoTWV0YWRhdGEsXHJcbiAgICAgICAgICAgIGxpbWl0OiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZVNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgdG9rZW5VcmlUaW1lb3V0SW5Nczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuVXJpVGltZW91dEluTXNcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAod2l0aE1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHtcclxuICAgICAgICAgICAgICAgIG5mdHM6IHJlc3BvbnNlLm5mdHMubWFwKHJlcyA9PiBnZXROZnRGcm9tUmF3KHJlcykpLFxyXG4gICAgICAgICAgICAgICAgcGFnZUtleTogcmVzcG9uc2UucGFnZUtleVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoe1xyXG4gICAgICAgICAgICBuZnRzOiByZXNwb25zZS5uZnRzLm1hcChyZXMgPT4gZ2V0QmFzZU5mdEZyb21SYXcocmVzLCBjb250cmFjdEFkZHJlc3MpKSxcclxuICAgICAgICAgICAgcGFnZUtleTogcmVzcG9uc2UucGFnZUtleVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0c0ZvckNvbnRyYWN0SXRlcmF0b3IoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIG9wdGlvbnMsIHNyY01ldGhvZCA9ICdnZXROZnRzRm9yQ29udHJhY3RJdGVyYXRvcicpIHtcclxuICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIGdldE5mdHNGb3JDb250cmFjdEl0ZXJhdG9yXzEoKSB7XHJcbiAgICAgICAgdmFyIGVfMiwgX2E7XHJcbiAgICAgICAgY29uc3Qgd2l0aE1ldGFkYXRhID0gb21pdE1ldGFkYXRhVG9XaXRoTWV0YWRhdGEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9taXRNZXRhZGF0YSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX2FzeW5jVmFsdWVzKHBhZ2luYXRlRW5kcG9pbnQoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRORlRzRm9yQ29udHJhY3QnLCBzcmNNZXRob2QsICdwYWdlS2V5JywgJ3BhZ2VLZXknLCB7XHJcbiAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICBwYWdlS2V5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleSxcclxuICAgICAgICAgICAgICAgIHdpdGhNZXRhZGF0YVxyXG4gICAgICAgICAgICB9KSksIF9jOyBfYyA9IHlpZWxkIF9fYXdhaXQoX2IubmV4dCgpKSwgIV9jLmRvbmU7KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IF9jLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZnQgb2YgcmVzcG9uc2UubmZ0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQobmZ0RnJvbUdldE5mdENvbnRyYWN0UmVzcG9uc2UobmZ0LCBjb250cmFjdEFkZHJlc3MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2EuY2FsbChfYikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRPd25lcnNGb3JDb250cmFjdChjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucywgc3JjTWV0aG9kID0gJ2dldE93bmVyc0ZvckNvbnRyYWN0Jykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIC8vIENhc3QgdG8gYGFueWAgdG8gYXZvaWQgbW9yZSB0eXBlIHdyYW5nbGluZy5cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRPd25lcnNGb3JDb250cmFjdCcsIHNyY01ldGhvZCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBjb250cmFjdEFkZHJlc3MgfSkpO1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2l0aFRva2VuQmFsYW5jZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoe1xyXG4gICAgICAgICAgICAgICAgb3duZXJzOiByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgICAgIC5vd25lcnMsXHJcbiAgICAgICAgICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdlS2V5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZCh7XHJcbiAgICAgICAgICAgIG93bmVyczogcmVzcG9uc2Uub3duZXJzLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdlS2V5XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb250cmFjdHNGb3JPd25lcihjb25maWcsIG93bmVyLCBvcHRpb25zLCBzcmNNZXRob2QgPSAnZ2V0Q29udHJhY3RzRm9yT3duZXInKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0Q29udHJhY3RzRm9yT3duZXInLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgb3duZXIsXHJcbiAgICAgICAgICAgIGV4Y2x1ZGVGaWx0ZXJzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXhjbHVkZUZpbHRlcnMsXHJcbiAgICAgICAgICAgIGluY2x1ZGVGaWx0ZXJzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5jbHVkZUZpbHRlcnMsXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlS2V5LFxyXG4gICAgICAgICAgICBwYWdlU2l6ZTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VTaXplLFxyXG4gICAgICAgICAgICBvcmRlckJ5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub3JkZXJCeVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHtcclxuICAgICAgICAgICAgY29udHJhY3RzOiByZXNwb25zZS5jb250cmFjdHMubWFwKGdldE5mdENvbnRyYWN0c0Zvck93bmVyRnJvbVJhdyksXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IHJlc3BvbnNlLnBhZ2VLZXksXHJcbiAgICAgICAgICAgIHRvdGFsQ291bnQ6IHJlc3BvbnNlLnRvdGFsQ291bnRcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE93bmVyc0Zvck5mdChjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCwgb3B0aW9ucywgc3JjTWV0aG9kID0gJ2dldE93bmVyc0Zvck5mdCcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICByZXR1cm4gcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldE93bmVyc0Zvck5GVCcsIHNyY01ldGhvZCwgT2JqZWN0LmFzc2lnbih7IGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZDogYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHRva2VuSWQpLnRvU3RyaW5nKCkgfSwgb3B0aW9ucykpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TWludGVkTmZ0cyhjb25maWcsIG93bmVyLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBjb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICBjb25zdCBvd25lckFkZHJlc3MgPSB5aWVsZCBwcm92aWRlci5fZ2V0QWRkcmVzcyhvd25lcik7XHJcbiAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBuZnRUb2tlblR5cGVUb0NhdGVnb3J5KG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b2tlblR5cGUpO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgZnJvbUJsb2NrOiAnMHgwJyxcclxuICAgICAgICAgICAgZnJvbUFkZHJlc3M6IEVUSF9OVUxMX0FERFJFU1MsXHJcbiAgICAgICAgICAgIHRvQWRkcmVzczogb3duZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICBleGNsdWRlWmVyb1ZhbHVlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3Nlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRyYWN0QWRkcmVzc2VzLFxyXG4gICAgICAgICAgICBjYXRlZ29yeSxcclxuICAgICAgICAgICAgbWF4Q291bnQ6IDEwMCxcclxuICAgICAgICAgICAgcGFnZUtleTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VLZXlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZ2V0QXNzZXRUcmFuc2ZlcnMoY29uZmlnLCBwYXJhbXMsICdnZXRNaW50ZWROZnRzJyk7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdHNGb3JUcmFuc2ZlcnMoY29uZmlnLCByZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2ZlcnNGb3JPd25lcihjb25maWcsIG93bmVyLCB0cmFuc2ZlclR5cGUsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIGNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgIGNvbnN0IG93bmVyQWRkcmVzcyA9IHlpZWxkIHByb3ZpZGVyLl9nZXRBZGRyZXNzKG93bmVyKTtcclxuICAgICAgICBjb25zdCBjYXRlZ29yeSA9IG5mdFRva2VuVHlwZVRvQ2F0ZWdvcnkob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuVHlwZSk7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICBmcm9tQmxvY2s6ICcweDAnLFxyXG4gICAgICAgICAgICBleGNsdWRlWmVyb1ZhbHVlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3Nlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRyYWN0QWRkcmVzc2VzLFxyXG4gICAgICAgICAgICBjYXRlZ29yeSxcclxuICAgICAgICAgICAgbWF4Q291bnQ6IDEwMCxcclxuICAgICAgICAgICAgcGFnZUtleTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VLZXlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0cmFuc2ZlclR5cGUgPT09IGV4cG9ydHMuR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGUuVE8pIHtcclxuICAgICAgICAgICAgcGFyYW1zLnRvQWRkcmVzcyA9IG93bmVyQWRkcmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5mcm9tQWRkcmVzcyA9IG93bmVyQWRkcmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJhbnNmZXJzUmVzcG9uc2UgPSB5aWVsZCBnZXRBc3NldFRyYW5zZmVycyhjb25maWcsIHBhcmFtcywgJ2dldFRyYW5zZmVyc0Zvck93bmVyJyk7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdHNGb3JUcmFuc2ZlcnMoY29uZmlnLCB0cmFuc2ZlcnNSZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2ZlcnNGb3JDb250cmFjdChjb25maWcsIGNvbnRyYWN0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBbXHJcbiAgICAgICAgICAgIGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeS5FUkM3MjEsXHJcbiAgICAgICAgICAgIGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeS5FUkMxMTU1LFxyXG4gICAgICAgICAgICBleHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkuU1BFQ0lBTE5GVFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBjb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICBjb25zdCBmcm9tQmxvY2sgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZyb21CbG9jaylcclxuICAgICAgICAgICAgPyBwcm92aWRlci5mb3JtYXR0ZXIuYmxvY2tUYWcoeWllbGQgcHJvdmlkZXIuX2dldEJsb2NrVGFnKG9wdGlvbnMuZnJvbUJsb2NrKSlcclxuICAgICAgICAgICAgOiAnMHgwJztcclxuICAgICAgICBjb25zdCB0b0Jsb2NrID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b0Jsb2NrKVxyXG4gICAgICAgICAgICA/IHByb3ZpZGVyLmZvcm1hdHRlci5ibG9ja1RhZyh5aWVsZCBwcm92aWRlci5fZ2V0QmxvY2tUYWcob3B0aW9ucy50b0Jsb2NrKSlcclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICBmcm9tQmxvY2ssXHJcbiAgICAgICAgICAgIHRvQmxvY2ssXHJcbiAgICAgICAgICAgIGV4Y2x1ZGVaZXJvVmFsdWU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc2VzOiBbY29udHJhY3RdLFxyXG4gICAgICAgICAgICBvcmRlcjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9yZGVyLFxyXG4gICAgICAgICAgICBjYXRlZ29yeSxcclxuICAgICAgICAgICAgbWF4Q291bnQ6IDEwMCxcclxuICAgICAgICAgICAgcGFnZUtleTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VLZXlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZmVyc1Jlc3BvbnNlID0geWllbGQgZ2V0QXNzZXRUcmFuc2ZlcnMoY29uZmlnLCBwYXJhbXMsICdnZXRUcmFuc2ZlcnNGb3JDb250cmFjdCcpO1xyXG4gICAgICAgIHJldHVybiBnZXROZnRzRm9yVHJhbnNmZXJzKGNvbmZpZywgdHJhbnNmZXJzUmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbmZ0VG9rZW5UeXBlVG9DYXRlZ29yeSh0b2tlblR5cGUpIHtcclxuICAgIHN3aXRjaCAodG9rZW5UeXBlKSB7XHJcbiAgICAgICAgY2FzZSBleHBvcnRzLk5mdFRva2VuVHlwZS5FUkM3MjE6XHJcbiAgICAgICAgICAgIHJldHVybiBbZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5LkVSQzcyMV07XHJcbiAgICAgICAgY2FzZSBleHBvcnRzLk5mdFRva2VuVHlwZS5FUkMxMTU1OlxyXG4gICAgICAgICAgICByZXR1cm4gW2V4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeS5FUkMxMTU1XTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5LkVSQzcyMSxcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeS5FUkMxMTU1LFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5LlNQRUNJQUxORlRcclxuICAgICAgICAgICAgXTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZTExNTVUcmFuc2Zlcih0cmFuc2Zlcikge1xyXG4gICAgcmV0dXJuIHRyYW5zZmVyLmVyYzExNTVNZXRhZGF0YS5tYXAobWV0YWRhdGEgPT4gKHtcclxuICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRyYW5zZmVyLnJhd0NvbnRyYWN0LmFkZHJlc3MsXHJcbiAgICAgICAgdG9rZW5JZDogbWV0YWRhdGEudG9rZW5JZCxcclxuICAgICAgICB0b2tlblR5cGU6IGV4cG9ydHMuTmZ0VG9rZW5UeXBlLkVSQzExNTVcclxuICAgIH0pKTtcclxufVxyXG5mdW5jdGlvbiB2ZXJpZnlOZnRPd25lcnNoaXAoY29uZmlnLCBvd25lciwgY29udHJhY3RBZGRyZXNzZXMsIHNyY01ldGhvZCA9ICd2ZXJpZnlOZnRPd25lcnNoaXAnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb250cmFjdEFkZHJlc3NlcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBnZXROZnRzRm9yT3duZXIoY29uZmlnLCBvd25lciwge1xyXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzZXM6IFtjb250cmFjdEFkZHJlc3Nlc10sXHJcbiAgICAgICAgICAgICAgICBvbWl0TWV0YWRhdGE6IHRydWVcclxuICAgICAgICAgICAgfSwgc3JjTWV0aG9kKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm93bmVkTmZ0cy5sZW5ndGggPiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRyYWN0QWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lIGNvbnRyYWN0IGFkZHJlc3MnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGdldE5mdHNGb3JPd25lcihjb25maWcsIG93bmVyLCB7XHJcbiAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3NlcyxcclxuICAgICAgICAgICAgICAgIG9taXRNZXRhZGF0YTogdHJ1ZVxyXG4gICAgICAgICAgICB9LCBzcmNNZXRob2QpO1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgbWFwIHdoZXJlIGFsbCBpbnB1dCBjb250cmFjdCBhZGRyZXNzZXMgYXJlIHNldCB0byBmYWxzZSwgdGhlbiBmbGlwXHJcbiAgICAgICAgICAgIC8vIG93bmVkIG5mdHMgdG8gdHJ1ZS5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29udHJhY3RBZGRyZXNzZXMucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcclxuICAgICAgICAgICAgICAgIGFjY1tjdXJyXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcclxuICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5mdCBvZiByZXNwb25zZS5vd25lZE5mdHMpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtuZnQuY29udHJhY3RBZGRyZXNzXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpc1NwYW1Db250cmFjdChjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgc3JjTWV0aG9kID0gJ2lzU3BhbUNvbnRyYWN0Jykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHJldHVybiByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnaXNTcGFtQ29udHJhY3QnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRTcGFtQ29udHJhY3RzKGNvbmZpZywgc3JjTWV0aG9kID0gJ2dldFNwYW1Db250cmFjdHMnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRTcGFtQ29udHJhY3RzJywgc3JjTWV0aG9kLCB1bmRlZmluZWQpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb3J0U3BhbShjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgc3JjTWV0aG9kID0gJ3JlcG9ydFNwYW0nKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdm9pZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAncmVwb3J0U3BhbScsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3NcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGlzQWlyZHJvcE5mdChjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCwgc3JjTWV0aG9kID0gJ2lzQWlyZHJvcE5mdCcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICByZXR1cm4gcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2lzQWlyZHJvcE5GVCcsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgIHRva2VuSWRcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEZsb29yUHJpY2UoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHNyY01ldGhvZCA9ICdnZXRGbG9vclByaWNlJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldEZsb29yUHJpY2UnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0U2FsZXMoY29uZmlnLCBvcHRpb25zID0ge30sIHNyY01ldGhvZCA9ICdnZXROZnRTYWxlcycpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyBBdm9pZCB0cyBjb21waWxlciBjb21wbGFpbmluZyBhYm91dCB0aGUgY29udHJhY3RBZGRyZXNzIGZpZWxkLlxyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldE5GVFNhbGVzJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGZyb21CbG9jazogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmZyb21CbG9jayxcclxuICAgICAgICAgICAgdG9CbG9jazogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnRvQmxvY2ssXHJcbiAgICAgICAgICAgIG9yZGVyOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMub3JkZXIsXHJcbiAgICAgICAgICAgIG1hcmtldHBsYWNlOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMubWFya2V0cGxhY2UsXHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgdG9rZW5JZDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy50b2tlbklkKVxyXG4gICAgICAgICAgICAgICAgPyBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20ocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnRva2VuSWQpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBzZWxsZXJBZGRyZXNzOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuc2VsbGVyQWRkcmVzcyxcclxuICAgICAgICAgICAgYnV5ZXJBZGRyZXNzOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYnV5ZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICB0YWtlcjogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnRha2VyLFxyXG4gICAgICAgICAgICBsaW1pdDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmxpbWl0LFxyXG4gICAgICAgICAgICBwYWdlS2V5OiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGFnZUtleVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBnZXROZnRTYWxlc0Zyb21SYXcocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZVJhcml0eShjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCwgc3JjTWV0aG9kID0gJ2NvbXB1dGVSYXJpdHknKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnY29tcHV0ZVJhcml0eScsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgIHRva2VuSWQ6IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh0b2tlbklkKS50b1N0cmluZygpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc2VhcmNoQ29udHJhY3RNZXRhZGF0YShjb25maWcsIHF1ZXJ5LCBzcmNNZXRob2QgPSAnc2VhcmNoQ29udHJhY3RNZXRhZGF0YScpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdzZWFyY2hDb250cmFjdE1ldGFkYXRhJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udHJhY3RzOiByZXNwb25zZS5jb250cmFjdHMubWFwKGdldE5mdENvbnRyYWN0RnJvbVJhdylcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc3VtbWFyaXplTmZ0QXR0cmlidXRlcyhjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgc3JjTWV0aG9kID0gJ3N1bW1hcml6ZU5mdEF0dHJpYnV0ZXMnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdzdW1tYXJpemVORlRBdHRyaWJ1dGVzJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmcmVzaE5mdE1ldGFkYXRhKGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkLCBzcmNNZXRob2QgPSAncmVmcmVzaE5mdE1ldGFkYXRhJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHRva2VuSWRTdHJpbmcgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odG9rZW5JZCkudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBmaXJzdCA9IHlpZWxkIGdldE5mdE1ldGFkYXRhKGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkU3RyaW5nLCB1bmRlZmluZWQsIHNyY01ldGhvZCk7XHJcbiAgICAgICAgY29uc3Qgc2Vjb25kID0geWllbGQgcmVmcmVzaChjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZFN0cmluZywgc3JjTWV0aG9kKTtcclxuICAgICAgICByZXR1cm4gZmlyc3QudGltZUxhc3RVcGRhdGVkICE9PSBzZWNvbmQudGltZUxhc3RVcGRhdGVkO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmcmVzaENvbnRyYWN0KGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBzcmNNZXRob2QgPSAncmVmcmVzaENvbnRyYWN0Jykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ3JlaW5nZXN0Q29udHJhY3QnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiByZXNwb25zZS5jb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgIHJlZnJlc2hTdGF0ZTogcGFyc2VSZWluZ2VzdGlvblN0YXRlKHJlc3BvbnNlLnJlaW5nZXN0aW9uU3RhdGUpLFxyXG4gICAgICAgICAgICBwcm9ncmVzczogcmVzcG9uc2UucHJvZ3Jlc3NcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmcmVzaChjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCwgc3JjTWV0aG9kKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0TkZUTWV0YWRhdGEnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICB0b2tlbklkOiBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odG9rZW5JZCkudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgcmVmcmVzaENhY2hlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdEZyb21SYXcocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciBtZXRob2QgdG8gY29udmVydCBhIE5GVCByZXNwb25zZSByZWNlaXZlZCBmcm9tIEFsY2hlbXkgYmFja2VuZCB0byBhblxyXG4gKiBTREsgTkZUIHR5cGUuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gbmZ0RnJvbUdldE5mdFJlc3BvbnNlKG93bmVkTmZ0KSB7XHJcbiAgICBpZiAoaXNOZnRXaXRoTWV0YWRhdGEob3duZWROZnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdEZyb21SYXcob3duZWROZnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEJhc2VOZnRGcm9tUmF3KG93bmVkTmZ0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIG1ldGhvZCB0byBjb252ZXJ0IGEgTkZUIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gQWxjaGVteSBiYWNrZW5kIHRvIGFuXHJcbiAqIFNESyBORlQgdHlwZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBuZnRGcm9tR2V0TmZ0Q29udHJhY3RSZXNwb25zZShvd25lZE5mdCwgY29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICBpZiAoaXNOZnRXaXRoTWV0YWRhdGEob3duZWROZnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdEZyb21SYXcob3duZWROZnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEJhc2VOZnRGcm9tUmF3KG93bmVkTmZ0LCBjb250cmFjdEFkZHJlc3MpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuLy8gVE9ETzogbW9yZSBjb21wcmVoZW5zaXZlIHR5cGUgY2hlY2tcclxuZnVuY3Rpb24gaXNOZnRXaXRoTWV0YWRhdGEocmVzcG9uc2UpIHtcclxuICAgIHJldHVybiByZXNwb25zZS5uYW1lICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGFuIEFzc2V0VHJhbnNmZXJzUmVzcG9uc2UsIGZldGNoZXMgdGhlIE5GVHMgYXNzb2NpYXRlZCB3aXRoIHRoZVxyXG4gKiB0cmFuc2ZlcnMgYW5kIGNvbGxhdGVzIHRoZW0gd2l0aCB0cmFuc2ZlciBtZXRhZGF0YS5cclxuICpcclxuICogVklTSUJMRSBGT1IgVEVTVElOR1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmZ0c0ZvclRyYW5zZmVycyhjb25maWcsIHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGFUcmFuc2ZlcnMgPSByZXNwb25zZS50cmFuc2ZlcnNcclxuICAgICAgICAgICAgLmZpbHRlcih0cmFuc2ZlciA9PiB0cmFuc2Zlci5yYXdDb250cmFjdC5hZGRyZXNzICE9PSBudWxsKVxyXG4gICAgICAgICAgICAvLyBVc2UgZmxhdE1hcCB0byBmbGF0dGVuIDExNTUgdHJhbnNmZXJzIHRoYXQgY29udGFpbiBtdWx0aXBsZSBORlRzLlxyXG4gICAgICAgICAgICAuZmxhdE1hcCh0cmFuc2ZlciA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5zRnJvbVRyYW5zZmVyKHRyYW5zZmVyKTtcclxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBmcm9tOiB0cmFuc2Zlci5mcm9tLFxyXG4gICAgICAgICAgICAgICAgdG86IChfYSA9IHRyYW5zZmVyLnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IHRyYW5zZmVyLmhhc2gsXHJcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdHJhbnNmZXIuYmxvY2tOdW1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAodG9rZW4gPT4gKHsgbWV0YWRhdGEsIHRva2VuIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobWV0YWRhdGFUcmFuc2ZlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG5mdHM6IFtdIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDEwMCBlbGVtZW50cyBhZnRlciB1bnJvbGxpbmcgMTE1NSB0cmFuc2ZlcnMsIHNwbGl0XHJcbiAgICAgICAgLy8gdHJhbnNmZXJzIGludG8gYmF0Y2hlcyBvZiAxMDAgdG8gc3RheSB1bmRlciBlbmRwb2ludCBiYXRjaCBzaXplIGxpbWl0LlxyXG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDEwMDtcclxuICAgICAgICBjb25zdCByZXF1ZXN0QmF0Y2hlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YWRhdGFUcmFuc2ZlcnMubGVuZ3RoOyBpICs9IGJhdGNoU2l6ZSkge1xyXG4gICAgICAgICAgICByZXF1ZXN0QmF0Y2hlcy5wdXNoKG1ldGFkYXRhVHJhbnNmZXJzLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VCYXRjaGVzID0geWllbGQgUHJvbWlzZS5hbGwocmVxdWVzdEJhdGNoZXMubWFwKGJhdGNoID0+IGdldE5mdE1ldGFkYXRhQmF0Y2goY29uZmlnLCBiYXRjaC5tYXAodHJhbnNmZXIgPT4gdHJhbnNmZXIudG9rZW4pKSkpO1xyXG4gICAgICAgIGNvbnN0IG5mdHMgPSByZXNwb25zZUJhdGNoZXMubWFwKHIgPT4gci5uZnRzKS5mbGF0KCk7XHJcbiAgICAgICAgLy8gVGhlIHNhbWUgTkZUIGNhbiBiZSB0cmFuc2ZlcnJlZCBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0cmFuc2ZlcnMgcmVzcG9uc2UuXHJcbiAgICAgICAgLy8gV2Ugd2FudCB0byByZXR1cm4gb25lIE5GVCBmb3IgZWFjaCB0cmFuc2Zlciwgc28gd2UgY3JlYXRlIGEgbWFwcGluZyBmb3JcclxuICAgICAgICAvLyBlYWNoIE5GVCB0byBwYWlyIHdpdGggdGhlIHRyYW5zZmVyIG1ldGFkYXRhLlxyXG4gICAgICAgIGNvbnN0IG5mdHNCeVRva2VuSWQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgbmZ0cy5mb3JFYWNoKG5mdCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke25mdC5jb250cmFjdC5hZGRyZXNzLnRvTG93ZXJDYXNlKCl9LSR7YmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKG5mdC50b2tlbklkKS50b1N0cmluZygpfWA7XHJcbiAgICAgICAgICAgIG5mdHNCeVRva2VuSWQuc2V0KGtleSwgbmZ0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB0cmFuc2ZlcnJlZE5mdHMgPSBtZXRhZGF0YVRyYW5zZmVycy5tYXAodCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke3QudG9rZW4uY29udHJhY3RBZGRyZXNzLnRvTG93ZXJDYXNlKCl9LSR7YmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHQudG9rZW4udG9rZW5JZCkudG9TdHJpbmcoKX1gO1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZnRzQnlUb2tlbklkLmdldChrZXkpKSwgdC5tZXRhZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmZ0czogdHJhbnNmZXJyZWROZnRzLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdlS2V5XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIE5GVCB0b2tlbnMgZnJvbSBhIHRyYW5zZmVyIGFzIHRoZSBwYXJhbXMgZm9yIGFcclxuICogYGdldE5mdE1ldGFkYXRhQmF0Y2hgIGNhbGwuIEhhbmRsZXMgdGhlIDExNTUgY2FzZSB3aGVyZSBtdWx0aXBsZSBORlRzIGNhbiBiZVxyXG4gKiB0cmFuc2ZlcnJlZCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGdldFRva2Vuc0Zyb21UcmFuc2Zlcih0cmFuc2Zlcikge1xyXG4gICAgLy8gRVJDMTE1NSBORlRzIGNhbiBjb250YWluIG11bHRpcGxlIHRva2VucyBpbiBhIHNpbmdsZSB0cmFuc2Zlciwgd2hpY2hcclxuICAgIC8vIHJlcXVpcmVzIHNwZWNpYWwgbG9naWMuXHJcbiAgICBpZiAodHJhbnNmZXIuY2F0ZWdvcnkgPT09IGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeS5FUkMxMTU1KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlMTE1NVRyYW5zZmVyKHRyYW5zZmVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHJhbnNmZXIucmF3Q29udHJhY3QuYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIHRva2VuSWQ6IHRyYW5zZmVyLnRva2VuSWQsXHJcbiAgICAgICAgICAgICAgICB0b2tlblR5cGU6IHRyYW5zZmVyLmNhdGVnb3J5ID09PSBleHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkuRVJDNzIxXHJcbiAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRzLk5mdFRva2VuVHlwZS5FUkM3MjFcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRmxpcHMgdGhlIGBvbWl0TWV0YWRhdGFgIFNESyBwYXJhbWV0ZXIgdHlwZSB0byB0aGUgYHdpdGhNZXRhZGF0YWAgcGFyYW1ldGVyXHJcbiAqIHJlcXVpcmVkIGJ5IHRoZSBBbGNoZW15IEFQSS4gSWYgYG9taXRNZXRhZGF0YWAgaXMgdW5kZWZpbmVkLCB0aGUgU0RLIGRlZmF1bHRzXHJcbiAqIHRvIGluY2x1ZGluZyBtZXRhZGF0YS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBvbWl0TWV0YWRhdGFUb1dpdGhNZXRhZGF0YShvbWl0TWV0YWRhdGEpIHtcclxuICAgIHJldHVybiBvbWl0TWV0YWRhdGEgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhb21pdE1ldGFkYXRhO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlUmVpbmdlc3Rpb25TdGF0ZShyZWluZ2VzdGlvblN0YXRlKSB7XHJcbiAgICBzd2l0Y2ggKHJlaW5nZXN0aW9uU3RhdGUpIHtcclxuICAgICAgICBjYXNlICdkb2VzX25vdF9leGlzdCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZS5ET0VTX05PVF9FWElTVDtcclxuICAgICAgICBjYXNlICdhbHJlYWR5X3F1ZXVlZCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZS5BTFJFQURZX1FVRVVFRDtcclxuICAgICAgICBjYXNlICdpbl9wcm9ncmVzcyc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZS5JTl9QUk9HUkVTUztcclxuICAgICAgICBjYXNlICdmaW5pc2hlZCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZS5GSU5JU0hFRDtcclxuICAgICAgICBjYXNlICdxdWV1ZWQnOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRSZWZyZXNoU3RhdGUuUVVFVUVEO1xyXG4gICAgICAgIGNhc2UgJ3F1ZXVlX2ZhaWxlZCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZS5RVUVVRV9GQUlMRUQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHJlaW5nZXN0aW9uIHN0YXRlOiAnICsgcmVpbmdlc3Rpb25TdGF0ZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFRoZSBORlQgbmFtZXNwYWNlIGNvbnRhaW5zIGFsbCB0aGUgZnVuY3Rpb25hbGl0eSByZWxhdGVkIHRvIE5GVHMuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIEFsY2hlbXkgb2JqZWN0XHJcbiAqIHdpdGggYGNvbnN0IGFsY2hlbXkgPSBuZXcgQWxjaGVteShjb25maWcpYCBhbmQgdGhlbiBhY2Nlc3MgdGhlIGNvcmUgbmFtZXNwYWNlXHJcbiAqIHZpYSBgYWxjaGVteS5uZnRgLlxyXG4gKi9cclxuY2xhc3MgTmZ0TmFtZXNwYWNlIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgZ2V0TmZ0TWV0YWRhdGEoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkLCBvcHRpb25zT3JUb2tlblR5cGUsIHRva2VuVXJpVGltZW91dEluTXMpIHtcclxuICAgICAgICBsZXQgb3B0aW9ucztcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPclRva2VuVHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIHRva2VuVHlwZTogb3B0aW9uc09yVG9rZW5UeXBlLnRva2VuVHlwZSxcclxuICAgICAgICAgICAgICAgIHRva2VuVXJpVGltZW91dEluTXM6IG9wdGlvbnNPclRva2VuVHlwZS50b2tlblVyaVRpbWVvdXRJbk1zLFxyXG4gICAgICAgICAgICAgICAgcmVmcmVzaENhY2hlOiBvcHRpb25zT3JUb2tlblR5cGUucmVmcmVzaENhY2hlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgdG9rZW5UeXBlOiBvcHRpb25zT3JUb2tlblR5cGUsXHJcbiAgICAgICAgICAgICAgICB0b2tlblVyaVRpbWVvdXRJbk1zXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnZXROZnRNZXRhZGF0YSh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgTkZUIG1ldGFkYXRhIGZvciBtdWx0aXBsZSBORlQgdG9rZW5zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0b2tlbnMgQW4gYXJyYXkgb2YgTkZUIHRva2VucyB0byBmZXRjaCBtZXRhZGF0YSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIG1ha2luZyB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgZ2V0TmZ0TWV0YWRhdGFCYXRjaCh0b2tlbnMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0TWV0YWRhdGFCYXRjaCh0aGlzLmNvbmZpZywgdG9rZW5zLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBORlQgY29udHJhY3QgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgTkZULlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRDb250cmFjdE1ldGFkYXRhKGNvbnRyYWN0QWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdE1ldGFkYXRhKHRoaXMuY29uZmlnLCBjb250cmFjdEFkZHJlc3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIE5GVCBjb250cmFjdCBtZXRhZGF0YSBmb3IgbXVsdGlwbGUgTkZUIGNvbnRyYWN0cyBpbiBhIHNpbmdsZSByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3NlcyAtIEFuIGFycmF5IG9mIGNvbnRyYWN0IGFkZHJlc3NlcyB0byBmZXRjaCBtZXRhZGF0YSBmb3IuXHJcbiAgICAgKi9cclxuICAgIGdldENvbnRyYWN0TWV0YWRhdGFCYXRjaChjb250cmFjdEFkZHJlc3Nlcykge1xyXG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdE1ldGFkYXRhQmF0Y2godGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzc2VzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBORlQgY29sbGVjdGlvbiBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25TbHVnIC0gVGhlIE9wZW5TZWEgY29sbGVjdGlvbiBzbHVnIG9mIHRoZSBORlQuXHJcbiAgICAgKiBAYmV0YVxyXG4gICAgICovXHJcbiAgICBnZXRDb2xsZWN0aW9uTWV0YWRhdGEoY29sbGVjdGlvblNsdWcpIHtcclxuICAgICAgICByZXR1cm4gZ2V0Q29sbGVjdGlvbk1ldGFkYXRhKHRoaXMuY29uZmlnLCBjb2xsZWN0aW9uU2x1Zyk7XHJcbiAgICB9XHJcbiAgICBnZXROZnRzRm9yT3duZXJJdGVyYXRvcihvd25lciwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBnZXROZnRzRm9yT3duZXJJdGVyYXRvcih0aGlzLmNvbmZpZywgb3duZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZ2V0TmZ0c0Zvck93bmVyKG93bmVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdHNGb3JPd25lcih0aGlzLmNvbmZpZywgb3duZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZ2V0TmZ0c0ZvckNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBnZXROZnRzRm9yQ29udHJhY3QodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBnZXROZnRzRm9yQ29udHJhY3RJdGVyYXRvcihjb250cmFjdEFkZHJlc3MsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0c0ZvckNvbnRyYWN0SXRlcmF0b3IodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBnZXRPd25lcnNGb3JDb250cmFjdChjb250cmFjdEFkZHJlc3MsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0T3duZXJzRm9yQ29udHJhY3QodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIHRoZSBvd25lcnMgZm9yIGEgZ2l2ZW4gTkZUIGNvbnRyYWN0IGFkZHJlc3MgYW5kIHRva2VuIElELlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgTkZUIGNvbnRyYWN0IGFkZHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRva2VuIGlkIG9mIHRoZSBORlQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBiZXRhXHJcbiAgICAgKi9cclxuICAgIGdldE93bmVyc0Zvck5mdChjb250cmFjdEFkZHJlc3MsIHRva2VuSWQsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0T3duZXJzRm9yTmZ0KHRoaXMuY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHRva2VuSWQsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBORlQgY29udHJhY3RzIGhlbGQgYnkgdGhlIHNwZWNpZmllZCBvd25lciBhZGRyZXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvd25lciAtIEFkZHJlc3MgZm9yIE5GVCBvd25lciAoY2FuIGJlIGluIEVOUyBmb3JtYXQhKS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETyh2Myk6IEFkZCBvdmVybG9hZCBmb3Igd2l0aE1ldGFkYXRhPWZhbHNlXHJcbiAgICBnZXRDb250cmFjdHNGb3JPd25lcihvd25lciwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdHNGb3JPd25lcih0aGlzLmNvbmZpZywgb3duZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBORlQgdHJhbnNmZXJzIGZvciBhIGdpdmVuIG93bmVyJ3MgYWRkcmVzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3duZXIgVGhlIG93bmVyIHRvIGdldCB0cmFuc2ZlcnMgZm9yLlxyXG4gICAgICogQHBhcmFtIGNhdGVnb3J5IFdoZXRoZXIgdG8gZ2V0IHRyYW5zZmVycyB0byBvciBmcm9tIHRoZSBvd25lciBhZGRyZXNzLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNmZXJzRm9yT3duZXIob3duZXIsIGNhdGVnb3J5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFRyYW5zZmVyc0Zvck93bmVyKHRoaXMuY29uZmlnLCBvd25lciwgY2F0ZWdvcnksIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBORlQgdHJhbnNmZXJzIGZvciBhIGdpdmVuIE5GVCBjb250cmFjdCBhZGRyZXNzLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHRzIHRvIGFsbCB0cmFuc2ZlcnMgZm9yIHRoZSBjb250cmFjdC4gVG8gZ2V0IHRyYW5zZmVycyBmb3IgYSBzcGVjaWZpY1xyXG4gICAgICogYmxvY2sgcmFuZ2UsIHVzZSB7QGxpbmsgR2V0VHJhbnNmZXJzRm9yQ29udHJhY3RPcHRpb25zfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udHJhY3QgVGhlIE5GVCBjb250cmFjdCB0byBnZXQgdHJhbnNmZXJzIGZvci5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGdldFRyYW5zZmVyc0ZvckNvbnRyYWN0KGNvbnRyYWN0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFRyYW5zZmVyc0ZvckNvbnRyYWN0KHRoaXMuY29uZmlnLCBjb250cmFjdCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgdGhlIE5GVHMgbWludGVkIGJ5IGEgc3BlY2lmaWVkIG93bmVyIGFkZHJlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG93bmVyIC0gQWRkcmVzcyBmb3IgdGhlIE5GVCBvd25lciAoY2FuIGJlIGluIEVOUyBmb3JtYXQpLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9uYWwgcGFyYW1ldGVycyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBnZXRNaW50ZWROZnRzKG93bmVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TWludGVkTmZ0cyh0aGlzLmNvbmZpZywgb3duZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmVyaWZ5TmZ0T3duZXJzaGlwKG93bmVyLCBjb250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gdmVyaWZ5TmZ0T3duZXJzaGlwKHRoaXMuY29uZmlnLCBvd25lciwgY29udHJhY3RBZGRyZXNzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGEgY29udHJhY3QgaXMgbWFya2VkIGFzIHNwYW0gb3Igbm90IGJ5IEFsY2hlbXkuIEZvciBtb3JlXHJcbiAgICAgKiBpbmZvcm1hdGlvbiBvbiBob3cgd2UgY2xhc3NpZnkgc3BhbSwgZ28gdG8gb3VyIE5GVCBBUEkgRkFRIGF0XHJcbiAgICAgKiBodHRwczovL2RvY3MuYWxjaGVteS5jb20vYWxjaGVteS9lbmhhbmNlZC1hcGlzL25mdC1hcGkvbmZ0LWFwaS1mYXEjbmZ0LXNwYW0tY2xhc3NpZmljYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIGNoZWNrLlxyXG4gICAgICovXHJcbiAgICBpc1NwYW1Db250cmFjdChjb250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gaXNTcGFtQ29udHJhY3QodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBzcGFtIGNvbnRyYWN0cyBtYXJrZWQgYnkgQWxjaGVteS4gRm9yIGRldGFpbHMgb24gaG93XHJcbiAgICAgKiBBbGNoZW15IG1hcmtzIHNwYW0gY29udHJhY3RzLCBnbyB0b1xyXG4gICAgICogaHR0cHM6Ly9kb2NzLmFsY2hlbXkuY29tL2FsY2hlbXkvZW5oYW5jZWQtYXBpcy9uZnQtYXBpL25mdC1hcGktZmFxI25mdC1zcGFtLWNsYXNzaWZpY2F0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXRTcGFtQ29udHJhY3RzKCkge1xyXG4gICAgICAgIHJldHVybiBnZXRTcGFtQ29udHJhY3RzKHRoaXMuY29uZmlnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGEgY29udHJhY3QgaXMgbWFya2VkIGFzIHNwYW0gb3Igbm90IGJ5IEFsY2hlbXkuIEZvciBtb3JlXHJcbiAgICAgKiBpbmZvcm1hdGlvbiBvbiBob3cgd2UgY2xhc3NpZnkgc3BhbSwgZ28gdG8gb3VyIE5GVCBBUEkgRkFRIGF0XHJcbiAgICAgKiBodHRwczovL2RvY3MuYWxjaGVteS5jb20vYWxjaGVteS9lbmhhbmNlZC1hcGlzL25mdC1hcGkvbmZ0LWFwaS1mYXEjbmZ0LXNwYW0tY2xhc3NpZmljYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIGNoZWNrLlxyXG4gICAgICovXHJcbiAgICByZXBvcnRTcGFtKGNvbnRyYWN0QWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiByZXBvcnRTcGFtKHRoaXMuY29uZmlnLCBjb250cmFjdEFkZHJlc3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSB0b2tlbiBpcyBtYXJrZWQgYXMgYW4gYWlyZHJvcCBvciBub3QuXHJcbiAgICAgKiBBaXJkcm9wcyBhcmUgZGVmaW5lZCBhcyBORlRzIHRoYXQgd2VyZSBtaW50ZWQgdG8gYSB1c2VyIGFkZHJlc3MgaW4gYSB0cmFuc2FjdGlvblxyXG4gICAgICogc2VudCBieSBhIGRpZmZlcmVudCBhZGRyZXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcyB0byBjaGVjay5cclxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVG9rZW4gaWQgb2YgdGhlIE5GVC5cclxuICAgICAqL1xyXG4gICAgaXNBaXJkcm9wTmZ0KGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCkge1xyXG4gICAgICAgIHJldHVybiBpc0FpcmRyb3BOZnQodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZsb29yIHByaWNlcyBvZiBhIE5GVCBjb250cmFjdCBieSBtYXJrZXRwbGFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gVGhlIGNvbnRyYWN0IGFkZHJlc3MgZm9yIHRoZSBORlQgY29sbGVjdGlvbi5cclxuICAgICAqIEBiZXRhXHJcbiAgICAgKi9cclxuICAgIGdldEZsb29yUHJpY2UoY29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEZsb29yUHJpY2UodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcyk7XHJcbiAgICB9XHJcbiAgICBnZXROZnRTYWxlcyhvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdFNhbGVzKHRoaXMuY29uZmlnLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSByYXJpdHkgb2YgZWFjaCBhdHRyaWJ1dGUgb2YgYW4gTkZULlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBDb250cmFjdCBhZGRyZXNzIGZvciB0aGUgTkZUIGNvbGxlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRva2VuIGlkIG9mIHRoZSBORlQuXHJcbiAgICAgKi9cclxuICAgIGNvbXB1dGVSYXJpdHkoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVSYXJpdHkodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaCBmb3IgYSBrZXl3b3JkIGFjcm9zcyBtZXRhZGF0YSBvZiBhbGwgRVJDLTcyMSBhbmQgRVJDLTExNTUgc21hcnQgY29udHJhY3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBzZWFyY2ggc3RyaW5nIHRoYXQgeW91IHdhbnQgdG8gc2VhcmNoIGZvciBpbiBjb250cmFjdCBtZXRhZGF0YS5cclxuICAgICAqL1xyXG4gICAgc2VhcmNoQ29udHJhY3RNZXRhZGF0YShxdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBzZWFyY2hDb250cmFjdE1ldGFkYXRhKHRoaXMuY29uZmlnLCBxdWVyeSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIHN1bW1hcnkgb2YgYXR0cmlidXRlIHByZXZhbGVuY2UgZm9yIGFuIE5GVCBjb2xsZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBDb250cmFjdCBhZGRyZXNzIGZvciB0aGUgTkZUIGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHN1bW1hcml6ZU5mdEF0dHJpYnV0ZXMoY29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1bW1hcml6ZU5mdEF0dHJpYnV0ZXModGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyB0aGUgY2FjaGVkIG1ldGFkYXRhIGZvciBhIHByb3ZpZGVkIE5GVCBjb250cmFjdCBhZGRyZXNzIGFuZCB0b2tlblxyXG4gICAgICogaWQuIFJldHVybnMgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgbWV0YWRhdGEgd2FzIHJlZnJlc2hlZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byByZWZyZXNoIHRoZSBtZXRhZGF0YSBmb3IgYSBORlQgdGhhdFxyXG4gICAgICogaGFzIGJlZW4gdXBkYXRlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBmZXRjaGVkLiBOb3RlIHRoYXQgdGhlIGJhY2tlbmRcclxuICAgICAqIG9ubHkgYWxsb3dzIG9uZSByZWZyZXNoIHBlciB0b2tlbiBldmVyeSAxNSBtaW51dGVzLCBnbG9iYWxseSBmb3IgYWxsIHVzZXJzLlxyXG4gICAgICogVGhlIGxhc3QgcmVmcmVzaCB0aW1lIGZvciBhbiBORlQgY2FuIGJlIGFjY2Vzc2VkIG9uIHRoZVxyXG4gICAgICoge0BsaW5rIE5mdC50aW1lTGFzdFVwZGF0ZWR9IGZpZWxkLlxyXG4gICAgICpcclxuICAgICAqIFRvIHRyaWdnZXIgYSByZWZyZXNoIGZvciBhbGwgTkZUcyBpbiBhIGNvbnRyYWN0LCB1c2Uge0BsaW5rIHJlZnJlc2hDb250cmFjdH0gaW5zdGVhZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gVGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIE5GVC5cclxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVGhlIHRva2VuIGlkIG9mIHRoZSBORlQuXHJcbiAgICAgKi9cclxuICAgIHJlZnJlc2hOZnRNZXRhZGF0YShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpIHtcclxuICAgICAgICByZXR1cm4gcmVmcmVzaE5mdE1ldGFkYXRhKHRoaXMuY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyBhIG1ldGFkYXRhIHJlZnJlc2ggYWxsIE5GVHMgaW4gdGhlIHByb3ZpZGVkIGNvbnRyYWN0IGFkZHJlc3MuIFRoaXNcclxuICAgICAqIG1ldGhvZCBpcyB1c2VmdWwgYWZ0ZXIgYW4gTkZUIGNvbGxlY3Rpb24gaXMgcmV2ZWFsZWQuXHJcbiAgICAgKlxyXG4gICAgICogUmVmcmVzaGVzIGFyZSBxdWV1ZWQgb24gdGhlIEFsY2hlbXkgYmFja2VuZCBhbmQgbWF5IHRha2UgdGltZSB0byBmdWxseVxyXG4gICAgICogcHJvY2Vzcy4gVG8gcmVmcmVzaCB0aGUgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdG9rZW4sIHVzZSB0aGVcclxuICAgICAqIHtAbGluayByZWZyZXNoTmZ0TWV0YWRhdGF9IG1ldGhvZCBpbnN0ZWFkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgTkZUIGNvbGxlY3Rpb24uXHJcbiAgICAgKiBAYmV0YVxyXG4gICAgICovXHJcbiAgICByZWZyZXNoQ29udHJhY3QoY29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZnJlc2hDb250cmFjdCh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogVGhlIE5vdGlmeSBuYW1lc3BhY2UgY29udGFpbnMgbWV0aG9kcyB1c2VkIGZvciBjcmVhdGluZywgcmVhZGluZywgdXBkYXRpbmcsXHJcbiAqIGFuZCBkZWxldGluZyB3ZWJob29rcyBpbiB0aGUgTm90aWZ5IEFQSS5cclxuICpcclxuICogVG8gdXNlIHRoZSBtZXRob2RzIGluIHRoZSBBUEksIHlvdSBtdXN0IHByb3ZpZGUgeW91ciB0ZWFtJ3MgYXV0aCB0b2tlbiBpbiB0aGVcclxuICoge0BsaW5rIEFsY2hlbXlTZXR0aW5ncy5hdXRoVG9rZW59IGZpZWxkIHdoZW4gY29uZmlndXJpbmdcclxuICoge0BsaW5rIEFsY2hlbXlTZXR0aW5nc30uIFRoZSBhdXRoIHRva2VuIGNhbiBiZSBmb3VuZCBpbiB0aGUgQWxjaGVteSBEYXNoYm9hcmRcclxuICogb24gdGhlIE5vdGlmeSB0YWIuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBub3QgYWxsIG5ldHdvcmtzIGFyZSBzdXBwb3J0ZWQgaW4gdGhlIE5vdGlmeSBBUEkuIFBsZWFzZSBjb25zdWx0XHJcbiAqIHRoZSBkb2N1bWVudGF0aW9uIGZvciB3aGljaCBuZXR3b3JrcyBhcmUgc3VwcG9ydGVkLlxyXG4gKlxyXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCBpbnN0YW50aWF0ZSBhbiBBbGNoZW15IG9iamVjdFxyXG4gKiB3aXRoIGBjb25zdCBhbGNoZW15ID0gbmV3IEFsY2hlbXkoY29uZmlnKWAgYW5kIHRoZW4gYWNjZXNzIHRoZSBub3RpZnlcclxuICogbmFtZXNwYWNlIHZpYSBgYWxjaGVteS5ub3RpZnlgLlxyXG4gKi9cclxuY2xhc3MgTm90aWZ5TmFtZXNwYWNlIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIHdlYmhvb2tzIG9uIHlvdXIgdGVhbS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgdGVhbSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBgYXV0aFRva2VuYCBwcm92aWRlZCBpbnRvIHRoZSB7QGxpbmsgQWxjaGVteVNldHRpbmdzfVxyXG4gICAgICogb2JqZWN0IHdoZW4gY3JlYXRpbmcgYSBuZXcge0BsaW5rIEFsY2hlbXl9IGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSByZXNwb25zZSBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHdlYmhvb2tzXHJcbiAgICAgKi9cclxuICAgIGdldEFsbFdlYmhvb2tzKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJpZnlDb25maWcoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRXZWJob29rUmVxdWVzdCgndGVhbS13ZWJob29rcycsICdnZXRBbGxXZWJob29rcycsIHt9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdlYmhvb2tzOiBwYXJzZVJhd1dlYmhvb2tSZXNwb25zZShyZXNwb25zZSksXHJcbiAgICAgICAgICAgICAgICB0b3RhbENvdW50OiByZXNwb25zZS5kYXRhLmxlbmd0aFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0QWRkcmVzc2VzKHdlYmhvb2tPcklkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcmlmeUNvbmZpZygpO1xyXG4gICAgICAgICAgICBjb25zdCB3ZWJob29rSWQgPSB0eXBlb2Ygd2ViaG9va09ySWQgPT09ICdzdHJpbmcnID8gd2ViaG9va09ySWQgOiB3ZWJob29rT3JJZC5pZDtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRXZWJob29rUmVxdWVzdCgnd2ViaG9vay1hZGRyZXNzZXMnLCAnZ2V0QWRkcmVzc2VzJywge1xyXG4gICAgICAgICAgICAgICAgd2ViaG9va19pZDogd2ViaG9va0lkLFxyXG4gICAgICAgICAgICAgICAgbGltaXQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5saW1pdCxcclxuICAgICAgICAgICAgICAgIGFmdGVyOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmF3QWRkcmVzc0FjdGl2aXR5UmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0R3JhcGhxbFF1ZXJ5KHdlYmhvb2tPcklkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcmlmeUNvbmZpZygpO1xyXG4gICAgICAgICAgICBjb25zdCB3ZWJob29rSWQgPSB0eXBlb2Ygd2ViaG9va09ySWQgPT09ICdzdHJpbmcnID8gd2ViaG9va09ySWQgOiB3ZWJob29rT3JJZC5pZDtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRXZWJob29rUmVxdWVzdCgnZGFzaGJvYXJkLXdlYmhvb2stZ3JhcGhxbC1xdWVyeScsICdnZXRHcmFwaHFsUXVlcnknLCB7XHJcbiAgICAgICAgICAgICAgICB3ZWJob29rX2lkOiB3ZWJob29rSWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVJhd0N1c3RvbUdyYXBocWxXZWJob29rUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0TmZ0RmlsdGVycyh3ZWJob29rT3JJZCwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJpZnlDb25maWcoKTtcclxuICAgICAgICAgICAgY29uc3Qgd2ViaG9va0lkID0gdHlwZW9mIHdlYmhvb2tPcklkID09PSAnc3RyaW5nJyA/IHdlYmhvb2tPcklkIDogd2ViaG9va09ySWQuaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zZW5kV2ViaG9va1JlcXVlc3QoJ3dlYmhvb2stbmZ0LWZpbHRlcnMnLCAnZ2V0TmZ0RmlsdGVycycsIHtcclxuICAgICAgICAgICAgICAgIHdlYmhvb2tfaWQ6IHdlYmhvb2tJZCxcclxuICAgICAgICAgICAgICAgIGxpbWl0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubGltaXQsXHJcbiAgICAgICAgICAgICAgICBhZnRlcjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VLZXlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVJhd05mdEZpbHRlcnNSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVXZWJob29rKHdlYmhvb2tPcklkLCB1cGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdlYmhvb2tJZCA9IHR5cGVvZiB3ZWJob29rT3JJZCA9PT0gJ3N0cmluZycgPyB3ZWJob29rT3JJZCA6IHdlYmhvb2tPcklkLmlkO1xyXG4gICAgICAgICAgICBsZXQgcmVzdEFwaU5hbWU7XHJcbiAgICAgICAgICAgIGxldCBtZXRob2ROYW1lO1xyXG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xyXG4gICAgICAgICAgICBsZXQgZGF0YTtcclxuICAgICAgICAgICAgaWYgKCdpc0FjdGl2ZScgaW4gdXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN0QXBpTmFtZSA9ICd1cGRhdGUtd2ViaG9vayc7XHJcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lID0gJ3VwZGF0ZVdlYmhvb2snO1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ1BVVCc7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlYmhvb2tfaWQ6IHdlYmhvb2tJZCxcclxuICAgICAgICAgICAgICAgICAgICBpc19hY3RpdmU6IHVwZGF0ZS5pc0FjdGl2ZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgnYWRkRmlsdGVycycgaW4gdXBkYXRlIHx8ICdyZW1vdmVGaWx0ZXJzJyBpbiB1cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3RBcGlOYW1lID0gJ3VwZGF0ZS13ZWJob29rLW5mdC1maWx0ZXJzJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAndXBkYXRlV2ViaG9va05mdEZpbHRlcnMnO1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ1BBVENIJztcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2ViaG9va19pZDogd2ViaG9va0lkLFxyXG4gICAgICAgICAgICAgICAgICAgIG5mdF9maWx0ZXJzX3RvX2FkZDogdXBkYXRlLmFkZEZpbHRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1cGRhdGUuYWRkRmlsdGVycy5tYXAobmZ0RmlsdGVyVG9QYXJhbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBuZnRfZmlsdGVyc190b19yZW1vdmU6IHVwZGF0ZS5yZW1vdmVGaWx0ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdXBkYXRlLnJlbW92ZUZpbHRlcnMubWFwKG5mdEZpbHRlclRvUGFyYW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJ2FkZE1ldGFkYXRhRmlsdGVycycgaW4gdXBkYXRlIHx8XHJcbiAgICAgICAgICAgICAgICAncmVtb3ZlTWV0YWRhdGFGaWx0ZXJzJyBpbiB1cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3RBcGlOYW1lID0gJ3VwZGF0ZS13ZWJob29rLW5mdC1tZXRhZGF0YS1maWx0ZXJzJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAndXBkYXRlV2ViaG9va05mdE1ldGFkYXRhRmlsdGVycyc7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnUEFUQ0gnO1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB3ZWJob29rX2lkOiB3ZWJob29rSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbmZ0X21ldGFkYXRhX2ZpbHRlcnNfdG9fYWRkOiB1cGRhdGUuYWRkTWV0YWRhdGFGaWx0ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdXBkYXRlLmFkZE1ldGFkYXRhRmlsdGVycy5tYXAobmZ0RmlsdGVyVG9QYXJhbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBuZnRfbWV0YWRhdGFfZmlsdGVyc190b19yZW1vdmU6IHVwZGF0ZS5yZW1vdmVNZXRhZGF0YUZpbHRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1cGRhdGUucmVtb3ZlTWV0YWRhdGFGaWx0ZXJzLm1hcChuZnRGaWx0ZXJUb1BhcmFtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCdhZGRBZGRyZXNzZXMnIGluIHVwZGF0ZSB8fCAncmVtb3ZlQWRkcmVzc2VzJyBpbiB1cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3RBcGlOYW1lID0gJ3VwZGF0ZS13ZWJob29rLWFkZHJlc3Nlcyc7XHJcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lID0gJ3dlYmhvb2s6dXBkYXRlV2ViaG9va0FkZHJlc3Nlcyc7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnUEFUQ0gnO1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB3ZWJob29rX2lkOiB3ZWJob29rSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzX3RvX2FkZDogeWllbGQgdGhpcy5yZXNvbHZlQWRkcmVzc2VzKHVwZGF0ZS5hZGRBZGRyZXNzZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3Nlc190b19yZW1vdmU6IHlpZWxkIHRoaXMucmVzb2x2ZUFkZHJlc3Nlcyh1cGRhdGUucmVtb3ZlQWRkcmVzc2VzKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgnbmV3QWRkcmVzc2VzJyBpbiB1cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3RBcGlOYW1lID0gJ3VwZGF0ZS13ZWJob29rLWFkZHJlc3Nlcyc7XHJcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lID0gJ3dlYmhvb2s6dXBkYXRlV2ViaG9va0FkZHJlc3MnO1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ1BVVCc7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlYmhvb2tfaWQ6IHdlYmhvb2tJZCxcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IHlpZWxkIHRoaXMucmVzb2x2ZUFkZHJlc3Nlcyh1cGRhdGUubmV3QWRkcmVzc2VzKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBgdXBkYXRlYCBwYXJhbSBwYXNzZWQgaW50byBgdXBkYXRlV2ViaG9va2AnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnNlbmRXZWJob29rUmVxdWVzdChyZXN0QXBpTmFtZSwgbWV0aG9kTmFtZSwge30sIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgICAgIGRhdGFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVXZWJob29rKHVybCwgdHlwZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgYXBwSWQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBleHBvcnRzLldlYmhvb2tUeXBlLk1JTkVEX1RSQU5TQUNUSU9OIHx8XHJcbiAgICAgICAgICAgICAgICB0eXBlID09PSBleHBvcnRzLldlYmhvb2tUeXBlLkRST1BQRURfVFJBTlNBQ1RJT04gfHxcclxuICAgICAgICAgICAgICAgIHR5cGUgPT09IGV4cG9ydHMuV2ViaG9va1R5cGUuR1JBUEhRTCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoJ2FwcElkJyBpbiBwYXJhbXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBhbmQgR3JhcGhRTCBXZWJob29rcyByZXF1aXJlIGFuIGFwcCBpZC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFwcElkID0gcGFyYW1zLmFwcElkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBuZXR3b3JrID0gTkVUV09SS19UT19XRUJIT09LX05FVFdPUksuZ2V0KHRoaXMuY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgICAgICBsZXQgbmZ0RmlsdGVyT2JqO1xyXG4gICAgICAgICAgICBsZXQgYWRkcmVzc2VzO1xyXG4gICAgICAgICAgICBsZXQgZ3JhcGhxbFF1ZXJ5O1xyXG4gICAgICAgICAgICBsZXQgc2tpcEVtcHR5TWVzc2FnZXM7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBleHBvcnRzLldlYmhvb2tUeXBlLk5GVF9BQ1RJVklUWSB8fFxyXG4gICAgICAgICAgICAgICAgdHlwZSA9PT0gZXhwb3J0cy5XZWJob29rVHlwZS5ORlRfTUVUQURBVEFfVVBEQVRFKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoISgnZmlsdGVycycgaW4gcGFyYW1zKSB8fCBwYXJhbXMuZmlsdGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05mdCBBY3Rpdml0eSBXZWJob29rcyByZXF1aXJlIGEgbm9uLWVtcHR5IGFycmF5IGlucHV0LicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV0d29yayA9IHBhcmFtcy5uZXR3b3JrXHJcbiAgICAgICAgICAgICAgICAgICAgPyBORVRXT1JLX1RPX1dFQkhPT0tfTkVUV09SSy5nZXQocGFyYW1zLm5ldHdvcmspXHJcbiAgICAgICAgICAgICAgICAgICAgOiBuZXR3b3JrO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVycyA9IHBhcmFtcy5maWx0ZXJzLm1hcChmaWx0ZXIgPT4gZmlsdGVyLnRva2VuSWRcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3RfYWRkcmVzczogZmlsdGVyLmNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5faWQ6IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShmaWx0ZXIudG9rZW5JZCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3RfYWRkcmVzczogZmlsdGVyLmNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbmZ0RmlsdGVyT2JqID1cclxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBleHBvcnRzLldlYmhvb2tUeXBlLk5GVF9BQ1RJVklUWVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgbmZ0X2ZpbHRlcnM6IGZpbHRlcnMgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgbmZ0X21ldGFkYXRhX2ZpbHRlcnM6IGZpbHRlcnMgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBleHBvcnRzLldlYmhvb2tUeXBlLkFERFJFU1NfQUNUSVZJVFkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICEoJ2FkZHJlc3NlcycgaW4gcGFyYW1zKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5hZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRyZXNzIEFjdGl2aXR5IFdlYmhvb2tzIHJlcXVpcmUgYSBub24tZW1wdHkgYXJyYXkgaW5wdXQuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXR3b3JrID0gcGFyYW1zLm5ldHdvcmtcclxuICAgICAgICAgICAgICAgICAgICA/IE5FVFdPUktfVE9fV0VCSE9PS19ORVRXT1JLLmdldChwYXJhbXMubmV0d29yaylcclxuICAgICAgICAgICAgICAgICAgICA6IG5ldHdvcms7XHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXMgPSB5aWVsZCB0aGlzLnJlc29sdmVBZGRyZXNzZXMocGFyYW1zLmFkZHJlc3Nlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBleHBvcnRzLldlYmhvb2tUeXBlLkdSQVBIUUwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICEoJ2dyYXBocWxRdWVyeScgaW4gcGFyYW1zKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ncmFwaHFsUXVlcnkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXN0b20gV2ViaG9va3MgcmVxdWlyZSBhIG5vbi1lbXB0eSBncmFwaHFsIHF1ZXJ5LicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV0d29yayA9IHBhcmFtcy5uZXR3b3JrXHJcbiAgICAgICAgICAgICAgICAgICAgPyBORVRXT1JLX1RPX1dFQkhPT0tfTkVUV09SSy5nZXQocGFyYW1zLm5ldHdvcmspXHJcbiAgICAgICAgICAgICAgICAgICAgOiBuZXR3b3JrO1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhxbFF1ZXJ5ID0gcGFyYW1zLmdyYXBocWxRdWVyeTtcclxuICAgICAgICAgICAgICAgIHNraXBFbXB0eU1lc3NhZ2VzID0gcGFyYW1zLnNraXBFbXB0eU1lc3NhZ2VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBuZXR3b3JrLCB3ZWJob29rX3R5cGU6IHR5cGUsIHdlYmhvb2tfdXJsOiB1cmwgfSwgKGFwcElkICYmIHsgYXBwX2lkOiBhcHBJZCB9KSksIChwYXJhbXMubmFtZSAmJiB7IG5hbWU6IHBhcmFtcy5uYW1lIH0pKSwgbmZ0RmlsdGVyT2JqKSwgKGFkZHJlc3NlcyAmJiB7IGFkZHJlc3NlcyB9KSksIChncmFwaHFsUXVlcnkgJiYge1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhxbF9xdWVyeToge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBncmFwaHFsUXVlcnksXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcF9lbXB0eV9tZXNzYWdlczogISFza2lwRW1wdHlNZXNzYWdlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zZW5kV2ViaG9va1JlcXVlc3QoJ2NyZWF0ZS13ZWJob29rJywgJ2NyZWF0ZVdlYmhvb2snLCB7fSwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICBkYXRhXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSYXdXZWJob29rKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlV2ViaG9vayh3ZWJob29rT3JJZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJpZnlDb25maWcoKTtcclxuICAgICAgICAgICAgY29uc3Qgd2ViaG9va0lkID0gdHlwZW9mIHdlYmhvb2tPcklkID09PSAnc3RyaW5nJyA/IHdlYmhvb2tPcklkIDogd2ViaG9va09ySWQuaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zZW5kV2ViaG9va1JlcXVlc3QoJ2RlbGV0ZS13ZWJob29rJywgJ2RlbGV0ZVdlYmhvb2snLCB7XHJcbiAgICAgICAgICAgICAgICB3ZWJob29rX2lkOiB3ZWJob29rSWRcclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiByZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXZWJob29rIG5vdCBmb3VuZC4gRmFpbGVkIHRvIGRlbGV0ZSB3ZWJob29rOiAke3dlYmhvb2tJZH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmVyaWZ5Q29uZmlnKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRoVG9rZW4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzaW5nIHRoZSBOb3RpZnkgQVBJIHJlcXVpcmVzIHNldHRpbmcgdGhlIEFsY2hlbXkgQXV0aCBUb2tlbiBpbiAnICtcclxuICAgICAgICAgICAgICAgICd0aGUgc2V0dGluZ3Mgb2JqZWN0IHdoZW4gaW5pdGlhbGl6aW5nIEFsY2hlbXkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFdlYmhvb2tSZXF1ZXN0KHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCBwYXJhbXMsIG92ZXJyaWRlcykge1xyXG4gICAgICAgIHJldHVybiByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKHRoaXMuY29uZmlnLCBBbGNoZW15QXBpVHlwZS5XRUJIT09LLCByZXN0QXBpTmFtZSwgbWV0aG9kTmFtZSwgcGFyYW1zLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcyksIHsgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7ICdYLUFsY2hlbXktVG9rZW4nOiB0aGlzLmNvbmZpZy5hdXRoVG9rZW4gfSwgb3ZlcnJpZGVzID09PSBudWxsIHx8IG92ZXJyaWRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcnJpZGVzLmhlYWRlcnMpIH0pKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXNvbHZlcyBFTlMgYWRkcmVzc2VzIHRvIHRoZSByYXcgYWRkcmVzcy5cclxuICAgICAqIEBpbnRlcm5hbCAqL1xyXG4gICAgcmVzb2x2ZUFkZHJlc3NlcyhhZGRyZXNzZXMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChhZGRyZXNzZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQWRkcmVzc2VzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFkZHJlc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmF3QWRkcmVzcyA9IHlpZWxkIHByb3ZpZGVyLnJlc29sdmVOYW1lKGFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhd0FkZHJlc3MgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXNvbHZlIHRoZSBFTlMgYWRkcmVzczogJHthZGRyZXNzfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBZGRyZXNzZXMucHVzaChyYXdBZGRyZXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRBZGRyZXNzZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hcHBpbmcgb2Ygd2ViaG9vayBuZXR3b3JrIHJlcHJlc2VudGF0aW9ucyB0byB0aGUgU0RLJ3MgbmV0d29yayByZXByZXNlbnRhdGlvbi5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBXRUJIT09LX05FVFdPUktfVE9fTkVUV09SSyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhleHBvcnRzLk5ldHdvcmspKTtcclxuLyoqIE1hcHBpbmcgb2YgdGhlIFNESydzIG5ldHdvcmsgcmVwcmVzZW50YXRpb24gdGhlIHdlYmhvb2sgQVBJJ3MgbmV0d29yayByZXByZXNlbnRhdGlvbi4gKi9cclxuY29uc3QgTkVUV09SS19UT19XRUJIT09LX05FVFdPUksgPSBPYmplY3Qua2V5cyhleHBvcnRzLk5ldHdvcmspLnJlZHVjZSgobWFwLCBrZXkpID0+IHtcclxuICAgIGlmIChrZXkgaW4gV0VCSE9PS19ORVRXT1JLX1RPX05FVFdPUkspIHtcclxuICAgICAgICBtYXAuc2V0KFdFQkhPT0tfTkVUV09SS19UT19ORVRXT1JLW2tleV0sIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWFwO1xyXG59LCBuZXcgTWFwKCkpO1xyXG5mdW5jdGlvbiBwYXJzZVJhd1dlYmhvb2tSZXNwb25zZShyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubWFwKHBhcnNlUmF3V2ViaG9vayk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VSYXdXZWJob29rKHJhd1dlYmhvb2spIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBpZDogcmF3V2ViaG9vay5pZCwgbmV0d29yazogV0VCSE9PS19ORVRXT1JLX1RPX05FVFdPUktbcmF3V2ViaG9vay5uZXR3b3JrXSwgdHlwZTogcmF3V2ViaG9vay53ZWJob29rX3R5cGUsIHVybDogcmF3V2ViaG9vay53ZWJob29rX3VybCwgaXNBY3RpdmU6IHJhd1dlYmhvb2suaXNfYWN0aXZlLCB0aW1lQ3JlYXRlZDogbmV3IERhdGUocmF3V2ViaG9vay50aW1lX2NyZWF0ZWQpLnRvSVNPU3RyaW5nKCksIHNpZ25pbmdLZXk6IHJhd1dlYmhvb2suc2lnbmluZ19rZXksIHZlcnNpb246IHJhd1dlYmhvb2sudmVyc2lvbiB9LCAocmF3V2ViaG9vay5hcHBfaWQgIT09IHVuZGVmaW5lZCAmJiB7IGFwcElkOiByYXdXZWJob29rLmFwcF9pZCB9KSksIChyYXdXZWJob29rLm5hbWUgIT09IHVuZGVmaW5lZCAmJiB7IG5hbWU6IHJhd1dlYmhvb2submFtZSB9KSk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VSYXdBZGRyZXNzQWN0aXZpdHlSZXNwb25zZShyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhZGRyZXNzZXM6IHJlc3BvbnNlLmRhdGEsXHJcbiAgICAgICAgdG90YWxDb3VudDogcmVzcG9uc2UucGFnaW5hdGlvbi50b3RhbF9jb3VudCxcclxuICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdpbmF0aW9uLmN1cnNvcnMuYWZ0ZXJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VSYXdDdXN0b21HcmFwaHFsV2ViaG9va1Jlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdyYXBocWxRdWVyeTogcmVzcG9uc2UuZGF0YS5ncmFwaHFsX3F1ZXJ5XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlUmF3TmZ0RmlsdGVyc1Jlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpbHRlcnM6IHJlc3BvbnNlLmRhdGEubWFwKGYgPT4gZi50b2tlbl9pZFxyXG4gICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogZi5jb250cmFjdF9hZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgdG9rZW5JZDogYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGYudG9rZW5faWQpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogZi5jb250cmFjdF9hZGRyZXNzXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIHRvdGFsQ291bnQ6IHJlc3BvbnNlLnBhZ2luYXRpb24udG90YWxfY291bnQsXHJcbiAgICAgICAgcGFnZUtleTogcmVzcG9uc2UucGFnaW5hdGlvbi5jdXJzb3JzLmFmdGVyXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG5mdEZpbHRlclRvUGFyYW0oZmlsdGVyKSB7XHJcbiAgICByZXR1cm4gZmlsdGVyLnRva2VuSWRcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgY29udHJhY3RfYWRkcmVzczogZmlsdGVyLmNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgdG9rZW5faWQ6IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShmaWx0ZXIudG9rZW5JZCkudG9TdHJpbmcoKVxyXG4gICAgICAgIH1cclxuICAgICAgICA6IHtcclxuICAgICAgICAgICAgY29udHJhY3RfYWRkcmVzczogZmlsdGVyLmNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgIH07XHJcbn1cblxuZnVuY3Rpb24gZ2V0VG9rZW5zQnlXYWxsZXQoY29uZmlnLCBhZGRyZXNzZXMsIHdpdGhNZXRhZGF0YSA9IHRydWUsIHdpdGhQcmljZXMgPSB0cnVlLCBpbmNsdWRlTmF0aXZlVG9rZW5zID0gdHJ1ZSwgc3JjTWV0aG9kID0gJ2dldFRva2Vuc0J5V2FsbGV0Jykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGFkZHJlc3NlcyxcclxuICAgICAgICAgICAgd2l0aE1ldGFkYXRhLFxyXG4gICAgICAgICAgICB3aXRoUHJpY2VzLFxyXG4gICAgICAgICAgICBpbmNsdWRlTmF0aXZlVG9rZW5zXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5QT1JURk9MSU8sICdhc3NldHMvdG9rZW5zL2J5LWFkZHJlc3MnLCBzcmNNZXRob2QsIHt9LCB7XHJcbiAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VG9rZW5CYWxhbmNlc0J5V2FsbGV0KGNvbmZpZywgYWRkcmVzc2VzLCBpbmNsdWRlTmF0aXZlVG9rZW5zID0gdHJ1ZSwgc3JjTWV0aG9kID0gJ2dldFRva2VuQmFsYW5jZXNCeVdhbGxldCcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICBhZGRyZXNzZXMsXHJcbiAgICAgICAgICAgIGluY2x1ZGVOYXRpdmVUb2tlbnNcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLlBPUlRGT0xJTywgJ2Fzc2V0cy90b2tlbnMvYmFsYW5jZXMvYnktYWRkcmVzcycsIHNyY01ldGhvZCwge30sIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGRhdGFcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRzQnlXYWxsZXQoY29uZmlnLCBhZGRyZXNzZXMsIHdpdGhNZXRhZGF0YSA9IHRydWUsIHBhZ2VLZXkgPSB1bmRlZmluZWQsIHBhZ2VTaXplID0gdW5kZWZpbmVkLCBzcmNNZXRob2QgPSAnZ2V0TmZ0c0J5V2FsbGV0Jykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGFkZHJlc3NlcyxcclxuICAgICAgICAgICAgd2l0aE1ldGFkYXRhLFxyXG4gICAgICAgICAgICBwYWdlS2V5LFxyXG4gICAgICAgICAgICBwYWdlU2l6ZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuUE9SVEZPTElPLCAnYXNzZXRzL25mdHMvYnktYWRkcmVzcycsIHNyY01ldGhvZCwge30sIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGRhdGFcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRDb2xsZWN0aW9uc0J5V2FsbGV0KGNvbmZpZywgYWRkcmVzc2VzLCB3aXRoTWV0YWRhdGEgPSB0cnVlLCBwYWdlS2V5ID0gdW5kZWZpbmVkLCBwYWdlU2l6ZSA9IHVuZGVmaW5lZCwgc3JjTWV0aG9kID0gJ2dldE5mdENvbGxlY3Rpb25zQnlXYWxsZXQnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICAgICAgYWRkcmVzc2VzLFxyXG4gICAgICAgICAgICBwYWdlS2V5LFxyXG4gICAgICAgICAgICBwYWdlU2l6ZSxcclxuICAgICAgICAgICAgd2l0aE1ldGFkYXRhXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5QT1JURk9MSU8sICdhc3NldHMvbmZ0cy9jb250cmFjdHMvYnktYWRkcmVzcycsIHNyY01ldGhvZCwge30sIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGRhdGFcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvbnNCeVdhbGxldChjb25maWcsIGFkZHJlc3NlcywgYmVmb3JlID0gdW5kZWZpbmVkLCBhZnRlciA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHNyY01ldGhvZCA9ICdnZXRUcmFuc2FjdGlvbnNCeVdhbGxldCcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICBhZGRyZXNzZXMsXHJcbiAgICAgICAgICAgIGJlZm9yZSxcclxuICAgICAgICAgICAgYWZ0ZXIsXHJcbiAgICAgICAgICAgIGxpbWl0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5QT1JURk9MSU8sICd0cmFuc2FjdGlvbnMvaGlzdG9yeS9ieS1hZGRyZXNzJywgc3JjTWV0aG9kLCB7fSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZGF0YVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHJlc3BvbnNlKTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBUaGUgUG9ydGZvbGlvIG5hbWVzcGFjZSBjb250YWlucyBtZXRob2RzIGZvciBnZXR0aW5nIGRhdGEgbmVlZGVkIHRvIGJ1aWxkIGEgcG9ydGZvbGlvLlxyXG4gKlxyXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCBpbnN0YW50aWF0ZSBhbiBBbGNoZW15IG9iamVjdFxyXG4gKiB3aXRoIGBjb25zdCBhbGNoZW15ID0gbmV3IEFsY2hlbXkoY29uZmlnKWAgYW5kIHRoZW4gYWNjZXNzIHRoZSBwb3J0Zm9saW8gbmFtZXNwYWNlXHJcbiAqIHZpYSBgYWxjaGVteS5wb3J0Zm9saW9gLlxyXG4gKi9cclxuY2xhc3MgUG9ydGZvbGlvTmFtZXNwYWNlIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaGVzIGZ1bmdpYmxlIHRva2VucyAobmF0aXZlIGFuZCBFUkMtMjApIGZvciBtdWx0aXBsZSB3YWxsZXQgYWRkcmVzc2VzXHJcbiAgICAgKiBhbmQgbmV0d29ya3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyAtIEFycmF5IG9mIG5ldHdvcmsvYWRkcmVzcyBwYWlyc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgIChsaW1pdCAyIHBhaXJzLCBtYXggNSBuZXR3b3JrcyBlYWNoKS5cclxuICAgICAqIEBwYXJhbSB3aXRoTWV0YWRhdGEgLSBCb29sZWFuLiBJZiBzZXQgdG8gdHJ1ZSwgcmV0dXJucyBtZXRhZGF0YS4gU2V0dGluZ1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgdG8gZmFsc2Ugd2lsbCByZWR1Y2UgcGF5bG9hZCBzaXplIGFuZFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heSByZXN1bHQgaW4gYSBmYXN0ZXIgQVBJIGNhbGwuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlZmF1bHQ6IHRydWUpXHJcbiAgICAgKiBAcGFyYW0gd2l0aFByaWNlcyAtIEJvb2xlYW4uIElmIHNldCB0byB0cnVlLCByZXR1cm5zIHRva2VuIHByaWNlcy4gU2V0dGluZ1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHRvIGZhbHNlIHdpbGwgcmVkdWNlIHBheWxvYWQgc2l6ZSBhbmQgbWF5XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCBpbiBhIGZhc3RlciBBUEkgY2FsbC4gKGRlZmF1bHQ6IHRydWUpXHJcbiAgICAgKiBAcGFyYW0gaW5jbHVkZU5hdGl2ZVRva2VucyAtIEJvb2xlYW4uIFdoZXRoZXIgdG8gaW5jbHVkZSBlYWNoIGNoYWlu4oCZc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmUgdG9rZW4gaW4gdGhlIHJlc3BvbnNlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLmcuIEVUSCBvbiBFdGhlcmV1bSkuIFRoZSBuYXRpdmVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gd2lsbCBoYXZlIGEgbnVsbCBjb250cmFjdFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLiAoZGVmYXVsdDogdHJ1ZSlcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHRva2VucyB3aXRoIGJhbGFuY2VzLCBwcmljZXMsIGFuZFxyXG4gICAgICogICAgICAgICAgbWV0YWRhdGEgZm9yIGVhY2ggd2FsbGV0L25ldHdvcmsgY29tYmluYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUb2tlbnNCeVdhbGxldChhZGRyZXNzZXMsIHdpdGhNZXRhZGF0YSA9IHRydWUsIHdpdGhQcmljZXMgPSB0cnVlLCBpbmNsdWRlTmF0aXZlVG9rZW5zID0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBnZXRUb2tlbnNCeVdhbGxldCh0aGlzLmNvbmZpZywgYWRkcmVzc2VzLCB3aXRoTWV0YWRhdGEsIHdpdGhQcmljZXMsIGluY2x1ZGVOYXRpdmVUb2tlbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaGVzIGZ1bmdpYmxlIHRva2VucyAobmF0aXZlIGFuZCBFUkMtMjApIGZvciBtdWx0aXBsZSB3YWxsZXQgYWRkcmVzc2VzIGFuZCBuZXR3b3Jrcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIC0gQXJyYXkgb2YgbmV0d29yay9hZGRyZXNzIHBhaXJzIChsaW1pdCAyIHBhaXJzLCBtYXggNSBuZXR3b3JrcyBlYWNoKS5cclxuICAgICAqIEBwYXJhbSBpbmNsdWRlTmF0aXZlVG9rZW5zIC0gQm9vbGVhbi4gV2hldGhlciB0byBpbmNsdWRlIGVhY2ggY2hhaW7igJlzIG5hdGl2ZSB0b2tlbiBpbiB0aGUgcmVzcG9uc2UgKGUuZy4gRVRIIG9uIEV0aGVyZXVtKS4gVGhlIG5hdGl2ZSB0b2tlbiB3aWxsIGhhdmUgYSBudWxsIGNvbnRyYWN0IGFkZHJlc3MuIChkZWZhdWx0OiB0cnVlKSAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGEgbGlzdCBvZiB0b2tlbnMgd2l0aCBiYWxhbmNlcyBmb3IgZWFjaCB3YWxsZXQvbmV0d29yayBjb21iaW5hdGlvblxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUb2tlbkJhbGFuY2VzQnlXYWxsZXQoYWRkcmVzc2VzLCBpbmNsdWRlTmF0aXZlVG9rZW5zID0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBnZXRUb2tlbkJhbGFuY2VzQnlXYWxsZXQodGhpcy5jb25maWcsIGFkZHJlc3NlcywgaW5jbHVkZU5hdGl2ZVRva2Vucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMgTkZUcyBmb3IgbXVsdGlwbGUgd2FsbGV0IGFkZHJlc3NlcyBhbmQgbmV0d29ya3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyAtIEFycmF5IG9mIG5ldHdvcmsvYWRkcmVzcyBwYWlycyB0byBmZXRjaCBORlRzIGZvci5cclxuICAgICAqIEBwYXJhbSB3aXRoTWV0YWRhdGEgLSBCb29sZWFuLiBJZiBzZXQgdG8gdHJ1ZSwgcmV0dXJucyBtZXRhZGF0YS4gU2V0dGluZyB0aGlzIHRvIGZhbHNlIHdpbGwgcmVkdWNlIHBheWxvYWQgc2l6ZSBhbmQgbWF5IHJlc3VsdCBpbiBhIGZhc3RlciBBUEkgY2FsbC4gKGRlZmF1bHQ6IHRydWUpXHJcbiAgICAgKiBAcGFyYW0gcGFnZUtleSAtIE9wdGlvbmFsLiBUaGUgY3Vyc29yIHRoYXQgcG9pbnRzIHRvIHRoZSBjdXJyZW50IHNldCBvZiByZXN1bHRzLlxyXG4gICAgICogQHBhcmFtIHBhZ2VTaXplIC0gT3B0aW9uYWwuIFNldHMgdGhlIG51bWJlciBvZiBpdGVtcyBwZXIgcGFnZS5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhIGxpc3Qgb2YgTkZUcyBhbmQgbWV0YWRhdGEgZm9yIGVhY2ggd2FsbGV0L25ldHdvcmsgY29tYmluYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXROZnRzQnlXYWxsZXQoYWRkcmVzc2VzLCB3aXRoTWV0YWRhdGEgPSB0cnVlLCBwYWdlS2V5LCBwYWdlU2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBnZXROZnRzQnlXYWxsZXQodGhpcy5jb25maWcsIGFkZHJlc3Nlcywgd2l0aE1ldGFkYXRhLCBwYWdlS2V5LCBwYWdlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMgTkZUIGNvbGxlY3Rpb25zIChjb250cmFjdHMpIGZvciBtdWx0aXBsZSB3YWxsZXQgYWRkcmVzc2VzIGFuZCBuZXR3b3Jrcy4gUmV0dXJucyBhIGxpc3Qgb2ZcclxuICAgICAqIGNvbGxlY3Rpb25zIGFuZCBtZXRhZGF0YSBmb3IgZWFjaCB3YWxsZXQvbmV0d29yayBjb21iaW5hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIC0gQXJyYXkgb2YgYWRkcmVzcyBhbmQgbmV0d29ya3MgcGFpcnMgKGxpbWl0IDIgcGFpcnMsIG1heCAxNSBuZXR3b3JrcyBlYWNoKS5cclxuICAgICAqIEBwYXJhbSB3aXRoTWV0YWRhdGEgLSBCb29sZWFuLiBJZiBzZXQgdG8gdHJ1ZSwgcmV0dXJucyBtZXRhZGF0YS4gKGRlZmF1bHQ6IHRydWUpXHJcbiAgICAgKiBAcGFyYW0gcGFnZUtleSAtIE9wdGlvbmFsLiBUaGUgY3Vyc29yIHRoYXQgcG9pbnRzIHRvIHRoZSBjdXJyZW50IHNldCBvZiByZXN1bHRzLlxyXG4gICAgICogQHBhcmFtIHBhZ2VTaXplIC0gT3B0aW9uYWwuIFNldHMgdGhlIG51bWJlciBvZiBpdGVtcyBwZXIgcGFnZS5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhIGxpc3Qgb2YgTkZUIGNvbGxlY3Rpb25zIGZvciBlYWNoIHdhbGxldC9uZXR3b3JrIGNvbWJpbmF0aW9uLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXROZnRDb2xsZWN0aW9uc0J5V2FsbGV0KGFkZHJlc3Nlcywgd2l0aE1ldGFkYXRhID0gdHJ1ZSwgcGFnZUtleSwgcGFnZVNpemUpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0Q29sbGVjdGlvbnNCeVdhbGxldCh0aGlzLmNvbmZpZywgYWRkcmVzc2VzLCB3aXRoTWV0YWRhdGEsIHBhZ2VLZXksIHBhZ2VTaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyBhbGwgaGlzdG9yaWNhbCB0cmFuc2FjdGlvbnMgKGludGVybmFsICYgZXh0ZXJuYWwpIGZvciBtdWx0aXBsZSB3YWxsZXQgYWRkcmVzc2VzIGFuZCBuZXR3b3Jrcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIC0gQXJyYXkgb2YgbmV0d29yay9hZGRyZXNzIHBhaXJzIHRvIGZldGNoIHRyYW5zYWN0aW9ucyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYmVmb3JlIC0gT3B0aW9uYWwuIFRoZSBjdXJzb3IgdGhhdCBwb2ludHMgdG8gdGhlIHByZXZpb3VzIHNldCBvZiByZXN1bHRzLlxyXG4gICAgICogQHBhcmFtIGFmdGVyIC0gT3B0aW9uYWwuIFRoZSBjdXJzb3IgdGhhdCBwb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzZXQgb2YgcmVzdWx0cy5cclxuICAgICAqIEBwYXJhbSBsaW1pdCAtIE9wdGlvbmFsLiBTZXRzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyBwZXIgcGFnZSAoTWF4OiAxMDApXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHRyYW5zYWN0aW9uIG9iamVjdHMgd2l0aCBtZXRhZGF0YSBhbmQgbG9nIGluZm9ybWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNhY3Rpb25zQnlXYWxsZXQoYWRkcmVzc2VzLCBiZWZvcmUsIGFmdGVyLCBsaW1pdCkge1xyXG4gICAgICAgIHJldHVybiBnZXRUcmFuc2FjdGlvbnNCeVdhbGxldCh0aGlzLmNvbmZpZywgYWRkcmVzc2VzLCBiZWZvcmUsIGFmdGVyLCBsaW1pdCk7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZ2V0VG9rZW5QcmljZUJ5QWRkcmVzcyhjb25maWcsIGFkZHJlc3Nlcywgc3JjTWV0aG9kID0gJ2dldFRva2VuUHJpY2VCeUFkZHJlc3MnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuUFJJQ0VTLCAndG9rZW5zL2J5LWFkZHJlc3MnLCBzcmNNZXRob2QsIHt9LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBkYXRhOiB7IGFkZHJlc3NlcyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VG9rZW5QcmljZUJ5U3ltYm9sKGNvbmZpZywgc3ltYm9scywgc3JjTWV0aG9kID0gJ2dldFRva2VuUHJpY2VCeVN5bWJvbCcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5QUklDRVMsICd0b2tlbnMvYnktc3ltYm9sJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIHN5bWJvbHNcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc2VyaWFsaXplIHRoZSBzeW1ib2xzIGFycmF5IGFzIFVSTFNlYXJjaFBhcmFtcyBzaW5jZSB0aGVcclxuICAgICAgICAgICAgLy8gQWxjaGVteSBBUEkgZXhwZWN0cyBhIHF1ZXJ5IHBhcmFtZXRlciBmb3IgZWFjaCBzeW1ib2wuIFRoZSBheGlvcyBkZWZhdWx0XHJcbiAgICAgICAgICAgIC8vIHNlcmlhbGl6ZXIgd2lsbCBub3Qgd29yayBoZXJlIGJlY2F1c2UgdGhlIHN5bWJvbHMgYXJyYXkgaXMgYW4gYXJyYXkgb2ZcclxuICAgICAgICAgICAgLy8gc3RyaW5ncy5cclxuICAgICAgICAgICAgLy8gQXhpb3MgZGVmYXVsdCBlbmNvZGluZzogP3N5bWJvbHNbXT1BQVZFJnN5bWJvbHNbXT1VTklcclxuICAgICAgICAgICAgLy8gQWxjaGVteSByZXF1aXJlczogP3N5bWJvbHM9QUFWRSZzeW1ib2xzPVVOSVxyXG4gICAgICAgICAgICBwYXJhbXNTZXJpYWxpemVyOiBwYXJhbXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdikpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRIaXN0b3JpY2FsUHJpY2VCeVN5bWJvbChjb25maWcsIHN5bWJvbCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBpbnRlcnZhbCwgc3JjTWV0aG9kID0gJ2dldEhpc3RvcmljYWxQcmljZUJ5U3ltYm9sJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLlBSSUNFUywgJ3Rva2Vucy9oaXN0b3JpY2FsJywgc3JjTWV0aG9kLCB7fSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lLFxyXG4gICAgICAgICAgICAgICAgZW5kVGltZSxcclxuICAgICAgICAgICAgICAgIGludGVydmFsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRIaXN0b3JpY2FsUHJpY2VCeUFkZHJlc3MoY29uZmlnLCBuZXR3b3JrLCBhZGRyZXNzLCBzdGFydFRpbWUsIGVuZFRpbWUsIGludGVydmFsLCBzcmNNZXRob2QgPSAnZ2V0SGlzdG9yaWNhbFByaWNlQnlBZGRyZXNzJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLlBSSUNFUywgJ3Rva2Vucy9oaXN0b3JpY2FsJywgc3JjTWV0aG9kLCB7fSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgbmV0d29yayxcclxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUsXHJcbiAgICAgICAgICAgICAgICBlbmRUaW1lLFxyXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHJlc3BvbnNlKTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBUaGUgUHJpY2VzIG5hbWVzcGFjZSBjb250YWlucyBtZXRob2RzIGZvciBnZXR0aW5nIHRva2VuIHByaWNlIGRhdGEuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIEFsY2hlbXkgb2JqZWN0XHJcbiAqIHdpdGggYGNvbnN0IGFsY2hlbXkgPSBuZXcgQWxjaGVteShjb25maWcpYCBhbmQgdGhlbiBhY2Nlc3MgdGhlIHByaWNlcyBuYW1lc3BhY2VcclxuICogdmlhIGBhbGNoZW15LnByaWNlc2AuXHJcbiAqL1xyXG5jbGFzcyBQcmljZXNOYW1lc3BhY2Uge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0b2tlbiBwcmljZXMgYnkgbmV0d29yayBhbmQgY29udHJhY3QgYWRkcmVzcyBwYWlycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIC0gQXJyYXkgb2YgbmV0d29yay9hZGRyZXNzIHBhaXJzIHRvIGdldCBwcmljZXMgZm9yXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgdG9rZW4gcHJpY2UgZGF0YVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUb2tlblByaWNlQnlBZGRyZXNzKGFkZHJlc3Nlcykge1xyXG4gICAgICAgIHJldHVybiBnZXRUb2tlblByaWNlQnlBZGRyZXNzKHRoaXMuY29uZmlnLCBhZGRyZXNzZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdG9rZW4gcHJpY2VzIGJ5IHRva2VuIHN5bWJvbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3ltYm9scyAtIEFycmF5IG9mIHRva2VuIHN5bWJvbHMgdG8gZ2V0IHByaWNlcyBmb3JcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0b2tlbiBwcmljZSBkYXRhXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldFRva2VuUHJpY2VCeVN5bWJvbChzeW1ib2xzKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFRva2VuUHJpY2VCeVN5bWJvbCh0aGlzLmNvbmZpZywgc3ltYm9scyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBoaXN0b3JpY2FsIHRva2VuIHByaWNlcyBieSB0b2tlbiBzeW1ib2wuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN5bWJvbCAtIFRoZSB0b2tlbiBzeW1ib2wgdG8gZ2V0IGhpc3RvcmljYWwgcHJpY2VzIGZvclxyXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZSAtIFN0YXJ0IHRpbWUgaW4gSVNPLTg2MDEgc3RyaW5nIGZvcm1hdCBvciBVbml4IHRpbWVzdGFtcCBpbiBzZWNvbmRzXHJcbiAgICAgKiBAcGFyYW0gZW5kVGltZSAtIEVuZCB0aW1lIGluIElTTy04NjAxIHN0cmluZyBmb3JtYXQgb3IgVW5peCB0aW1lc3RhbXAgaW4gc2Vjb25kc1xyXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gVGltZSBpbnRlcnZhbCBiZXR3ZWVuIGRhdGEgcG9pbnRzXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgaGlzdG9yaWNhbCB0b2tlbiBwcmljZSBkYXRhXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldEhpc3RvcmljYWxQcmljZUJ5U3ltYm9sKHN5bWJvbCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBpbnRlcnZhbCkge1xyXG4gICAgICAgIHJldHVybiBnZXRIaXN0b3JpY2FsUHJpY2VCeVN5bWJvbCh0aGlzLmNvbmZpZywgc3ltYm9sLCBzdGFydFRpbWUsIGVuZFRpbWUsIGludGVydmFsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGhpc3RvcmljYWwgdG9rZW4gcHJpY2VzIGJ5IG5ldHdvcmsgYW5kIGNvbnRyYWN0IGFkZHJlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5ldHdvcmsgLSBUaGUgbmV0d29yayB3aGVyZSB0aGUgdG9rZW4gY29udHJhY3QgaXMgZGVwbG95ZWRcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIHRva2VuIGNvbnRyYWN0IGFkZHJlc3NcclxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBTdGFydCB0aW1lIGluIElTTy04NjAxIHN0cmluZyBmb3JtYXQgb3IgVW5peCB0aW1lc3RhbXAgaW4gc2Vjb25kc1xyXG4gICAgICogQHBhcmFtIGVuZFRpbWUgLSBFbmQgdGltZSBpbiBJU08tODYwMSBzdHJpbmcgZm9ybWF0IG9yIFVuaXggdGltZXN0YW1wIGluIHNlY29uZHNcclxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAtIFRpbWUgaW50ZXJ2YWwgYmV0d2VlbiBkYXRhIHBvaW50c1xyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGhpc3RvcmljYWwgdG9rZW4gcHJpY2UgZGF0YVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRIaXN0b3JpY2FsUHJpY2VCeUFkZHJlc3MobmV0d29yaywgYWRkcmVzcywgc3RhcnRUaW1lLCBlbmRUaW1lLCBpbnRlcnZhbCkge1xyXG4gICAgICAgIHJldHVybiBnZXRIaXN0b3JpY2FsUHJpY2VCeUFkZHJlc3ModGhpcy5jb25maWcsIG5ldHdvcmssIGFkZHJlc3MsIHN0YXJ0VGltZSwgZW5kVGltZSwgaW50ZXJ2YWwpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBNdWx0aXBsZXMgdG8gaW5jcmVtZW50IGZlZSBwZXIgZ2FzIHdoZW4gdXNpbmdcclxuICoge0BsaW5rIFRyYW5zYWN0TmFtZXNwYWNlLnNlbmRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvbn0uXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgR0FTX09QVElNSVpFRF9UWF9GRUVfTVVMVElQTEVTID0gWzAuOSwgMSwgMS4xLCAxLjIsIDEuM107XHJcbi8qKlxyXG4gKiBUaGUgVHJhbnNhY3QgbmFtZXNwYWNlIGNvbnRhaW5zIG1ldGhvZHMgdXNlZCBmb3Igc2VuZGluZyB0cmFuc2FjdGlvbnMgYW5kXHJcbiAqIGNoZWNraW5nIG9uIHRoZSBzdGF0ZSBvZiBzdWJtaXR0ZWQgdHJhbnNhY3Rpb25zLlxyXG4gKlxyXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCBpbnN0YW50aWF0ZSBhbiBBbGNoZW15IG9iamVjdFxyXG4gKiB3aXRoIGBjb25zdCBhbGNoZW15ID0gbmV3IEFsY2hlbXkoY29uZmlnKWAgYW5kIHRoZW4gYWNjZXNzIHRoZSB0cmFuc2FjdFxyXG4gKiBuYW1lc3BhY2UgdmlhIGBhbGNoZW15LnRyYW5zYWN0YC5cclxuICovXHJcbmNsYXNzIFRyYW5zYWN0TmFtZXNwYWNlIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIHNlbmQgYSBzaW5nbGUgdHJhbnNhY3Rpb24gdG8gRmxhc2hib3RzLiBGbGFzaGJvdHMgd2lsbCBhdHRlbXB0IHRvXHJcbiAgICAgKiBzZW5kIHRoZSB0cmFuc2FjdGlvbiB0byBtaW5lcnMgZm9yIHRoZSBuZXh0IDI1IGJsb2Nrcy5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSBzdWJtaXR0ZWQgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNpZ25lZFRyYW5zYWN0aW9uIFRoZSByYXcsIHNpZ25lZCB0cmFuc2FjdGlvbiBhcyBhIGhhc2guXHJcbiAgICAgKiBAcGFyYW0gbWF4QmxvY2tOdW1iZXIgT3B0aW9uYWwgaGlnaGVzdCBibG9jayBudW1iZXIgaW4gd2hpY2ggdGhlXHJcbiAgICAgKiAgIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBpbmNsdWRlZC5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBzZW5kUHJpdmF0ZVRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uLCBtYXhCbG9ja051bWJlciwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBoZXhCbG9ja051bWJlciA9IG1heEJsb2NrTnVtYmVyID8gdG9IZXgobWF4QmxvY2tOdW1iZXIpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQoJ2V0aF9zZW5kUHJpdmF0ZVRyYW5zYWN0aW9uJywgW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHR4OiBzaWduZWRUcmFuc2FjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBtYXhCbG9ja051bWJlcjogaGV4QmxvY2tOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZmVyZW5jZXM6IG9wdGlvbnNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSwgJ3NlbmRQcml2YXRlVHJhbnNhY3Rpb24nKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIHByb3ZpZGVkIHByaXZhdGUgdHJhbnNhY3Rpb24gZnJvbSBiZWluZyBzdWJtaXR0ZWQgZm9yIGZ1dHVyZVxyXG4gICAgICogYmxvY2tzLiBBIHRyYW5zYWN0aW9uIGNhbiBvbmx5IGJlIGNhbmNlbGxlZCBpZiB0aGUgcmVxdWVzdCBpcyBzaWduZWQgYnkgdGhlXHJcbiAgICAgKiBzYW1lIGtleSBhcyB0aGUge0BsaW5rIHNlbmRQcml2YXRlVHJhbnNhY3Rpb259IGNhbGwgc3VibWl0dGluZyB0aGVcclxuICAgICAqIHRyYW5zYWN0aW9uIGluIGZpcnN0IHBsYWNlLlxyXG4gICAgICpcclxuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgZmFzdCBtb2RlIHRyYW5zYWN0aW9ucyBjYW5ub3QgYmUgY2FuY2VsbGVkIHVzaW5nIHRoaXMgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2FuY2VsbGF0aW9uIHdhcyBzdWNjZXNzZnVsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbkhhc2ggVHJhbnNhY3Rpb24gaGFzaCBvZiBwcml2YXRlIHR4IHRvIGJlIGNhbmNlbGxlZFxyXG4gICAgICovXHJcbiAgICBjYW5jZWxQcml2YXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZCgnZXRoX2NhbmNlbFByaXZhdGVUcmFuc2FjdGlvbicsIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0eEhhc2g6IHRyYW5zYWN0aW9uSGFzaFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLCAnY2FuY2VsUHJpdmF0ZVRyYW5zYWN0aW9uJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpbXVsYXRlcyB0aGUgYXNzZXQgY2hhbmdlcyByZXN1bHRpbmcgZnJvbSBhIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIHNpbXVsYXRlZFxyXG4gICAgICogaW4gc2VxdWVuY2UuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXNzZXQgY2hhbmdlcyBmb3IgZWFjaCB0cmFuc2FjdGlvbiBkdXJpbmcgc2ltdWxhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25zIFRyYW5zYWN0aW9ucyBsaXN0IG9mIG1heCAzIHRyYW5zYWN0aW9ucyB0byBzaW11bGF0ZS5cclxuICAgICAqIEBwYXJhbSBibG9ja0lkZW50aWZpZXIgT3B0aW9uYWwgYmxvY2sgaWRlbnRpZmllciB0byBzaW11bGF0ZSB0aGVcclxuICAgICAqIHRyYW5zYWN0aW9uIGluLlxyXG4gICAgICovXHJcbiAgICBzaW11bGF0ZUFzc2V0Q2hhbmdlc0J1bmRsZSh0cmFuc2FjdGlvbnMsIGJsb2NrSWRlbnRpZmllcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBibG9ja0lkZW50aWZpZXIgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBbdHJhbnNhY3Rpb25zLCBibG9ja0lkZW50aWZpZXJdXHJcbiAgICAgICAgICAgICAgICA6IFt0cmFuc2FjdGlvbnNdO1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB5aWVsZCBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9zaW11bGF0ZUFzc2V0Q2hhbmdlc0J1bmRsZScsIHBhcmFtcywgJ3NpbXVsYXRlQXNzZXRDaGFuZ2VzQnVuZGxlJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHJlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpbXVsYXRlcyB0aGUgYXNzZXQgY2hhbmdlcyByZXN1bHRpbmcgZnJvbSBhIHNpbmdsZSB0cmFuc2FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGxpc3Qgb2YgYXNzZXQgY2hhbmdlcyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGUgdHJhbnNhY3Rpb25cclxuICAgICAqIHNpbXVsYXRpb24uIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBkb2VzIG5vdCBydW4gdGhlIHRyYW5zYWN0aW9uIG9uIHRoZVxyXG4gICAgICogYmxvY2tjaGFpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIHRvIHNpbXVsYXRlLlxyXG4gICAgICogQHBhcmFtIGJsb2NrSWRlbnRpZmllciBPcHRpb25hbCBibG9jayBpZGVudGlmaWVyIHRvIHNpbXVsYXRlIHRoZVxyXG4gICAgICogdHJhbnNhY3Rpb24gaW4uXHJcbiAgICAgKi9cclxuICAgIHNpbXVsYXRlQXNzZXRDaGFuZ2VzKHRyYW5zYWN0aW9uLCBibG9ja0lkZW50aWZpZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYmxvY2tJZGVudGlmaWVyICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gW3RyYW5zYWN0aW9uLCBibG9ja0lkZW50aWZpZXJdXHJcbiAgICAgICAgICAgICAgICA6IFt0cmFuc2FjdGlvbl07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X3NpbXVsYXRlQXNzZXRDaGFuZ2VzJywgcGFyYW1zLCAnc2ltdWxhdGVBc3NldENoYW5nZXMnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQocmVzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2ltdWxhdGVzIGEgbGlzdCBvZiB0cmFuc2FjdGlvbnMgaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgbGlzdCBvZiBkZWNvZGVkXHJcbiAgICAgKiB0cmFjZXMgYW5kIGxvZ3MgdGhhdCBvY2N1cnJlZCBmb3IgZWFjaCB0cmFuc2FjdGlvbiBkdXJpbmcgc2ltdWxhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZG9lcyBub3QgcnVuIGFueSB0cmFuc2FjdGlvbnMgb24gdGhlIGJsb2NrY2hhaW4uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9ucyBUcmFuc2FjdGlvbnMgbGlzdCBvZiBtYXggMyB0cmFuc2FjdGlvbnMgdG8gc2ltdWxhdGUuXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tJZGVudGlmaWVyIE9wdGlvbmFsIGJsb2NrIGlkZW50aWZpZXIgdG8gc2ltdWxhdGUgdGhlXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBpbi5cclxuICAgICAqL1xyXG4gICAgc2ltdWxhdGVFeGVjdXRpb25CdW5kbGUodHJhbnNhY3Rpb25zLCBibG9ja0lkZW50aWZpZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYmxvY2tJZGVudGlmaWVyICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gW3RyYW5zYWN0aW9ucywgYmxvY2tJZGVudGlmaWVyXVxyXG4gICAgICAgICAgICAgICAgOiBbdHJhbnNhY3Rpb25zXTtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfc2ltdWxhdGVFeGVjdXRpb25CdW5kbGUnLCBwYXJhbXMsICdzaW11bGF0ZUV4ZWN1dGlvbkJ1bmRsZScpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChyZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW11bGF0ZXMgYSBzaW5nbGUgdHJhbnNhY3Rpb24gYW5kIHRoZSByZXN1bHRpbmcgYW5kIHJldHVybnMgbGlzdCBvZlxyXG4gICAgICogZGVjb2RlZCB0cmFjZXMgYW5kIGxvZ3MgdGhhdCBvY2N1cnJlZCBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uIHNpbXVsYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGRvZXMgbm90IHJ1biB0aGUgdHJhbnNhY3Rpb24gb24gdGhlIGJsb2NrY2hhaW4uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBzaW11bGF0ZS5cclxuICAgICAqIEBwYXJhbSBibG9ja0lkZW50aWZpZXIgT3B0aW9uYWwgYmxvY2sgaWRlbnRpZmllciB0byBzaW11bGF0ZSB0aGVcclxuICAgICAqIHRyYW5zYWN0aW9uIGluLlxyXG4gICAgICovXHJcbiAgICBzaW11bGF0ZUV4ZWN1dGlvbih0cmFuc2FjdGlvbiwgYmxvY2tJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGJsb2NrSWRlbnRpZmllciAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IFt0cmFuc2FjdGlvbiwgYmxvY2tJZGVudGlmaWVyXVxyXG4gICAgICAgICAgICAgICAgOiBbdHJhbnNhY3Rpb25dO1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9zaW11bGF0ZUV4ZWN1dGlvbicsIHBhcmFtcywgJ3NpbXVsYXRlRXhlY3V0aW9uJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHJlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHdpdGggaGFzaCBvciBudWxsIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyB1bmtub3duLlxyXG4gICAgICpcclxuICAgICAqIElmIGEgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCB0aGlzIG1ldGhvZCB3aWxsIHNlYXJjaCB0aGVcclxuICAgICAqIHRyYW5zYWN0aW9uIHBvb2wuIFZhcmlvdXMgYmFja2VuZHMgbWF5IGhhdmUgbW9yZSByZXN0cmljdGl2ZSB0cmFuc2FjdGlvblxyXG4gICAgICogcG9vbCBhY2Nlc3MgKGUuZy4gaWYgdGhlIGdhcyBwcmljZSBpcyB0b28gbG93IG9yIHRoZSB0cmFuc2FjdGlvbiB3YXMgb25seVxyXG4gICAgICogcmVjZW50bHkgc2VudCBhbmQgbm90IHlldCBpbmRleGVkKSBpbiB3aGljaCBjYXNlIHRoaXMgbWV0aG9kIG1heSBhbHNvIHJldHVybiBudWxsLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBDb3JlTmFtZXNwYWNlLmdldFRyYW5zYWN0aW9ufS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25IYXNoIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBnZXQuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3VibWl0cyB0cmFuc2FjdGlvbiB0byB0aGUgbmV0d29yayB0byBiZSBtaW5lZC4gVGhlIHRyYW5zYWN0aW9uIG11c3QgYmVcclxuICAgICAqIHNpZ25lZCwgYW5kIGJlIHZhbGlkIChpLmUuIHRoZSBub25jZSBpcyBjb3JyZWN0IGFuZCB0aGUgYWNjb3VudCBoYXNcclxuICAgICAqIHN1ZmZpY2llbnQgYmFsYW5jZSB0byBwYXkgZm9yIHRoZSB0cmFuc2FjdGlvbikuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIENvcmVOYW1lc3BhY2Uuc2VuZFRyYW5zYWN0aW9ufS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2lnbmVkVHJhbnNhY3Rpb24gVGhlIHNpZ25lZCB0cmFuc2FjdGlvbiB0byBzZW5kLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBzZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gZXN0aW1hdGUgb2YgdGhlIGFtb3VudCBvZiBnYXMgdGhhdCB3b3VsZCBiZSByZXF1aXJlZCB0byBzdWJtaXRcclxuICAgICAqIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrLlxyXG4gICAgICpcclxuICAgICAqIEFuIGVzdGltYXRlIG1heSBub3QgYmUgYWNjdXJhdGUgc2luY2UgdGhlcmUgY291bGQgYmUgYW5vdGhlciB0cmFuc2FjdGlvbiBvblxyXG4gICAgICogdGhlIG5ldHdvcmsgdGhhdCB3YXMgbm90IGFjY291bnRlZCBmb3IsIGJ1dCBhZnRlciBiZWluZyBtaW5lZCBhZmZlY3RzIHRoZVxyXG4gICAgICogcmVsZXZhbnQgc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIENvcmVOYW1lc3BhY2UuZXN0aW1hdGVHYXN9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBUaGUgdHJhbnNhY3Rpb24gdG8gZXN0aW1hdGUgZ2FzIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGZlZSBwZXIgZ2FzIChpbiB3ZWkpIHRoYXQgaXMgYW4gZXN0aW1hdGUgb2YgaG93IG11Y2ggeW91IGNhbiBwYXlcclxuICAgICAqIGFzIGEgcHJpb3JpdHkgZmVlLCBvciBcInRpcFwiLCB0byBnZXQgYSB0cmFuc2FjdGlvbiBpbmNsdWRlZCBpbiB0aGUgY3VycmVudCBibG9jay5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG51bWJlciBpcyBnZW5lcmFsbHkgdXNlZCB0byBzZXQgdGhlIGBtYXhQcmlvcml0eUZlZVBlckdhc2AgZmllbGQgaW4gYVxyXG4gICAgICogdHJhbnNhY3Rpb24gcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldE1heFByaW9yaXR5RmVlUGVyR2FzKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBmZWVIZXggPSB5aWVsZCBwcm92aWRlci5fc2VuZCgnZXRoX21heFByaW9yaXR5RmVlUGVyR2FzJywgW10sICdnZXRNYXhQcmlvcml0eUZlZVBlckdhcycpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUhleChmZWVIZXgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCB3aWxsIG5vdCByZXNvbHZlIHVudGlsIHNwZWNpZmllZCB0cmFuc2FjdGlvbiBoYXNoIGlzIG1pbmVkLlxyXG4gICAgICpcclxuICAgICAqIElmIHtAbGluayBjb25maXJtYXRpb25zfSBpcyAwLCB0aGlzIG1ldGhvZCBpcyBub24tYmxvY2tpbmcgYW5kIGlmIHRoZVxyXG4gICAgICogdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkIHJldHVybnMgbnVsbC4gT3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCB3aWxsXHJcbiAgICAgKiBibG9jayB1bnRpbCB0aGUgdHJhbnNhY3Rpb24gaGFzIGNvbmZpcm1lZCBibG9ja3MgbWluZWQgb24gdG9wIG9mIHRoZSBibG9ja1xyXG4gICAgICogaW4gd2hpY2ggaXQgd2FzIG1pbmVkLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBDb3JlTmFtZXNwYWNlLndhaXRGb3JUcmFuc2FjdGlvbn0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSGFzaCBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gd2FpdCBmb3IuXHJcbiAgICAgKiBAcGFyYW0gY29uZmlybWF0aW9ucyBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0byB3YWl0IGZvci5cclxuICAgICAqIEBwYXJhbSB0aW1lb3V0IFRoZSBtYXhpbXVtIHRpbWUgdG8gd2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbmZpcm0uXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHdhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2VuZEdhc09wdGltaXplZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uT3JTaWduZWRUeHMsIHdhbGxldCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25PclNpZ25lZFR4cykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25PclNpZ25lZFR4cywgJ3NlbmRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblByZVNpZ25lZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBnYXNMaW1pdDtcclxuICAgICAgICAgICAgbGV0IHByaW9yaXR5RmVlO1xyXG4gICAgICAgICAgICBsZXQgYmFzZUZlZTtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZ2FzTGltaXQgPSB5aWVsZCB0aGlzLmVzdGltYXRlR2FzKHRyYW5zYWN0aW9uT3JTaWduZWRUeHMpO1xyXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlGZWUgPSB5aWVsZCB0aGlzLmdldE1heFByaW9yaXR5RmVlUGVyR2FzKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QmxvY2sgPSB5aWVsZCBwcm92aWRlci5nZXRCbG9jaygnbGF0ZXN0Jyk7XHJcbiAgICAgICAgICAgICAgICBiYXNlRmVlID0gY3VycmVudEJsb2NrLmJhc2VGZWVQZXJHYXMudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZXN0aW1hdGUgZ2FzIGZvciB0cmFuc2FjdGlvbjogJHtlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGdhc1NwcmVhZFRyYW5zYWN0aW9ucyA9IGdlbmVyYXRlR2FzU3ByZWFkVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uT3JTaWduZWRUeHMsIGdhc0xpbWl0LnRvTnVtYmVyKCksIGJhc2VGZWUsIHByaW9yaXR5RmVlKTtcclxuICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0geWllbGQgUHJvbWlzZS5hbGwoZ2FzU3ByZWFkVHJhbnNhY3Rpb25zLm1hcCh0eCA9PiB3YWxsZXQuc2lnblRyYW5zYWN0aW9uKHR4KSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEdhc09wdGltaXplZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9ucywgJ3NlbmRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvbkdlbmVyYXRlZCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBvZiB0aGUgdHJhbnNhY3Rpb24gam9iIHJldHVybmVkIGJ5IHRoZVxyXG4gICAgICoge0BsaW5rIHNlbmRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvbn0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYWNraW5nSWQgVGhlIHRyYWNraW5nIGlkIGZyb20gdGhlIHJlc3BvbnNlIG9mIHRoZSBzZW50IGdhcyBvcHRpbWl6ZWQgdHJhbnNhY3Rpb24uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETyh0eGpvYik6IFJlbW92ZSBpbnRlcm5hbCB0YWcgb25jZSB0aGlzIGZlYXR1cmUgaXMgcmVsZWFzZWQuXHJcbiAgICBnZXRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1cyh0cmFja2luZ0lkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9nZXRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1cycsIFt0cmFja2luZ0lkXSwgJ2dldEdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBfc2VuZEdhc09wdGltaXplZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9ucywgbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfc2VuZEdhc09wdGltaXplZFRyYW5zYWN0aW9uJywgW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhd1RyYW5zYWN0aW9uczogc2lnbmVkVHJhbnNhY3Rpb25zXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sIG1ldGhvZE5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGdlbmVyYXRlIHRoZSByYXcgdHJhbnNhY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gZ2FzIGxpbWl0IGFuZFxyXG4gKiBwcmlvcml0eSBmZWUgYWNyb3NzIGEgc3ByZWFkIG9mIGRpZmZlcmVudCBnYXMgcHJpY2VzLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbi8vIFZpc2libGUgZm9yIHRlc3RpbmdcclxuZnVuY3Rpb24gZ2VuZXJhdGVHYXNTcHJlYWRUcmFuc2FjdGlvbnModHJhbnNhY3Rpb24sIGdhc0xpbWl0LCBiYXNlRmVlLCBwcmlvcml0eUZlZSkge1xyXG4gICAgcmV0dXJuIEdBU19PUFRJTUlaRURfVFhfRkVFX01VTFRJUExFUy5tYXAoZmVlTXVsdGlwbGllciA9PiB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb24pLCB7IGdhc0xpbWl0LCBtYXhGZWVQZXJHYXM6IE1hdGgucm91bmQoYmFzZUZlZSAqIGZlZU11bHRpcGxpZXIgKyBwcmlvcml0eUZlZSAqIGZlZU11bHRpcGxpZXIpLCBtYXhQcmlvcml0eUZlZVBlckdhczogTWF0aC5yb3VuZChmZWVNdWx0aXBsaWVyICogcHJpb3JpdHlGZWUpIH0pO1xyXG4gICAgfSk7XHJcbn1cblxuLyoqIFRoaXMgZmlsZSBjb250YWlucyBpbnRlcm5hbCB0eXBlcyB1c2VkIGJ5IHRoZSBTREsgYW5kIGFyZSBub3QgZXhwb3NlZCB0byB0aGUgZW5kIHVzZXIuICovXHJcbi8qKlxyXG4gKiBQcmVmaXggZm9yIGBhbGNoZW15X3BlbmRpbmdUcmFuc2FjdGlvbnNgIHN1YnNjcmlwdGlvbnMgd2hlbiBzZXJpYWxpemluZyB0b1xyXG4gKiBldGhlcnMgZXZlbnRzLlxyXG4gKlxyXG4gKiBUaGlzIHRhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgZXRoZXJzIHRvIHRyYWNrIGRpZmZlcmVudCBldmVudCBmaWx0ZXJzLlxyXG4gKi9cclxuY29uc3QgQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFID0gJ2FsY2hlbXktcGVuZGluZy10cmFuc2FjdGlvbnMnO1xyXG4vKipcclxuICogUHJlZml4IGZvciBgYWxjaGVteV9taW5lZFRyYW5zYWN0aW9uc2Agc3Vic2NyaXB0aW9ucyB3aGVuIHNlcmlhbGl6aW5nIHRvIGV0aGVycyBldmVudHMuXHJcbiAqXHJcbiAqIFRoaXMgdGFnIGlzIHVzZWQgaW50ZXJuYWxseSBieSBldGhlcnMgdG8gdHJhY2sgZGlmZmVyZW50IGV2ZW50IGZpbHRlcnMuXHJcbiAqL1xyXG5jb25zdCBBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFID0gJ2FsY2hlbXktbWluZWQtdHJhbnNhY3Rpb25zJztcclxuLyoqXHJcbiAqIEFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBjdXN0b20gZXZlbnQgdGFncyB1c2VkIGludGVybmFsbHkgYnkgZXRoZXJzIHRvIHRyYWNrXHJcbiAqIGV2ZW50IGZpbHRlcnMuXHJcbiAqL1xyXG5jb25zdCBBTENIRU1ZX0VWRU5UX1RZUEVTID0gW1xyXG4gICAgQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFLFxyXG4gICAgQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRVxyXG5dO1xuXG4vKipcclxuICogRE8gTk9UIE1PRElGWS5cclxuICpcclxuICogRXZlbnQgY2xhc3MgY29waWVkIGRpcmVjdGx5IG92ZXIgZnJvbSBldGhlcnMuanMncyBgQmFzZVByb3ZpZGVyYCBjbGFzcy5cclxuICpcclxuICogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIHJlcHJlc2VudCBldmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgbGlzdGVuZXJzLiBUaGVcclxuICogU0RLIG5lZWRzIHRvIGV4dGVuZCB0aGlzIGNsYXNzIGluIG9yZGVyIHRvIHN1cHBvcnQgQWxjaGVteSdzIGN1c3RvbVxyXG4gKiBTdWJzY3JpcHRpb24gQVBJIHR5cGVzLiBUaGUgb3JpZ2luYWwgY2xhc3MgaXMgbm90IGV4cG9ydGVkIGJ5IGV0aGVycy4gTWluaW1hbFxyXG4gKiBjaGFuZ2VzIGhhdmUgYmVlbiBtYWRlIGluIG9yZGVyIHRvIGdldCBUUyB0byBjb21waWxlLlxyXG4gKi9cclxuY2xhc3MgRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFnLCBsaXN0ZW5lciwgb25jZSkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICB0aGlzLnRhZyA9IHRhZztcclxuICAgICAgICB0aGlzLm9uY2UgPSBvbmNlO1xyXG4gICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xyXG4gICAgICAgIHRoaXMuX2luZmxpZ2h0ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXQgZXZlbnQoKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAndHgnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaDtcclxuICAgICAgICAgICAgY2FzZSAnZmlsdGVyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgdHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50YWcuc3BsaXQoJzonKVswXTtcclxuICAgIH1cclxuICAgIGdldCBoYXNoKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoJzonKTtcclxuICAgICAgICBpZiAoY29tcHNbMF0gIT09ICd0eCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB0cmFuc2FjdGlvbiBldmVudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcHNbMV07XHJcbiAgICB9XHJcbiAgICBnZXQgZmlsdGVyKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoJzonKTtcclxuICAgICAgICBpZiAoY29tcHNbMF0gIT09ICdmaWx0ZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdHJhbnNhY3Rpb24gZXZlbnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGNvbXBzWzFdO1xyXG4gICAgICAgIGNvbnN0IHRvcGljcyA9IGRlc2VyaWFsaXplVG9waWNzKGNvbXBzWzJdKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7fTtcclxuICAgICAgICBpZiAodG9waWNzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFkZHJlc3MgJiYgYWRkcmVzcyAhPT0gJyonKSB7XHJcbiAgICAgICAgICAgIGZpbHRlci5hZGRyZXNzID0gYWRkcmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgIH1cclxuICAgIHBvbGxhYmxlKCkge1xyXG4gICAgICAgIGNvbnN0IFBvbGxhYmxlRXZlbnRzID0gWydibG9jaycsICduZXR3b3JrJywgJ3BlbmRpbmcnLCAncG9sbCddO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZy5pbmRleE9mKCc6JykgPj0gMCB8fCBQb2xsYWJsZUV2ZW50cy5pbmRleE9mKHRoaXMudGFnKSA+PSAwO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBXcmFwcGVyIGNsYXNzIGFyb3VuZCB0aGUgZXRoZXJzIGBFdmVudGAgY2xhc3MgaW4gb3JkZXIgdG8gYWRkIHN1cHBvcnQgZm9yXHJcbiAqIEFsY2hlbXkncyBjdXN0b20gc3Vic2NyaXB0aW9ucyB0eXBlcy5cclxuICpcclxuICogVGhlIHNlcmlhbGl6YXRpb24gYW5kIGRlc2VyaWFsaXphdGlvbiBtZWNoYW5pc20gcmVxdWlyZXMgdGhlIG9yZGVyIG9mIHRoZVxyXG4gKiBmaWVsZHMgdG8gYmUgdGhlIHNhbWUgYWNyb3NzIGRpZmZlcmVudCB7QGxpbmsgQUxDSEVNWV9FVkVOVF9UWVBFU30uIEJlZm9yZVxyXG4gKiB1c2luZyBhIGdldHRlciBvbiBhIG5ldyBldmVudCBmaWx0ZXIsIG1ha2Ugc3VyZSB0aGF0IHRoZSBwb3NpdGlvbiBvZiB0aGVcclxuICogZmllbGQgaW4gc2VyaWFsaXphdGlvbiBpcyBjb3JyZWN0LlxyXG4gKlxyXG4gKiBUaGUgZ2V0dGVycyBvbiB0aGlzIGNsYXNzIGRlc2VyaWFsaXplIHRoZSBldmVudCB0YWcgZ2VuZXJhdGVkIGJ5XHJcbiAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGludG8gdGhlIG9yaWdpbmFsIGZpZWxkcyBwYXNzZWQgaW50byB0aGUgZXZlbnQuXHJcbiAqL1xyXG5jbGFzcyBFdGhlcnNFdmVudCBleHRlbmRzIEV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGV2ZW50IHRhZyBpbnRvIHRoZSBvcmlnaW5hbCBgZnJvbUFkZHJlc3NgIGZpZWxkIGluXHJcbiAgICAgKiB7QGxpbmsgQWxjaGVteVBlbmRpbmdUcmFuc2FjdGlvbnNFdmVudEZpbHRlcn0uXHJcbiAgICAgKi9cclxuICAgIGdldCBmcm9tQWRkcmVzcygpIHtcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBzWzFdICYmIGNvbXBzWzFdICE9PSAnKicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplQWRkcmVzc0ZpZWxkKGNvbXBzWzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZXZlbnQgdGFnIGludG8gdGhlIG9yaWdpbmFsIGB0b0FkZHJlc3NgIGZpZWxkIGluXHJcbiAgICAgKiB7QGxpbmsgQWxjaGVteVBlbmRpbmdUcmFuc2FjdGlvbnNFdmVudEZpbHRlcn0uXHJcbiAgICAgKi9cclxuICAgIGdldCB0b0FkZHJlc3MoKSB7XHJcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRhZy5zcGxpdCgnOicpO1xyXG4gICAgICAgIGlmIChjb21wc1swXSAhPT0gQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wc1syXSAmJiBjb21wc1syXSAhPT0gJyonKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZUFkZHJlc3NGaWVsZChjb21wc1syXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGV2ZW50IHRhZyBpbnRvIHRoZSBvcmlnaW5hbCBgaGFzaGVzT25seWAgZmllbGQgaW5cclxuICAgICAqIHtAbGluayBBbGNoZW15UGVuZGluZ1RyYW5zYWN0aW9uc0V2ZW50RmlsdGVyfSBhbmQge0BsaW5rIEFsY2hlbXlNaW5lZFRyYW5zYWN0aW9uc0V2ZW50RmlsdGVyfS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhhc2hlc09ubHkoKSB7XHJcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRhZy5zcGxpdCgnOicpO1xyXG4gICAgICAgIGlmICghQUxDSEVNWV9FVkVOVF9UWVBFUy5pbmNsdWRlcyhjb21wc1swXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBzWzNdICYmIGNvbXBzWzNdICE9PSAnKicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBzWzNdID09PSAndHJ1ZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBpbmNsdWRlUmVtb3ZlZCgpIHtcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wc1syXSAmJiBjb21wc1syXSAhPT0gJyonKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wc1syXSA9PT0gJ3RydWUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgYWRkcmVzc2VzKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoJzonKTtcclxuICAgICAgICBpZiAoY29tcHNbMF0gIT09IEFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBzWzFdICYmIGNvbXBzWzFdICE9PSAnKicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplQWRkcmVzc2VzRmllbGQoY29tcHNbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNBbGNoZW15RXZlbnQoZXZlbnQpIHtcclxuICAgIHJldHVybiB0eXBlb2YgZXZlbnQgPT09ICdvYmplY3QnICYmICdtZXRob2QnIGluIGV2ZW50O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGBhbGNoZW15X3BlbmRpbmdUcmFuc2FjdGlvbmBcclxuICogc3Vic2NyaXB0aW9uIGZpbHRlciB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgZXRoZXJzIGltcGxlbWVudGF0aW9uIG9mXHJcbiAqIGBnZXRFdmVudFRhZygpYC4gVGhlIG1ldGhvZCBpcyBub3QgYW4gZXhwb3J0ZWQgZnVuY3Rpb24gaW4gZXRoZXJzLCB3aGljaCBpc1xyXG4gKiB3aHkgdGhlIFNESyBoYXMgaXRzIG93biBpbXBsZW1lbnRhdGlvbi5cclxuICpcclxuICogVGhlIGV2ZW50IHRhZyBpcyB0aGVuIGRlc2VyaWFsaXplZCBieSB0aGUgU0RLJ3Mge0BsaW5rIEV0aGVyc0V2ZW50fSBnZXR0ZXJzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgIGBgYGpzXHJcbiAqICAgLy8gUmV0dXJucyAnYWxjaGVteS1wZW5kaW5nLXRyYW5zYWN0aW9uczoweEFCQzoweERFRnwweEdISTp0cnVlJ1xyXG4gKiAgIGNvbnN0IGV2ZW50VGFnID0gIGdldEFsY2hlbXlFdmVudFRhZyhcclxuICogICB7XHJcbiAqICAgICBcIm1ldGhvZFwiOiBcImFsY2hlbXlfcGVuZGluZ1RyYW5zYWN0aW9uc1wiLFxyXG4gKiAgICAgXCJmcm9tQWRkcmVzc1wiOiBcIjB4QUJDXCIsXHJcbiAqICAgICBcInRvQWRkcmVzc1wiOiBbXCIweERFRlwiLCBcIjB4R0hJXCJdLFxyXG4gKiAgICAgXCJoYXNoZXNPbmx5OiB0cnVlXHJcbiAqICAgfSk7XHJcbiAqICAgYGBgO1xyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnRcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnQpIHtcclxuICAgIGlmICghaXNBbGNoZW15RXZlbnQoZXZlbnQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCB0YWcgcmVxdWlyZXMgQWxjaGVteUV2ZW50VHlwZScpO1xyXG4gICAgfVxyXG4gICAgaWYgKGV2ZW50Lm1ldGhvZCA9PT0gZXhwb3J0cy5BbGNoZW15U3Vic2NyaXB0aW9uLlBFTkRJTkdfVFJBTlNBQ1RJT05TKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVBlbmRpbmdUcmFuc2FjdGlvbnNFdmVudChldmVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChldmVudC5tZXRob2QgPT09IGV4cG9ydHMuQWxjaGVteVN1YnNjcmlwdGlvbi5NSU5FRF9UUkFOU0FDVElPTlMpIHtcclxuICAgICAgICByZXR1cm4gc2VyaWFsaXplTWluZWRUcmFuc2FjdGlvbnNFdmVudChldmVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBBbGNoZW15RmlsdGVyRXZlbnQ6ICR7ZXZlbnR9YCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmVyaWZ5QWxjaGVteUV2ZW50TmFtZShldmVudE5hbWUpIHtcclxuICAgIGlmICghT2JqZWN0LnZhbHVlcyhleHBvcnRzLkFsY2hlbXlTdWJzY3JpcHRpb24pLmluY2x1ZGVzKGV2ZW50TmFtZS5tZXRob2QpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1ldGhvZCBuYW1lICR7ZXZlbnROYW1lLm1ldGhvZH0uIEFjY2VwdGVkIG1ldGhvZCBuYW1lczogJHtPYmplY3QudmFsdWVzKGV4cG9ydHMuQWxjaGVteVN1YnNjcmlwdGlvbil9YCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNlcmlhbGl6ZXMgdGhlIHByb3ZpZGVkIHtAbGluayBBbGNoZW15UGVuZGluZ1RyYW5zYWN0aW9uc0V2ZW50RmlsdGVyfSBpbnRvIGFuIGV0aGVyc1xyXG4gKiBjb21wYXRpYmxlIGV2ZW50IHRhZy5cclxuICpcclxuICogRm9yIHRoZSBleGFtcGxlIGV2ZW50OlxyXG4gKiBgYGBcclxuICogIHtcclxuICogICAgIFwibWV0aG9kXCI6IFwiYWxjaGVteV9wZW5kaW5nVHJhbnNhY3Rpb25zXCIsXHJcbiAqICAgICBcImZyb21BZGRyZXNzXCI6IFwiMHhBQkNcIixcclxuICogICAgIFwidG9BZGRyZXNzXCI6IFtcIjB4REVGXCIsIFwiMHhHSElcIl0sXHJcbiAqICAgICBcImhhc2hlc09ubHk6IHRydWVcclxuICogICB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb24gaXM6XHJcbiAqIGBhbGNoZW15X3BlbmRpbmdUcmFuc2FjdGlvbnM6MHhBQkM6MHhERUZ8MHhHSEk6dHJ1ZWBcclxuICpcclxuICogSWYgYSBmaWVsZCBpcyBvbWl0dGVkLCBpdCBpcyByZXBsYWNlZCB3aXRoIGEgYCpgLlxyXG4gKi9cclxuZnVuY3Rpb24gc2VyaWFsaXplUGVuZGluZ1RyYW5zYWN0aW9uc0V2ZW50KGV2ZW50KSB7XHJcbiAgICBjb25zdCBmcm9tQWRkcmVzcyA9IHNlcmlhbGl6ZUFkZHJlc3NGaWVsZChldmVudC5mcm9tQWRkcmVzcyk7XHJcbiAgICBjb25zdCB0b0FkZHJlc3MgPSBzZXJpYWxpemVBZGRyZXNzRmllbGQoZXZlbnQudG9BZGRyZXNzKTtcclxuICAgIGNvbnN0IGhhc2hlc09ubHkgPSBzZXJpYWxpemVCb29sZWFuRmllbGQoZXZlbnQuaGFzaGVzT25seSk7XHJcbiAgICByZXR1cm4gKEFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSArXHJcbiAgICAgICAgJzonICtcclxuICAgICAgICBmcm9tQWRkcmVzcyArXHJcbiAgICAgICAgJzonICtcclxuICAgICAgICB0b0FkZHJlc3MgK1xyXG4gICAgICAgICc6JyArXHJcbiAgICAgICAgaGFzaGVzT25seSk7XHJcbn1cclxuLyoqXHJcbiAqIFNlcmlhbGl6ZXMgdGhlIHByb3ZpZGVkIHtAbGluayBBbGNoZW15UGVuZGluZ1RyYW5zYWN0aW9uc0V2ZW50RmlsdGVyfSBpbnRvIGFuIGV0aGVyc1xyXG4gKiBjb21wYXRpYmxlIGV2ZW50IHRhZy5cclxuICpcclxuICogRm9yIHRoZSBleGFtcGxlIGV2ZW50OlxyXG4gKiBgYGBcclxuICogIHtcclxuICogICAgIFwibWV0aG9kXCI6IFwiYWxjaGVteV9taW5lZFRyYW5zYWN0aW9uc1wiLFxyXG4gKiAgICAgXCJhZGRyZXNzZXNcIjogW1xyXG4gKiAgICAgICB7XHJcbiAqICAgICAgICAgZnJvbTogXCIweEFCQ1wiXHJcbiAqICAgICAgIH0sXHJcbiAqICAgICAgIHtcclxuICogICAgICAgICB0bzogXCIweERFRlwiLFxyXG4gKiAgICAgICAgIGZyb206IFwiMHgxMjNcIlxyXG4gKiAgICAgICB9XHJcbiAqICAgICBdXHJcbiAqICAgICBcImluY2x1ZGVSZW1vdmVkXCI6IGZhbHNlXHJcbiAqICAgICBcImhhc2hlc09ubHk6IHRydWVcclxuICogICB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb24gaXM6XHJcbiAqIGBhbGNoZW15X21pbmVkVHJhbnNhY3Rpb25zOiosMHhBQkN8MHhERUYsMHgxMjM6ZmFsc2U6dHJ1ZWBcclxuICpcclxuICogSWYgYSBmaWVsZCBpcyBvbWl0dGVkLCBpdCBpcyByZXBsYWNlZCB3aXRoIGEgYCpgLlxyXG4gKlxyXG4gKiBUaGUgYGFkZHJlc3Nlc2AgYXJyYXkgaXMgc3BsaXQgYnkgdGhlICd8JyBjaGFyYWN0ZXIsIGFuZCBlYWNoIHRvL2Zyb20gYWRkcmVzc1xyXG4gKiBwYWlyIGlzIHNlcGFyYXRlZCBieSBhICcsJyBjaGFyYWN0ZXIuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXJpYWxpemVNaW5lZFRyYW5zYWN0aW9uc0V2ZW50KGV2ZW50KSB7XHJcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBzZXJpYWxpemVBZGRyZXNzZXNGaWVsZChldmVudC5hZGRyZXNzZXMpO1xyXG4gICAgY29uc3QgaW5jbHVkZVJlbW92ZWQgPSBzZXJpYWxpemVCb29sZWFuRmllbGQoZXZlbnQuaW5jbHVkZVJlbW92ZWQpO1xyXG4gICAgY29uc3QgaGFzaGVzT25seSA9IHNlcmlhbGl6ZUJvb2xlYW5GaWVsZChldmVudC5oYXNoZXNPbmx5KTtcclxuICAgIHJldHVybiAoQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSArXHJcbiAgICAgICAgJzonICtcclxuICAgICAgICBhZGRyZXNzZXMgK1xyXG4gICAgICAgICc6JyArXHJcbiAgICAgICAgaW5jbHVkZVJlbW92ZWQgK1xyXG4gICAgICAgICc6JyArXHJcbiAgICAgICAgaGFzaGVzT25seSk7XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplQWRkcmVzc2VzRmllbGQoYWRkcmVzc2VzKSB7XHJcbiAgICBpZiAoYWRkcmVzc2VzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gJyonO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFkZHJlc3Nlc1xyXG4gICAgICAgIC5tYXAoZmlsdGVyID0+IHNlcmlhbGl6ZUFkZHJlc3NGaWVsZChmaWx0ZXIudG8pICtcclxuICAgICAgICAnLCcgK1xyXG4gICAgICAgIHNlcmlhbGl6ZUFkZHJlc3NGaWVsZChmaWx0ZXIuZnJvbSkpXHJcbiAgICAgICAgLmpvaW4oJ3wnKTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVBZGRyZXNzRmllbGQoZmllbGQpIHtcclxuICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuICcqJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmllbGQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkLmpvaW4oJ3wnKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmaWVsZDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVCb29sZWFuRmllbGQoZmllbGQpIHtcclxuICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuICcqJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmaWVsZC50b1N0cmluZygpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9waWNzKGRhdGEpIHtcclxuICAgIGlmIChkYXRhID09PSAnJykge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhLnNwbGl0KC8mL2cpLm1hcCh0b3BpYyA9PiB7XHJcbiAgICAgICAgaWYgKHRvcGljID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdG9waWMuc3BsaXQoJ3wnKS5tYXAodG9waWMgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9waWMgPT09ICdudWxsJyA/IG51bGwgOiB0b3BpYztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29tcHMubGVuZ3RoID09PSAxID8gY29tcHNbMF0gOiBjb21wcztcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplQWRkcmVzc0ZpZWxkKGRhdGEpIHtcclxuICAgIGlmIChkYXRhID09PSAnJykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBkYXRhLnNwbGl0KCd8Jyk7XHJcbiAgICByZXR1cm4gYWRkcmVzc2VzLmxlbmd0aCA9PT0gMSA/IGFkZHJlc3Nlc1swXSA6IGFkZHJlc3NlcztcclxufVxyXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUFkZHJlc3Nlc0ZpZWxkKGRhdGEpIHtcclxuICAgIGlmIChkYXRhID09PSAnJykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBQZXJmb3JtIGEgY2FzdCBoZXJlIHNpbmNlIFRTIGRvZXNuJ3Qga25vdyB3ZSdyZSBndWFyYW50ZWVkIGEgbm9uLWVtcHR5XHJcbiAgICAvLyBhcnJheSBmcm9tIGRlc2VyaWFsaXppbmcuXHJcbiAgICByZXR1cm4gZGF0YVxyXG4gICAgICAgIC5zcGxpdCgnfCcpXHJcbiAgICAgICAgLm1hcChhZGRyZXNzU3RyID0+IGFkZHJlc3NTdHIuc3BsaXQoJywnKSlcclxuICAgICAgICAubWFwKGFkZHJlc3NQYWlyID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChhZGRyZXNzUGFpclswXSAhPT0gJyonICYmIHsgdG86IGFkZHJlc3NQYWlyWzBdIH0pKSwgKGFkZHJlc3NQYWlyWzFdICE9PSAnKicgJiYgeyBmcm9tOiBhZGRyZXNzUGFpclsxXSB9KSkpKTtcclxufVxuXG4vKipcclxuICogVGhlIFdlYnNvY2tldCBuYW1lc3BhY2UgY29udGFpbnMgYWxsIHN1YnNjcmlwdGlvbiByZWxhdGVkIGZ1bmN0aW9ucyB0aGF0XHJcbiAqIGFsbG93IHlvdSB0byBzdWJzY3JpYmUgdG8gZXZlbnRzIGFuZCByZWNlaXZlIHVwZGF0ZXMgYXMgdGhleSBvY2N1ci4gVGhlXHJcbiAqIHVuZGVybHlpbmcgV2ViU29ja2V0IHByb3ZpZGVyIGhhcyBhZGRpdGlvbmFsIGxvZ2ljIHRvIGhhbmRsZSByZWNvbm5lY3Rpb25zXHJcbiAqIGFuZCBhdXRvbWF0aWNhbGx5IGJhY2tmaWxscyBtaXNzZWQgZXZlbnRzLlxyXG4gKlxyXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCBpbnN0YW50aWF0ZSBhbiBBbGNoZW15IG9iamVjdFxyXG4gKiB3aXRoIGBjb25zdCBhbGNoZW15ID0gbmV3IEFsY2hlbXkoY29uZmlnKWAgYW5kIHRoZW4gYWNjZXNzIHRoZSBjb3JlIG5hbWVzcGFjZVxyXG4gKiB2aWEgYGFsY2hlbXkud3NgLlxyXG4gKi9cclxuY2xhc3MgV2ViU29ja2V0TmFtZXNwYWNlIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gYmUgdHJpZ2dlcmVkIGZvciBlYWNoIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBBbHNvXHJcbiAgICAgKiBpbmNsdWRlcyBBbGNoZW15J3MgU3Vic2NyaXB0aW9uIEFQSSBldmVudHMuIFNlZSB7QGxpbmsgQWxjaGVteUV2ZW50VHlwZX0gZm9yXHJcbiAgICAgKiBob3cgdG8gdXNlIHRoZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gbGlzdGVuIGZvci5cclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICB2b2lkICgoKSA9PiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRXZWJTb2NrZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRFdmVudCA9IHlpZWxkIHRoaXMuX3Jlc29sdmVFbnNBbGNoZW15RXZlbnQoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgcHJvdmlkZXIub24ocHJvY2Vzc2VkRXZlbnQsIGxpc3RlbmVyKTtcclxuICAgICAgICB9KSkoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIGJlIHRyaWdnZXJlZCBmb3Igb25seSB0aGUgbmV4dCB7QGxpbmsgZXZlbnROYW1lfSBldmVudCxcclxuICAgICAqIGFmdGVyIHdoaWNoIGl0IHdpbGwgYmUgcmVtb3ZlZC4gQWxzbyBpbmNsdWRlcyBBbGNoZW15J3MgU3Vic2NyaXB0aW9uIEFQSVxyXG4gICAgICogZXZlbnRzLiBTZWUge0BsaW5rIEFsY2hlbXlFdmVudFR5cGV9IGZvciBob3cgdG8gdXNlIHRoZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gbGlzdGVuIGZvci5cclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHZvaWQgKCgpID0+IF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFdlYlNvY2tldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZEV2ZW50ID0geWllbGQgdGhpcy5fcmVzb2x2ZUVuc0FsY2hlbXlFdmVudChldmVudE5hbWUpO1xyXG4gICAgICAgICAgICBwcm92aWRlci5vbmNlKHByb2Nlc3NlZEV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHByb3ZpZGVkIHtAbGluayBsaXN0ZW5lcn0gZm9yIHRoZSB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWYgbm9cclxuICAgICAqIGxpc3RlbmVyIGlzIHByb3ZpZGVkLCBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnQgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIHVubGlzdGVuIHRvLlxyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmUuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdm9pZCAoKCkgPT4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkRXZlbnQgPSB5aWVsZCB0aGlzLl9yZXNvbHZlRW5zQWxjaGVteUV2ZW50KGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5vZmYocHJvY2Vzc2VkRXZlbnQsIGxpc3RlbmVyKTtcclxuICAgICAgICB9KSkoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBwcm92aWRlZCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWYgbm8gZXZlbnRcclxuICAgICAqIGlzIHByb3ZpZGVkLCBhbGwgZXZlbnRzIGFuZCB0aGVpciBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgdm9pZCAoKCkgPT4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkRXZlbnQgPSBldmVudE5hbWVcclxuICAgICAgICAgICAgICAgID8geWllbGQgdGhpcy5fcmVzb2x2ZUVuc0FsY2hlbXlFdmVudChldmVudE5hbWUpXHJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlQWxsTGlzdGVuZXJzKHByb2Nlc3NlZEV2ZW50KTtcclxuICAgICAgICB9KSkoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBmb3IgdGhlIHByb3ZpZGVkIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZlxyXG4gICAgICogbm8gZXZlbnQgaXMgcHJvdmlkZWQsIHRoZSB0b3RhbCBudW1iZXIgb2YgbGlzdGVuZXJzIGZvciBhbGwgZXZlbnRzIGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIGdldCB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFdlYlNvY2tldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZEV2ZW50ID0gZXZlbnROYW1lXHJcbiAgICAgICAgICAgICAgICA/IHlpZWxkIHRoaXMuX3Jlc29sdmVFbnNBbGNoZW15RXZlbnQoZXZlbnROYW1lKVxyXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5saXN0ZW5lckNvdW50KHByb2Nlc3NlZEV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIHRoZSBwcm92aWRlZCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWZcclxuICAgICAqIG5vIGV2ZW50IGlzIHByb3ZpZGVkLCBhbGwgbGlzdGVuZXJzIHdpbGwgYmUgaW5jbHVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBsaXN0ZW5lcnMgZm9yLlxyXG4gICAgICovXHJcbiAgICBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFdlYlNvY2tldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZEV2ZW50ID0gZXZlbnROYW1lXHJcbiAgICAgICAgICAgICAgICA/IHlpZWxkIHRoaXMuX3Jlc29sdmVFbnNBbGNoZW15RXZlbnQoZXZlbnROYW1lKVxyXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5saXN0ZW5lcnMocHJvY2Vzc2VkRXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBFTlMgYWRkcmVzc2VzIGluIGFuIEFsY2hlbXkgRXZlbnQgdG8gdGhlIHVuZGVybHlpbmcgcmVzb2x2ZWRcclxuICAgICAqIGFkZHJlc3MuXHJcbiAgICAgKlxyXG4gICAgICogVklTSUJMRSBPTkxZIEZPUiBURVNUSU5HLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcmVzb2x2ZUVuc0FsY2hlbXlFdmVudChldmVudE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lLm1ldGhvZCA9PT0gZXhwb3J0cy5BbGNoZW15U3Vic2NyaXB0aW9uLk1JTkVEX1RSQU5TQUNUSU9OUyAmJlxyXG4gICAgICAgICAgICAgICAgZXZlbnROYW1lLmFkZHJlc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkQWRkcmVzc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgZXZlbnROYW1lLmFkZHJlc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzLnRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MudG8gPSB5aWVsZCB0aGlzLl9yZXNvbHZlTmFtZU9yRXJyb3IoYWRkcmVzcy50byk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzLmZyb20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5mcm9tID0geWllbGQgdGhpcy5fcmVzb2x2ZU5hbWVPckVycm9yKGFkZHJlc3MuZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZEFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXZlbnROYW1lLmFkZHJlc3NlcyA9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQWRkcmVzc2VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZS5tZXRob2QgPT09IGV4cG9ydHMuQWxjaGVteVN1YnNjcmlwdGlvbi5QRU5ESU5HX1RSQU5TQUNUSU9OUykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZS5mcm9tQWRkcmVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lLmZyb21BZGRyZXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUuZnJvbUFkZHJlc3MgPSB5aWVsZCB0aGlzLl9yZXNvbHZlTmFtZU9yRXJyb3IoZXZlbnROYW1lLmZyb21BZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZS5mcm9tQWRkcmVzcyA9IHlpZWxkIFByb21pc2UuYWxsKGV2ZW50TmFtZS5mcm9tQWRkcmVzcy5tYXAoYWRkcmVzcyA9PiB0aGlzLl9yZXNvbHZlTmFtZU9yRXJyb3IoYWRkcmVzcykpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lLnRvQWRkcmVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lLnRvQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lLnRvQWRkcmVzcyA9IHlpZWxkIHRoaXMuX3Jlc29sdmVOYW1lT3JFcnJvcihldmVudE5hbWUudG9BZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZS50b0FkZHJlc3MgPSB5aWVsZCBQcm9taXNlLmFsbChldmVudE5hbWUudG9BZGRyZXNzLm1hcChhZGRyZXNzID0+IHRoaXMuX3Jlc29sdmVOYW1lT3JFcnJvcihhZGRyZXNzKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnROYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgRU5TIGFkZHJlc3Mgb3IgdGhyb3dzIGFuIGVycm9yLiBUaGlzIGltcHJvdmVzIGNvZGVcclxuICAgICAqIHJlYWRhYmlsaXR5IGFuZCB0eXBlIHNhZmV0eSBpbiBvdGhlciBtZXRob2RzLlxyXG4gICAgICpcclxuICAgICAqIFZJU0lCTEUgT05MWSBGT1IgVEVTVElORy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3Jlc29sdmVOYW1lT3JFcnJvcihuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0geWllbGQgcHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVzb2x2ZSB0aGUgRU5TIGFkZHJlc3M6ICR7bmFtZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFRoZSBBbGNoZW15IFNESyBjbGllbnQuIFRoaXMgY2xhc3MgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgaW50byBBbGNoZW15J3NcclxuICogQVBJcyBhbmQgc2VwYXJhdGVzIGZ1bmN0aW9uYWxpdHkgaW50byBkaWZmZXJlbnQgbmFtZXNwYWNlcy5cclxuICpcclxuICogRWFjaCBTREsgaW5zdGFuY2UgaXMgYXNzb2NpYXRlZCB3aXRoIGEgc3BlY2lmaWMgbmV0d29yayBhbmQgQVBJIGtleS4gVG8gdXNlIGFcclxuICogZGlmZmVyZW50IG5ldHdvcmsgb3IgQVBJIGtleSwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBBbGNoZW15fS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQWxjaGVteSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2V0dGluZ3MuYXBpS2V5XSAtIFRoZSBBUEkga2V5IHRvIHVzZSBmb3IgQWxjaGVteVxyXG4gICAgICogQHBhcmFtIHtOZXR3b3JrfSBbc2V0dGluZ3MubmV0d29ya10gLSBUaGUgbmV0d29yayB0byB1c2UgZm9yIEFsY2hlbXlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2V0dGluZ3MubWF4UmV0cmllc10gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcyB0byBhdHRlbXB0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NldHRpbmdzLnJlcXVlc3RUaW1lb3V0XSAtIFRoZSB0aW1lb3V0IGFmdGVyIHdoaWNoIHJlcXVlc3Qgc2hvdWxkIGZhaWxcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IG5ldyBBbGNoZW15Q29uZmlnKHNldHRpbmdzKTtcclxuICAgICAgICB0aGlzLmNvcmUgPSBuZXcgQ29yZU5hbWVzcGFjZSh0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5uZnQgPSBuZXcgTmZ0TmFtZXNwYWNlKHRoaXMuY29uZmlnKTtcclxuICAgICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldE5hbWVzcGFjZSh0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy50cmFuc2FjdCA9IG5ldyBUcmFuc2FjdE5hbWVzcGFjZSh0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5ub3RpZnkgPSBuZXcgTm90aWZ5TmFtZXNwYWNlKHRoaXMuY29uZmlnKTtcclxuICAgICAgICB0aGlzLmRlYnVnID0gbmV3IERlYnVnTmFtZXNwYWNlKHRoaXMuY29uZmlnKTtcclxuICAgICAgICB0aGlzLnByaWNlcyA9IG5ldyBQcmljZXNOYW1lc3BhY2UodGhpcy5jb25maWcpO1xyXG4gICAgICAgIHRoaXMucG9ydGZvbGlvID0gbmV3IFBvcnRmb2xpb05hbWVzcGFjZSh0aGlzLmNvbmZpZyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFRoZSBXYWxsZXQgY2xhc3MgaW5oZXJpdHMgU2lnbmVyIGFuZCBjYW4gc2lnbiB0cmFuc2FjdGlvbnMgYW5kIG1lc3NhZ2VzIHVzaW5nXHJcbiAqIGEgcHJpdmF0ZSBrZXkgYXMgYSBzdGFuZGFyZCBFeHRlcm5hbGx5IE93bmVkIEFjY291bnQgKEVPQSkuXHJcbiAqXHJcbiAqIFNESydzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBvZiBFdGhlcnMuanMncyAnV2FsbGV0Jy5cclxuICpcclxuICogUHJpbWFyeSBkaWZmZXJlbmNlIGZyb20gRXRoZXJzLmpzICdXYWxsZXQnIGlzIHRoYXQgeW91IGNhbiBwYXNzIGluIGVpdGhlciBhXHJcbiAqIFByb3ZpZGVyIG9yIGFuIEFsY2hlbXkgb2JqZWN0LiBUaGlzIGltcGxlbWVudGF0aW9uIHdpbGwgaW50ZWxsaWdlbnRseSBkZXRlY3RcclxuICogdGhlIGZvcm1hdCBhbmQgc2V0IHRoZSBwcm92aWRlciBhY2NvcmRpbmdseS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcbmNsYXNzIFdhbGxldCBleHRlbmRzIHdhbGxldC5XYWxsZXQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVybG9hZCBwZXJtaXRzIHVzZXJzIHRvIHBhc3MgaW4gZWl0aGVyIGEgc3RhbmRhcmQgUHJvdmlkZXIgb3IgYW4gQWxjaGVteVxyXG4gICAgICogb2JqZWN0LiBUaGUgY29uc3RydWN0b3Igd2lsbCBkZXRlY3QgdGhlIG9iamVjdCB0eXBlIGFuZCBoYW5kbGUgYXBwcm9wcmlhdGVseS5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZUtleSwgYWxjaGVteU9yUHJvdmlkZXIpIHtcclxuICAgICAgICAvLyBJZiBvYmplY3QgcGFzc2VkIGluIGlzIGEgcHJvdmlkZXIsIHNlbmQgdG8gc3VwZXJcclxuICAgICAgICBsZXQgc3VwZXJQcm92aWRlcjtcclxuICAgICAgICBpZiAoYWxjaGVteU9yUHJvdmlkZXIgJiYgYWJzdHJhY3RQcm92aWRlci5Qcm92aWRlci5pc1Byb3ZpZGVyKGFsY2hlbXlPclByb3ZpZGVyKSkge1xyXG4gICAgICAgICAgICBzdXBlclByb3ZpZGVyID0gYWxjaGVteU9yUHJvdmlkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyKHByaXZhdGVLZXksIHN1cGVyUHJvdmlkZXIpO1xyXG4gICAgICAgIC8vIElmIG9iamVjdCBwYXNzZWQgaW4gaXMgYW4gQWxjaGVteSBvYmplY3QsIGp1c3Qgc2V0IEFsY2hlbXlcclxuICAgICAgICBpZiAoYWxjaGVteU9yUHJvdmlkZXIgJiYgIWFic3RyYWN0UHJvdmlkZXIuUHJvdmlkZXIuaXNQcm92aWRlcihhbGNoZW15T3JQcm92aWRlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5hbGNoZW15UHJvdmlkZXJQcm9taXNlID0gYWxjaGVteU9yUHJvdmlkZXIuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAvLyBTZXQgb2Ygb3ZlcnJpZGVzIGZyb20gU2lnbmVyIHRvIGhhbmRsZSBhc3luYyBwcm92aWRlciByZXRyaWV2YWwuXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYmFsYW5jZSBvZiB0aGlzIHdhbGxldCBhdCBibG9ja1RhZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tUYWcgVGhlIGJsb2NrIHRvIGNoZWNrIHRoZSBiYWxhbmNlIG9mXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZ2V0QmFsYW5jZShibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5nZXRCYWxhbmNlKGJsb2NrVGFnKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgdGhpcyBhY2NvdW50IGhhcyBldmVyIHNlbnQuIFRoaXMgaXMgdGhlXHJcbiAgICAgKiB2YWx1ZSByZXF1aXJlZCB0byBiZSBpbmNsdWRlZCBpbiB0cmFuc2FjdGlvbnMgYXMgdGhlIG5vbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBibG9ja1RhZyBUaGUgYmxvY2sgdG8gY2hlY2sgdGhlIHRyYW5zYWN0aW9uIGNvdW50IG9uXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNhY3Rpb25Db3VudChibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5nZXRUcmFuc2FjdGlvbkNvdW50KGJsb2NrVGFnKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBlc3RpbWF0aW5nIHRoZSBjb3N0IHRvIHNlbmQgdGhlIHRyYW5zYWN0aW9uUmVxdWVzdCxcclxuICAgICAqIHdpdGggdGhpcyBhY2NvdW50IGFkZHJlc3MgYmVpbmcgdXNlZCBhcyB0aGUgZnJvbSBmaWVsZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGdhcyBvblxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2FsbGV0KCkudGhlbih3YWxsZXQgPT4gd2FsbGV0LmVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHVzaW5nIHRoZSB0cmFuc2FjdGlvblJlcXVlc3QsIHdpdGggdGhpc1xyXG4gICAgICogYWNjb3VudCBhZGRyZXNzIGJlaW5nIHVzZWQgYXMgdGhlIGZyb20gZmllbGQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRvIG1ha2UgYSBjYWxsIG9uXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tUYWcgVGhlIGJsb2NrIHRvIG1ha2UgdGhlIGNhbGwgb25cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBjYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5jYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3B1bGF0ZXMgQUxMIGtleXMgZm9yIGEgdHJhbnNhY3Rpb24gYW5kIGNoZWNrcyB0aGF0IGBmcm9tYCBtYXRjaGVzIHRoaXNcclxuICAgICAqIGBTaWduZXJgLiBSZXNvbHZlcyBFTlMgbmFtZXMgYW5kIHBvcHVsYXRlcyBmaWVsZHMgbGlrZSBgZ2FzUHJpY2VgLCBgZ2FzTGltaXRgLFxyXG4gICAgICogYG5vbmNlYCwgYW5kIGBjaGFpbklkYCBpZiB0aGV5IGFyZSBub3QgcHJvdmlkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBwb3B1bGF0ZS5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2FsbGV0KCkudGhlbih3YWxsZXQgPT4gd2FsbGV0LnBvcHVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUG9wdWxhdGVzIGFsbCBmaWVsZHMgaW4gYSB0cmFuc2FjdGlvbiwgc2lnbnMgaXQgYW5kIHNlbmRzIGl0IHRvIHRoZSBuZXR3b3JrXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBzZW5kLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2hhaW4gSUQgdGhpcyB3YWxsZXQgaXMgY29ubmVjdGVkIHRvLlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBnZXRDaGFpbklkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5nZXRDaGFpbklkKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGdhcyBwcmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZ2V0R2FzUHJpY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2FsbGV0KCkudGhlbih3YWxsZXQgPT4gd2FsbGV0LmdldEdhc1ByaWNlKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlY29tbWVuZGVkIEZlZURhdGEgdG8gdXNlIGluIGEgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGFuIEVJUC0xNTU5IHRyYW5zYWN0aW9uLCB0aGUgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhc1xyXG4gICAgICogc2hvdWxkIGJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMgYW5kIG5ldHdvcmtzIHdoaWNoIGRvIG5vdCBzdXBwb3J0IEVJUC0xNTU5LCB0aGVcclxuICAgICAqIGdhc1ByaWNlIHNob3VsZCBiZSB1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBnZXRGZWVEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5nZXRGZWVEYXRhKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb29rcyB1cCB0aGUgYWRkcmVzcyBvZiBuYW1lLiBJZiB0aGUgbmFtZSBpcyBub3Qgb3duZWQsIG9yIGRvZXMgbm90IGhhdmUgYVxyXG4gICAgICogUmVzb2x2ZXIgY29uZmlndXJlZCwgb3IgdGhlIFJlc29sdmVyIGRvZXMgbm90IGhhdmUgYW4gYWRkcmVzcyBjb25maWd1cmVkLFxyXG4gICAgICogbnVsbCBpcyByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBFTlMgYWRkcmVzc1xyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmVOYW1lKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXYWxsZXQoKS50aGVuKHdhbGxldCA9PiB3YWxsZXQucmVzb2x2ZU5hbWUobmFtZSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0V2FsbGV0KCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsY2hlbXlQcm92aWRlclByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5wcm92aWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh5aWVsZCB0aGlzLmFsY2hlbXlQcm92aWRlclByb21pc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBUaGUgQ29udHJhY3QgY2xhc3MgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgQ29udHJhY3QgY2xhc3MgZnJvbSBldGhlcnMuanMgYW5kXHJcbiAqIGlzIGV4cG9ydGVkIGhlcmUgZm9yIGNvbnZlbmllbmNlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG4vLyBUT0RPOiBzdXBwb3J0IHBhc3NpbmcgaW4gQWxjaGVteSBpbnN0YW5jZSBpbnRvIHRoZSBjb250cmFjdC5cclxuY2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBjb250cmFjdHMuQ29udHJhY3Qge1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgQ29udHJhY3RGYWN0b3J5IGNsYXNzIGlzIGEgd3JhcHBlciBhcm91bmQgdGhlIENvbnRyYWN0RmFjdG9yeSBjbGFzcyBmcm9tXHJcbiAqIGV0aGVycy5qcyBhbmQgaXMgZXhwb3J0ZWQgaGVyZSBmb3IgY29udmVuaWVuY2UuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIENvbnRyYWN0RmFjdG9yeSBleHRlbmRzIGNvbnRyYWN0cy5Db250cmFjdEZhY3Rvcnkge1xyXG59XG5cbmV4cG9ydHMuQUxDSEVNWV9FVkVOVF9UWVBFUyA9IEFMQ0hFTVlfRVZFTlRfVFlQRVM7XG5leHBvcnRzLkFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUgPSBBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFO1xuZXhwb3J0cy5BTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUgPSBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEU7XG5leHBvcnRzLkFsY2hlbXkgPSBBbGNoZW15O1xuZXhwb3J0cy5Db250cmFjdCA9IENvbnRyYWN0O1xuZXhwb3J0cy5Db250cmFjdEZhY3RvcnkgPSBDb250cmFjdEZhY3Rvcnk7XG5leHBvcnRzLkN1c3RvbU5ldHdvcmtzID0gQ3VzdG9tTmV0d29ya3M7XG5leHBvcnRzLkRFRkFVTFRfQUxDSEVNWV9BUElfS0VZID0gREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XG5leHBvcnRzLkRFRkFVTFRfTkVUV09SSyA9IERFRkFVTFRfTkVUV09SSztcbmV4cG9ydHMuRXRoZXJzRXZlbnQgPSBFdGhlcnNFdmVudDtcbmV4cG9ydHMuRXRoZXJzTmV0d29yayA9IEV0aGVyc05ldHdvcms7XG5leHBvcnRzLklTX0JST1dTRVIgPSBJU19CUk9XU0VSO1xuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjtcbmV4cG9ydHMuV2FsbGV0ID0gV2FsbGV0O1xuZXhwb3J0cy5fX2F3YWl0ZXIgPSBfX2F3YWl0ZXIkMTtcbmV4cG9ydHMuZGVlcENvcHkgPSBkZWVwQ29weTtcbmV4cG9ydHMuZnJvbUhleCA9IGZyb21IZXg7XG5leHBvcnRzLmdldEFsY2hlbXlFdmVudFRhZyA9IGdldEFsY2hlbXlFdmVudFRhZztcbmV4cG9ydHMuZ2V0QWxjaGVteUh0dHBVcmwgPSBnZXRBbGNoZW15SHR0cFVybDtcbmV4cG9ydHMuZ2V0QWxjaGVteVdzVXJsID0gZ2V0QWxjaGVteVdzVXJsO1xuZXhwb3J0cy5pc0FsY2hlbXlFdmVudCA9IGlzQWxjaGVteUV2ZW50O1xuZXhwb3J0cy5pc0hleCA9IGlzSGV4O1xuZXhwb3J0cy5sb2dXYXJuID0gbG9nV2FybjtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5leHBvcnRzLnNldExvZ0xldmVsID0gc2V0TG9nTGV2ZWw7XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLnZlcmlmeUFsY2hlbXlFdmVudE5hbWUgPSB2ZXJpZnlBbGNoZW15RXZlbnROYW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtMzg3M2U3YjguanMubWFwXG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiYmlnbnVtYmVyIiwiYnl0ZXMiLCJheGlvcyIsImFic3RyYWN0UHJvdmlkZXIiLCJ3YWxsZXQiLCJjb250cmFjdHMiLCJfaW50ZXJvcERlZmF1bHRMZWdhY3kiLCJlIiwiYXhpb3NfX2RlZmF1bHQiLCJleHBvcnRzIiwiTmV0d29yayIsIlRva2VuQmFsYW5jZVR5cGUiLCJBc3NldFRyYW5zZmVyc0NhdGVnb3J5IiwiR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGUiLCJTb3J0aW5nT3JkZXIiLCJPcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzIiwiQWxjaGVteVN1YnNjcmlwdGlvbiIsIlNpbXVsYXRlQXNzZXRUeXBlIiwiU2ltdWxhdGVDaGFuZ2VUeXBlIiwiRGVjb2RpbmdBdXRob3JpdHkiLCJEZWJ1Z0NhbGxUeXBlIiwiR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMiLCJXZWJob29rVmVyc2lvbiIsIldlYmhvb2tUeXBlIiwiQ29tbWl0bWVudExldmVsIiwiRGVidWdUcmFjZXJUeXBlIiwiTmZ0VG9rZW5UeXBlIiwiTmZ0U3BhbUNsYXNzaWZpY2F0aW9uIiwiTmZ0RmlsdGVycyIsIk5mdE9yZGVyaW5nIiwiTmZ0U2FsZU1hcmtldHBsYWNlIiwiTmZ0U2FsZVRha2VyVHlwZSIsIk5mdFJlZnJlc2hTdGF0ZSIsIk5mdENvbGxlY3Rpb25NYXJrZXRwbGFjZSIsIkhpc3RvcmljYWxQcmljZUludGVydmFsIiwiX19hd2FpdGVyJDEiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fdmFsdWVzIiwibyIsInMiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm0iLCJpIiwiY2FsbCIsImxlbmd0aCIsIlR5cGVFcnJvciIsIl9fYXdhaXQiLCJ2IiwiX19hc3luY0dlbmVyYXRvciIsImFzeW5jSXRlcmF0b3IiLCJnIiwicSIsInZlcmIiLCJuIiwiYSIsImIiLCJwdXNoIiwicmVzdW1lIiwic2V0dGxlIiwiciIsImZ1bGZpbGwiLCJmIiwic2hpZnQiLCJfX2FzeW5jVmFsdWVzIiwiZCIsIkRFRkFVTFRfQUxDSEVNWV9BUElfS0VZIiwiREVGQVVMVF9ORVRXT1JLIiwiRVRIX01BSU5ORVQiLCJERUZBVUxUX01BWF9SRVRSSUVTIiwiREVGQVVMVF9SRVFVRVNUX1RJTUVPVVQiLCJnZXRBbGNoZW15SHR0cFVybCIsIm5ldHdvcmsiLCJhcGlLZXkiLCJnZXRBbGNoZW15TmZ0SHR0cFVybCIsImdldEFsY2hlbXlXc1VybCIsImdldEFsY2hlbXlXZWJob29rSHR0cFVybCIsImdldFByaWNlc0Jhc2VVcmwiLCJnZXREYXRhQmFzZVVybCIsIkFsY2hlbXlBcGlUeXBlIiwiRXRoZXJzTmV0d29yayIsIkVUSF9HT0VSTEkiLCJFVEhfU0VQT0xJQSIsIkVUSF9IT0xFU0tZIiwiRVRIX0hPT0RJIiwiT1BUX01BSU5ORVQiLCJPUFRfR09FUkxJIiwiT1BUX1NFUE9MSUEiLCJBUkJfTUFJTk5FVCIsIkFSQl9HT0VSTEkiLCJBUkJfU0VQT0xJQSIsIk1BVElDX01BSU5ORVQiLCJNQVRJQ19NVU1CQUkiLCJNQVRJQ19BTU9ZIiwiU09MQU5BX01BSU5ORVQiLCJTT0xBTkFfREVWTkVUIiwiQVNUQVJfTUFJTk5FVCIsIlBPTFlHT05aS0VWTV9NQUlOTkVUIiwiUE9MWUdPTlpLRVZNX1RFU1RORVQiLCJQT0xZR09OWktFVk1fQ0FSRE9OQSIsIkJBU0VfTUFJTk5FVCIsIkJBU0VfR09FUkxJIiwiQkFTRV9TRVBPTElBIiwiWktTWU5DX01BSU5ORVQiLCJaS1NZTkNfU0VQT0xJQSIsIlNIQVBFX01BSU5ORVQiLCJTSEFQRV9TRVBPTElBIiwiTElORUFfTUFJTk5FVCIsIkxJTkVBX1NFUE9MSUEiLCJGQU5UT01fTUFJTk5FVCIsIkZBTlRPTV9URVNUTkVUIiwiWkVUQUNIQUlOX01BSU5ORVQiLCJaRVRBQ0hBSU5fVEVTVE5FVCIsIkFSQk5PVkFfTUFJTk5FVCIsIkJMQVNUX01BSU5ORVQiLCJCTEFTVF9TRVBPTElBIiwiTUFOVExFX01BSU5ORVQiLCJNQU5UTEVfU0VQT0xJQSIsIlNDUk9MTF9NQUlOTkVUIiwiU0NST0xMX1NFUE9MSUEiLCJHTk9TSVNfTUFJTk5FVCIsIkdOT1NJU19DSElBRE8iLCJCTkJfTUFJTk5FVCIsIkJOQl9URVNUTkVUIiwiQVZBWF9NQUlOTkVUIiwiQVZBWF9GVUpJIiwiQ0VMT19NQUlOTkVUIiwiQ0VMT19BTEZBSk9SRVMiLCJDRUxPX0JBS0xBVkEiLCJNRVRJU19NQUlOTkVUIiwiT1BCTkJfTUFJTk5FVCIsIk9QQk5CX1RFU1RORVQiLCJCRVJBQ0hBSU5fQkFSVElPIiwiQkVSQUNIQUlOX01BSU5ORVQiLCJCRVJBQ0hBSU5fQkVQT0xJQSIsIlNPTkVJVU1fTUFJTk5FVCIsIlNPTkVJVU1fTUlOQVRPIiwiV09STERDSEFJTl9NQUlOTkVUIiwiV09STERDSEFJTl9TRVBPTElBIiwiUk9PVFNUT0NLX01BSU5ORVQiLCJST09UU1RPQ0tfVEVTVE5FVCIsIkZMT1dfTUFJTk5FVCIsIkZMT1dfVEVTVE5FVCIsIlpPUkFfTUFJTk5FVCIsIlpPUkFfU0VQT0xJQSIsIkZSQVhfTUFJTk5FVCIsIkZSQVhfU0VQT0xJQSIsIlBPTFlOT01JQUxfTUFJTk5FVCIsIlBPTFlOT01JQUxfU0VQT0xJQSIsIkNST1NTRklfTUFJTk5FVCIsIkNST1NTRklfVEVTVE5FVCIsIkFQRUNIQUlOX01BSU5ORVQiLCJBUEVDSEFJTl9DVVJUSVMiLCJMRU5TX01BSU5ORVQiLCJMRU5TX1NFUE9MSUEiLCJHRUlTVF9NQUlOTkVUIiwiR0VJU1RfUE9MVEVSIiwiTFVNSUFfUFJJU00iLCJMVU1JQV9URVNUTkVUIiwiVU5JQ0hBSU5fTUFJTk5FVCIsIlVOSUNIQUlOX1NFUE9MSUEiLCJTT05JQ19NQUlOTkVUIiwiU09OSUNfQkxBWkUiLCJYTVRQX1RFU1RORVQiLCJBQlNUUkFDVF9NQUlOTkVUIiwiQUJTVFJBQ1RfVEVTVE5FVCIsIkRFR0VOX01BSU5ORVQiLCJJTktfTUFJTk5FVCIsIklOS19TRVBPTElBIiwiU0VJX01BSU5ORVQiLCJTRUlfVEVTVE5FVCIsIlJPTklOX01BSU5ORVQiLCJST05JTl9TQUlHT04iLCJNT05BRF9URVNUTkVUIiwiU0VUVExVU19NQUlOTkVUIiwiU0VUVExVU19TRVBURVNUTkVUIiwiR0VOU1lOX1RFU1RORVQiLCJTVVBFUlNFRURfTUFJTk5FVCIsIlNVUEVSU0VFRF9TRVBPTElBIiwiVEVBX1NFUE9MSUEiLCJBTklNRV9NQUlOTkVUIiwiQU5JTUVfU0VQT0xJQSIsIlNUT1JZX01BSU5ORVQiLCJTVE9SWV9BRU5FSUQiLCJNRUdBRVRIX1RFU1RORVQiLCJCT1RBTklYX01BSU5ORVQiLCJCT1RBTklYX1RFU1RORVQiLCJIVU1BTklUWV9NQUlOTkVUIiwiUklTRV9URVNUTkVUIiwiQ3VzdG9tTmV0d29ya3MiLCJjaGFpbklkIiwibmFtZSIsInNlcG9saWEiLCJob2xlc2t5IiwiaG9vZGkiLCJtYXRpY2Ftb3kiLCJub29wIiwiRVRIX05VTExfVkFMVUUiLCJFVEhfTlVMTF9BRERSRVNTIiwiQWxjaGVteUNvbmZpZyIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwibWF4UmV0cmllcyIsInVybCIsImF1dGhUb2tlbiIsImJhdGNoUmVxdWVzdHMiLCJyZXF1ZXN0VGltZW91dCIsImNvbm5lY3Rpb25JbmZvT3ZlcnJpZGVzIiwiX2dldFJlcXVlc3RVcmwiLCJhcGlUeXBlIiwidW5kZWZpbmVkIiwiTkZUIiwiV0VCSE9PSyIsIlBSSUNFUyIsIlBPUlRGT0xJTyIsImdldFByb3ZpZGVyIiwiX2Jhc2VBbGNoZW15UHJvdmlkZXIiLCJBbGNoZW15UHJvdmlkZXIiLCJnZXRXZWJTb2NrZXRQcm92aWRlciIsIl9iYXNlQWxjaGVteVdzc1Byb3ZpZGVyIiwiQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIiwidmVyc2lvbiQxIiwiX3Blcm1hbmVudENlbnNvckVycm9ycyIsIl9jZW5zb3JFcnJvcnMiLCJMb2dMZXZlbHMiLCJkZWJ1ZyIsImluZm8iLCJ3YXJuaW5nIiwiZXJyb3IiLCJvZmYiLCJfbG9nTGV2ZWwiLCJfZ2xvYmFsTG9nZ2VyIiwiX2NoZWNrTm9ybWFsaXplIiwibWlzc2luZyIsImZvckVhY2giLCJmb3JtIiwibm9ybWFsaXplIiwiRXJyb3IiLCJqb2luIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibWVzc2FnZSIsIl9ub3JtYWxpemVFcnJvciIsIkxvZ0xldmVsJDEiLCJMb2dMZXZlbCIsIkVycm9yQ29kZSIsIkhFWCIsIkxvZ2dlciQxIiwidmVyc2lvbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiX2xvZyIsImxvZ0xldmVsIiwiYXJncyIsImxldmVsIiwidG9Mb3dlckNhc2UiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJjb25zb2xlIiwibG9nIiwibGV2ZWxzIiwiREVCVUciLCJJTkZPIiwid2FybiIsIldBUk5JTkciLCJtYWtlRXJyb3IiLCJjb2RlIiwicGFyYW1zIiwiZXJyb3JzIiwiVU5LTk9XTl9FUlJPUiIsIm1lc3NhZ2VEZXRhaWxzIiwia2V5cyIsImtleSIsIlVpbnQ4QXJyYXkiLCJoZXgiLCJKU09OIiwic3RyaW5naWZ5IiwidG9TdHJpbmciLCJyZWFzb24iLCJOVU1FUklDX0ZBVUxUIiwiZmF1bHQiLCJDQUxMX0VYQ0VQVElPTiIsIklOU1VGRklDSUVOVF9GVU5EUyIsIk1JU1NJTkdfTkVXIiwiTk9OQ0VfRVhQSVJFRCIsIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEIiwiVFJBTlNBQ1RJT05fUkVQTEFDRUQiLCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVCIsInRocm93RXJyb3IiLCJJTlZBTElEX0FSR1VNRU5UIiwiYXJndW1lbnQiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJhc3NlcnRBcmd1bWVudCIsImNoZWNrTm9ybWFsaXplIiwiVU5TVVBQT1JURURfT1BFUkFUSU9OIiwib3BlcmF0aW9uIiwiY2hlY2tTYWZlVWludDUzIiwiY2hlY2tBcmd1bWVudENvdW50IiwiY291bnQiLCJleHBlY3RlZENvdW50IiwiTUlTU0lOR19BUkdVTUVOVCIsIlVORVhQRUNURURfQVJHVU1FTlQiLCJjaGVja05ldyIsInRhcmdldCIsImtpbmQiLCJjaGVja0Fic3RyYWN0IiwiZ2xvYmFsTG9nZ2VyIiwic2V0Q2Vuc29yc2hpcCIsImNlbnNvcnNoaXAiLCJwZXJtYW5lbnQiLCJzZXRMb2dMZXZlbCIsImZyb20iLCJfX2F3YWl0ZXIiLCJsb2dnZXIiLCJkZWZpbmVSZWFkT25seSIsIm9iamVjdCIsInJlc29sdmVQcm9wZXJ0aWVzIiwicHJvbWlzZXMiLCJtYXAiLCJyZXN1bHRzIiwiYWxsIiwicmVkdWNlIiwiYWNjdW0iLCJvcGFxdWUiLCJiaWdpbnQiLCJib29sZWFuIiwibnVtYmVyIiwic3RyaW5nIiwiX2lzRnJvemVuIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNGcm96ZW4iLCJfZGVlcENvcHkiLCJmcmVlemUiLCJpdGVtIiwiZGVlcENvcHkiLCJmcm9tSGV4IiwiaGV4U3RyaW5nIiwiQmlnTnVtYmVyIiwidG9OdW1iZXIiLCJ0b0hleCIsIm51bSIsImhleFZhbHVlIiwiaXNIZXgiLCJwb3NzaWJsZUhleFN0cmluZyIsInRlc3QiLCJmb3JtYXRCbG9jayIsImJsb2NrIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwic3RyaW5nVG9FbnVtIiwieCIsImVudW1iIiwidmFsdWVzIiwiaW5jbHVkZXMiLCJnZXROZnRDb250cmFjdEZvck5mdEZyb21SYXciLCJyYXdOZnRDb250cmFjdCIsIm51bGxzVG9VbmRlZmluZWQiLCJhc3NpZ24iLCJnZXROZnRDb250cmFjdEZyb21SYXciLCJzcGFtQ2xhc3NpZmljYXRpb25zIiwicGFyc2VOZnRTcGFtQ2xhc3NpZmljYXRpb24iLCJnZXROZnRDb250cmFjdHNGb3JPd25lckZyb21SYXciLCJkaXNwbGF5TmZ0IiwiaW1hZ2UiLCJ0b3RhbEJhbGFuY2UiLCJudW1EaXN0aW5jdFRva2Vuc093bmVkIiwiaXNTcGFtIiwiX2EiLCJ0b2tlblR5cGUiLCJwYXJzZU5mdFRva2VuVHlwZSIsIm9wZW5TZWFNZXRhZGF0YSIsInNhZmVsaXN0UmVxdWVzdFN0YXR1cyIsImdldE5mdENvbGxlY3Rpb25Gcm9tUmF3IiwicmF3TmZ0Q29sbGVjdGlvbiIsImZsb29yUHJpY2UiLCJtYXJrZXRwbGFjZSIsInBhcnNlTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlIiwiZ2V0QmFzZU5mdEZyb21SYXciLCJyYXdCYXNlTmZ0IiwiY29udHJhY3RBZGRyZXNzIiwidG9rZW5JZCIsImdldE5mdEZyb21SYXciLCJyYXdOZnQiLCJjb250cmFjdCIsImFjcXVpcmVkQXQiLCJjb2xsZWN0aW9uIiwibWludCIsImdldE5mdFNhbGVzRnJvbVJhdyIsInJhd05mdFNhbGVzIiwibmZ0U2FsZXMiLCJyYXdOZnRTYWxlIiwicGFyc2VOZnRTYWxlTWFya2V0cGxhY2UiLCJ0YWtlciIsInBhcnNlTmZ0VGFrZXIiLCJ2YWxpZEF0IiwicGFnZUtleSIsIkxPT0tTUkFSRSIsIlNFQVBPUlQiLCJYMlkyIiwiV1lWRVJOIiwiQ1JZUFRPUFVOS1MiLCJCTFVSIiwiVU5LTk9XTiIsIk9QRU5TRUEiLCJCVVlFUiIsIlNFTExFUiIsInJlcyIsIlVua25vd24iLCJFUkM3MjEiLCJFUkMxMTU1IiwiTk9fU1VQUE9SVEVEX05GVF9TVEFOREFSRCIsIk5PVF9BX0NPTlRSQUNUIiwiSVNfQlJPV1NFUiIsIndpbmRvdyIsIm9iaiIsImdldEFzc2V0VHJhbnNmZXJzIiwic3JjTWV0aG9kIiwicHJvdmlkZXIiLCJmcm9tQWRkcmVzcyIsIl9nZXRBZGRyZXNzIiwidG9BZGRyZXNzIiwiX3NlbmQiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwibWF4Q291bnQiLCJnZXRUcmFuc2FjdGlvblJlY2VpcHRzIiwiZ2V0TG9ncyIsImZpbHRlciIsImdldE5ldHdvcmsiLCJnZXRGaWx0ZXIiLCJsb2dzIiwic2VuZCIsInJlbW92ZWQiLCJhcnJheU9mIiwiZm9ybWF0dGVyIiwiZmlsdGVyTG9nIiwiYmluZCIsInJlc29sdmVkRmlsdGVyIiwiX2dldEJsb2NrVGFnIiwiYWRkcmVzcyIsImZvcm1hdCIsImFycmF5IiwiQ29yZU5hbWVzcGFjZSIsImdldEJhbGFuY2UiLCJhZGRyZXNzT3JOYW1lIiwiYmxvY2tUYWciLCJpc0NvbnRyYWN0QWRkcmVzcyIsImdldENvZGUiLCJnZXRTdG9yYWdlQXQiLCJwb3NpdGlvbiIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJnZXRCbG9jayIsImJsb2NrSGFzaE9yQmxvY2tUYWciLCJnZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMiLCJnZXRCbG9ja051bWJlciIsImdldEdhc1ByaWNlIiwiZ2V0RmVlRGF0YSIsInJlYWR5IiwidHJhbnNhY3Rpb24iLCJlc3RpbWF0ZUdhcyIsImdldFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25IYXNoIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0Iiwic2VuZFRyYW5zYWN0aW9uIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJ3YWl0Rm9yVHJhbnNhY3Rpb24iLCJjb25maXJtYXRpb25zIiwidGltZW91dCIsIm1ldGhvZCIsImZpbmRDb250cmFjdERlcGxveWVyIiwiY3VycmVudEJsb2NrTnVtIiwiZmlyc3RCbG9jayIsImJpbmFyeVNlYXJjaEZpcnN0QmxvY2siLCJ0eFJlY2VpcHRzIiwiYmxvY2tOdW1iZXIiLCJtYXRjaGluZ1JlY2VpcHQiLCJyZWNlaXB0cyIsImZpbmQiLCJyZWNlaXB0IiwiZGVwbG95ZXJBZGRyZXNzIiwiZ2V0VG9rZW5CYWxhbmNlcyIsImNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zIiwiRVJDMjAiLCJ0eXBlIiwiZ2V0VG9rZW5zRm9yT3duZXIiLCJvcHRpb25zIiwiY29udHJhY3RBZGRyZXNzZXMiLCJyZXNwb25zZSIsImZvcm1hdHRlZEJhbGFuY2VzIiwidG9rZW5CYWxhbmNlcyIsImJhbGFuY2UiLCJyYXdCYWxhbmNlIiwidG9rZW5CYWxhbmNlIiwibWV0YWRhdGFQcm9taXNlcyIsImFsbFNldHRsZWQiLCJ0b2tlbiIsIm1ldGFkYXRhIiwicCIsInN0YXR1cyIsInN5bWJvbCIsImRlY2ltYWxzIiwibG9nbyIsIm93bmVkVG9rZW5zIiwiaW5kZXgiLCJmb3JtYXRVbml0cyIsInRva2VucyIsInQiLCJnZXRUb2tlbk1ldGFkYXRhIiwicmVzb2x2ZU5hbWUiLCJsb29rdXBBZGRyZXNzIiwic3RhcnQiLCJlbmQiLCJtaWQiLCJNYXRoIiwiZmxvb3IiLCJEZWJ1Z05hbWVzcGFjZSIsInRyYWNlQ2FsbCIsImJsb2NrSWRlbnRpZmllciIsInRyYWNlciIsInBhcnNlVHJhY2VyUGFyYW1zIiwidHJhY2VUcmFuc2FjdGlvbiIsInRyYWNlQmxvY2siLCJpc0hleFN0cmluZyIsImhleFN0cmlwWmVyb3MiLCJvbmx5VG9wQ2FsbCIsInRyYWNlckNvbmZpZyIsInNhbml0aXplVG9rZW5UeXBlIiwibG9nTGV2ZWxTdHJpbmdUb0VudW0iLCJXQVJOIiwiRVJST1IiLCJzaWxlbnQiLCJTSUxFTlQiLCJsb2dMZXZlbFRvQ29uc29sZUZuIiwiREVGQVVMVF9MT0dfTEVWRUwiLCJsb2dnZXJDbGllbnQiLCJsb2dEZWJ1ZyIsImxvZ0luZm8iLCJsb2dXYXJuIiwiTG9nZ2VyIiwidmFsIiwibm93IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiVkVSU0lPTiIsInNlbmRBeGlvc1JlcXVlc3QiLCJiYXNlVXJsIiwicmVzdEFwaU5hbWUiLCJtZXRob2ROYW1lIiwib3ZlcnJpZGVzIiwicmVxdWVzdFVybCIsImhlYWRlcnMiLCJERUZBVUxUX0JBQ0tPRkZfSU5JVElBTF9ERUxBWV9NUyIsIkRFRkFVTFRfQkFDS09GRl9NVUxUSVBMSUVSIiwiREVGQVVMVF9CQUNLT0ZGX01BWF9ERUxBWV9NUyIsIkRFRkFVTFRfQkFDS09GRl9NQVhfQVRURU1QVFMiLCJFeHBvbmVudGlhbEJhY2tvZmYiLCJtYXhBdHRlbXB0cyIsImluaXRpYWxEZWxheU1zIiwiYmFja29mZk11bHRpcGxpZXIiLCJtYXhEZWxheU1zIiwibnVtQXR0ZW1wdHMiLCJjdXJyZW50RGVsYXlNcyIsImlzSW5CYWNrb2ZmIiwiYmFja29mZiIsImJhY2tvZmZEZWxheVdpdGhKaXR0ZXJNcyIsIndpdGhKaXR0ZXJNcyIsIm1heCIsIm1pbiIsInNldFRpbWVvdXQiLCJkZWxheU1zIiwicmFuZG9tIiwicmVxdWVzdEh0dHBXaXRoQmFja29mZiIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJlcnIiLCJkYXRhIiwiaXNBeGlvc0Vycm9yIiwiaXNSZXRyeWFibGVIdHRwRXJyb3IiLCJyZXRyeWFibGVDb2RlcyIsInBhZ2luYXRlRW5kcG9pbnQiLCJyZXFQYWdlS2V5IiwicmVzUGFnZUtleSIsImFyZ3VtZW50cyIsInBhZ2luYXRlRW5kcG9pbnRfMSIsImhhc05leHQiLCJyZXF1ZXN0UGFyYW1zIiwiZ2V0TmZ0TWV0YWRhdGEiLCJ0b2tlblVyaVRpbWVvdXRJbk1zIiwicmVmcmVzaENhY2hlIiwiZ2V0TmZ0TWV0YWRhdGFCYXRjaCIsIm5mdHMiLCJuZnQiLCJnZXRDb250cmFjdE1ldGFkYXRhIiwiZ2V0Q29udHJhY3RNZXRhZGF0YUJhdGNoIiwiZ2V0Q29sbGVjdGlvbk1ldGFkYXRhIiwiY29sbGVjdGlvblNsdWciLCJnZXROZnRzRm9yT3duZXJJdGVyYXRvciIsIm93bmVyIiwiZ2V0TmZ0c0Zvck93bmVySXRlcmF0b3JfMSIsImVfMSIsIndpdGhNZXRhZGF0YSIsIm9taXRNZXRhZGF0YVRvV2l0aE1ldGFkYXRhIiwib21pdE1ldGFkYXRhIiwiX2IiLCJleGNsdWRlRmlsdGVycyIsImluY2x1ZGVGaWx0ZXJzIiwib3JkZXJCeSIsIl9jIiwib3duZWROZnQiLCJvd25lZE5mdHMiLCJuZnRGcm9tR2V0TmZ0UmVzcG9uc2UiLCJlXzFfMSIsInJldHVybiIsImdldE5mdHNGb3JPd25lciIsInBhZ2VTaXplIiwidG90YWxDb3VudCIsImdldE5mdHNGb3JDb250cmFjdCIsImxpbWl0IiwiZ2V0TmZ0c0ZvckNvbnRyYWN0SXRlcmF0b3IiLCJnZXROZnRzRm9yQ29udHJhY3RJdGVyYXRvcl8xIiwiZV8yIiwibmZ0RnJvbUdldE5mdENvbnRyYWN0UmVzcG9uc2UiLCJlXzJfMSIsImdldE93bmVyc0ZvckNvbnRyYWN0Iiwid2l0aFRva2VuQmFsYW5jZXMiLCJvd25lcnMiLCJnZXRDb250cmFjdHNGb3JPd25lciIsImdldE93bmVyc0Zvck5mdCIsImdldE1pbnRlZE5mdHMiLCJvd25lckFkZHJlc3MiLCJjYXRlZ29yeSIsIm5mdFRva2VuVHlwZVRvQ2F0ZWdvcnkiLCJleGNsdWRlWmVyb1ZhbHVlIiwiZ2V0TmZ0c0ZvclRyYW5zZmVycyIsImdldFRyYW5zZmVyc0Zvck93bmVyIiwidHJhbnNmZXJUeXBlIiwiVE8iLCJ0cmFuc2ZlcnNSZXNwb25zZSIsImdldFRyYW5zZmVyc0ZvckNvbnRyYWN0IiwiU1BFQ0lBTE5GVCIsIm9yZGVyIiwicGFyc2UxMTU1VHJhbnNmZXIiLCJ0cmFuc2ZlciIsImVyYzExNTVNZXRhZGF0YSIsInJhd0NvbnRyYWN0IiwidmVyaWZ5TmZ0T3duZXJzaGlwIiwiYWNjIiwiY3VyciIsImlzU3BhbUNvbnRyYWN0IiwiZ2V0U3BhbUNvbnRyYWN0cyIsInJlcG9ydFNwYW0iLCJpc0FpcmRyb3BOZnQiLCJnZXRGbG9vclByaWNlIiwiZ2V0TmZ0U2FsZXMiLCJzZWxsZXJBZGRyZXNzIiwiYnV5ZXJBZGRyZXNzIiwiY29tcHV0ZVJhcml0eSIsInNlYXJjaENvbnRyYWN0TWV0YWRhdGEiLCJxdWVyeSIsInN1bW1hcml6ZU5mdEF0dHJpYnV0ZXMiLCJyZWZyZXNoTmZ0TWV0YWRhdGEiLCJ0b2tlbklkU3RyaW5nIiwiZmlyc3QiLCJzZWNvbmQiLCJyZWZyZXNoIiwidGltZUxhc3RVcGRhdGVkIiwicmVmcmVzaENvbnRyYWN0IiwicmVmcmVzaFN0YXRlIiwicGFyc2VSZWluZ2VzdGlvblN0YXRlIiwicmVpbmdlc3Rpb25TdGF0ZSIsInByb2dyZXNzIiwiaXNOZnRXaXRoTWV0YWRhdGEiLCJtZXRhZGF0YVRyYW5zZmVycyIsInRyYW5zZmVycyIsImZsYXRNYXAiLCJnZXRUb2tlbnNGcm9tVHJhbnNmZXIiLCJ0byIsImhhc2giLCJibG9ja051bSIsImJhdGNoU2l6ZSIsInJlcXVlc3RCYXRjaGVzIiwic2xpY2UiLCJyZXNwb25zZUJhdGNoZXMiLCJiYXRjaCIsImZsYXQiLCJuZnRzQnlUb2tlbklkIiwiTWFwIiwic2V0IiwidHJhbnNmZXJyZWROZnRzIiwiZ2V0IiwiRE9FU19OT1RfRVhJU1QiLCJBTFJFQURZX1FVRVVFRCIsIklOX1BST0dSRVNTIiwiRklOSVNIRUQiLCJRVUVVRUQiLCJRVUVVRV9GQUlMRUQiLCJOZnROYW1lc3BhY2UiLCJvcHRpb25zT3JUb2tlblR5cGUiLCJOb3RpZnlOYW1lc3BhY2UiLCJnZXRBbGxXZWJob29rcyIsInZlcmlmeUNvbmZpZyIsInNlbmRXZWJob29rUmVxdWVzdCIsIndlYmhvb2tzIiwicGFyc2VSYXdXZWJob29rUmVzcG9uc2UiLCJnZXRBZGRyZXNzZXMiLCJ3ZWJob29rT3JJZCIsIndlYmhvb2tJZCIsImlkIiwid2ViaG9va19pZCIsImFmdGVyIiwicGFyc2VSYXdBZGRyZXNzQWN0aXZpdHlSZXNwb25zZSIsImdldEdyYXBocWxRdWVyeSIsInBhcnNlUmF3Q3VzdG9tR3JhcGhxbFdlYmhvb2tSZXNwb25zZSIsImdldE5mdEZpbHRlcnMiLCJwYXJzZVJhd05mdEZpbHRlcnNSZXNwb25zZSIsInVwZGF0ZVdlYmhvb2siLCJ1cGRhdGUiLCJpc19hY3RpdmUiLCJpc0FjdGl2ZSIsIm5mdF9maWx0ZXJzX3RvX2FkZCIsImFkZEZpbHRlcnMiLCJuZnRGaWx0ZXJUb1BhcmFtIiwibmZ0X2ZpbHRlcnNfdG9fcmVtb3ZlIiwicmVtb3ZlRmlsdGVycyIsIm5mdF9tZXRhZGF0YV9maWx0ZXJzX3RvX2FkZCIsImFkZE1ldGFkYXRhRmlsdGVycyIsIm5mdF9tZXRhZGF0YV9maWx0ZXJzX3RvX3JlbW92ZSIsInJlbW92ZU1ldGFkYXRhRmlsdGVycyIsImFkZHJlc3Nlc190b19hZGQiLCJyZXNvbHZlQWRkcmVzc2VzIiwiYWRkQWRkcmVzc2VzIiwiYWRkcmVzc2VzX3RvX3JlbW92ZSIsInJlbW92ZUFkZHJlc3NlcyIsImFkZHJlc3NlcyIsIm5ld0FkZHJlc3NlcyIsImNyZWF0ZVdlYmhvb2siLCJhcHBJZCIsIk1JTkVEX1RSQU5TQUNUSU9OIiwiRFJPUFBFRF9UUkFOU0FDVElPTiIsIkdSQVBIUUwiLCJORVRXT1JLX1RPX1dFQkhPT0tfTkVUV09SSyIsIm5mdEZpbHRlck9iaiIsImdyYXBocWxRdWVyeSIsInNraXBFbXB0eU1lc3NhZ2VzIiwiTkZUX0FDVElWSVRZIiwiTkZUX01FVEFEQVRBX1VQREFURSIsImZpbHRlcnMiLCJjb250cmFjdF9hZGRyZXNzIiwidG9rZW5faWQiLCJuZnRfZmlsdGVycyIsIm5mdF9tZXRhZGF0YV9maWx0ZXJzIiwiQUREUkVTU19BQ1RJVklUWSIsIndlYmhvb2tfdHlwZSIsIndlYmhvb2tfdXJsIiwiYXBwX2lkIiwiZ3JhcGhxbF9xdWVyeSIsInNraXBfZW1wdHlfbWVzc2FnZXMiLCJwYXJzZVJhd1dlYmhvb2siLCJkZWxldGVXZWJob29rIiwicmVzb2x2ZWRBZGRyZXNzZXMiLCJyYXdBZGRyZXNzIiwiV0VCSE9PS19ORVRXT1JLX1RPX05FVFdPUksiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJyYXdXZWJob29rIiwidGltZUNyZWF0ZWQiLCJ0aW1lX2NyZWF0ZWQiLCJzaWduaW5nS2V5Iiwic2lnbmluZ19rZXkiLCJwYWdpbmF0aW9uIiwidG90YWxfY291bnQiLCJjdXJzb3JzIiwiZ2V0VG9rZW5zQnlXYWxsZXQiLCJ3aXRoUHJpY2VzIiwiaW5jbHVkZU5hdGl2ZVRva2VucyIsImdldFRva2VuQmFsYW5jZXNCeVdhbGxldCIsImdldE5mdHNCeVdhbGxldCIsImdldE5mdENvbGxlY3Rpb25zQnlXYWxsZXQiLCJnZXRUcmFuc2FjdGlvbnNCeVdhbGxldCIsImJlZm9yZSIsIlBvcnRmb2xpb05hbWVzcGFjZSIsImdldFRva2VuUHJpY2VCeUFkZHJlc3MiLCJnZXRUb2tlblByaWNlQnlTeW1ib2wiLCJzeW1ib2xzIiwicGFyYW1zU2VyaWFsaXplciIsInNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImFwcGVuZCIsImdldEhpc3RvcmljYWxQcmljZUJ5U3ltYm9sIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImludGVydmFsIiwiZ2V0SGlzdG9yaWNhbFByaWNlQnlBZGRyZXNzIiwiUHJpY2VzTmFtZXNwYWNlIiwiR0FTX09QVElNSVpFRF9UWF9GRUVfTVVMVElQTEVTIiwiVHJhbnNhY3ROYW1lc3BhY2UiLCJzZW5kUHJpdmF0ZVRyYW5zYWN0aW9uIiwibWF4QmxvY2tOdW1iZXIiLCJoZXhCbG9ja051bWJlciIsInR4IiwicHJlZmVyZW5jZXMiLCJjYW5jZWxQcml2YXRlVHJhbnNhY3Rpb24iLCJ0eEhhc2giLCJzaW11bGF0ZUFzc2V0Q2hhbmdlc0J1bmRsZSIsInRyYW5zYWN0aW9ucyIsInNpbXVsYXRlQXNzZXRDaGFuZ2VzIiwic2ltdWxhdGVFeGVjdXRpb25CdW5kbGUiLCJzaW11bGF0ZUV4ZWN1dGlvbiIsImdldE1heFByaW9yaXR5RmVlUGVyR2FzIiwiZmVlSGV4Iiwic2VuZEdhc09wdGltaXplZFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25PclNpZ25lZFR4cyIsIl9zZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb24iLCJnYXNMaW1pdCIsInByaW9yaXR5RmVlIiwiYmFzZUZlZSIsImN1cnJlbnRCbG9jayIsImJhc2VGZWVQZXJHYXMiLCJnYXNTcHJlYWRUcmFuc2FjdGlvbnMiLCJnZW5lcmF0ZUdhc1NwcmVhZFRyYW5zYWN0aW9ucyIsInNpZ25lZFRyYW5zYWN0aW9ucyIsInNpZ25UcmFuc2FjdGlvbiIsImdldEdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzIiwidHJhY2tpbmdJZCIsInJhd1RyYW5zYWN0aW9ucyIsImZlZU11bHRpcGxpZXIiLCJtYXhGZWVQZXJHYXMiLCJyb3VuZCIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFIiwiQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSIsIkFMQ0hFTVlfRVZFTlRfVFlQRVMiLCJFdmVudCIsInRhZyIsImxpc3RlbmVyIiwib25jZSIsIl9sYXN0QmxvY2tOdW1iZXIiLCJfaW5mbGlnaHQiLCJldmVudCIsInNwbGl0IiwiY29tcHMiLCJ0b3BpY3MiLCJkZXNlcmlhbGl6ZVRvcGljcyIsInBvbGxhYmxlIiwiUG9sbGFibGVFdmVudHMiLCJpbmRleE9mIiwiRXRoZXJzRXZlbnQiLCJkZXNlcmlhbGl6ZUFkZHJlc3NGaWVsZCIsImhhc2hlc09ubHkiLCJpbmNsdWRlUmVtb3ZlZCIsImRlc2VyaWFsaXplQWRkcmVzc2VzRmllbGQiLCJpc0FsY2hlbXlFdmVudCIsImdldEFsY2hlbXlFdmVudFRhZyIsIlBFTkRJTkdfVFJBTlNBQ1RJT05TIiwic2VyaWFsaXplUGVuZGluZ1RyYW5zYWN0aW9uc0V2ZW50IiwiTUlORURfVFJBTlNBQ1RJT05TIiwic2VyaWFsaXplTWluZWRUcmFuc2FjdGlvbnNFdmVudCIsInZlcmlmeUFsY2hlbXlFdmVudE5hbWUiLCJldmVudE5hbWUiLCJzZXJpYWxpemVBZGRyZXNzRmllbGQiLCJzZXJpYWxpemVCb29sZWFuRmllbGQiLCJzZXJpYWxpemVBZGRyZXNzZXNGaWVsZCIsImZpZWxkIiwidG9waWMiLCJhZGRyZXNzU3RyIiwiYWRkcmVzc1BhaXIiLCJXZWJTb2NrZXROYW1lc3BhY2UiLCJvbiIsInByb2Nlc3NlZEV2ZW50IiwiX3Jlc29sdmVFbnNBbGNoZW15RXZlbnQiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwibGlzdGVuZXJzIiwicHJvY2Vzc2VkQWRkcmVzc2VzIiwiX3Jlc29sdmVOYW1lT3JFcnJvciIsInJlc29sdmVkIiwiQWxjaGVteSIsInNldHRpbmdzIiwiY29yZSIsIndzIiwidHJhbnNhY3QiLCJub3RpZnkiLCJwcmljZXMiLCJwb3J0Zm9saW8iLCJXYWxsZXQiLCJwcml2YXRlS2V5IiwiYWxjaGVteU9yUHJvdmlkZXIiLCJzdXBlclByb3ZpZGVyIiwiUHJvdmlkZXIiLCJpc1Byb3ZpZGVyIiwiYWxjaGVteVByb3ZpZGVyUHJvbWlzZSIsImdldFdhbGxldCIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJnZXRDaGFpbklkIiwiY29ubmVjdCIsIkNvbnRyYWN0IiwiQ29udHJhY3RGYWN0b3J5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/alchemy-sdk/dist/cjs/index-3873e7b8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/alchemy-sdk/dist/cjs/index.js":
/*!****************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/cjs/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar utils = __webpack_require__(/*! ./api/utils */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\nvar index = __webpack_require__(/*! ./index-3873e7b8.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/index-3873e7b8.js\");\nvar bignumber = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\");\n__webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/./node_modules/@ethersproject/wallet/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/./node_modules/@ethersproject/contracts/lib.esm/index.js\");\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar utils__namespace = /*#__PURE__*/ _interopNamespace(utils);\nexports.Utils = utils__namespace;\nexports.Alchemy = index.Alchemy;\nObject.defineProperty(exports, \"AlchemySubscription\", ({\n    enumerable: true,\n    get: function() {\n        return index.AlchemySubscription;\n    }\n}));\nObject.defineProperty(exports, \"AssetTransfersCategory\", ({\n    enumerable: true,\n    get: function() {\n        return index.AssetTransfersCategory;\n    }\n}));\nObject.defineProperty(exports, \"CommitmentLevel\", ({\n    enumerable: true,\n    get: function() {\n        return index.CommitmentLevel;\n    }\n}));\nexports.Contract = index.Contract;\nexports.ContractFactory = index.ContractFactory;\nObject.defineProperty(exports, \"DebugCallType\", ({\n    enumerable: true,\n    get: function() {\n        return index.DebugCallType;\n    }\n}));\nObject.defineProperty(exports, \"DebugTracerType\", ({\n    enumerable: true,\n    get: function() {\n        return index.DebugTracerType;\n    }\n}));\nObject.defineProperty(exports, \"DecodingAuthority\", ({\n    enumerable: true,\n    get: function() {\n        return index.DecodingAuthority;\n    }\n}));\nObject.defineProperty(exports, \"GasOptimizedTransactionStatus\", ({\n    enumerable: true,\n    get: function() {\n        return index.GasOptimizedTransactionStatus;\n    }\n}));\nObject.defineProperty(exports, \"GetTransfersForOwnerTransferType\", ({\n    enumerable: true,\n    get: function() {\n        return index.GetTransfersForOwnerTransferType;\n    }\n}));\nObject.defineProperty(exports, \"HistoricalPriceInterval\", ({\n    enumerable: true,\n    get: function() {\n        return index.HistoricalPriceInterval;\n    }\n}));\nObject.defineProperty(exports, \"Network\", ({\n    enumerable: true,\n    get: function() {\n        return index.Network;\n    }\n}));\nObject.defineProperty(exports, \"NftCollectionMarketplace\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftCollectionMarketplace;\n    }\n}));\nObject.defineProperty(exports, \"NftFilters\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftFilters;\n    }\n}));\nObject.defineProperty(exports, \"NftOrdering\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftOrdering;\n    }\n}));\nObject.defineProperty(exports, \"NftRefreshState\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftRefreshState;\n    }\n}));\nObject.defineProperty(exports, \"NftSaleMarketplace\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftSaleMarketplace;\n    }\n}));\nObject.defineProperty(exports, \"NftSaleTakerType\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftSaleTakerType;\n    }\n}));\nObject.defineProperty(exports, \"NftSpamClassification\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftSpamClassification;\n    }\n}));\nObject.defineProperty(exports, \"NftTokenType\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftTokenType;\n    }\n}));\nObject.defineProperty(exports, \"OpenSeaSafelistRequestStatus\", ({\n    enumerable: true,\n    get: function() {\n        return index.OpenSeaSafelistRequestStatus;\n    }\n}));\nObject.defineProperty(exports, \"SimulateAssetType\", ({\n    enumerable: true,\n    get: function() {\n        return index.SimulateAssetType;\n    }\n}));\nObject.defineProperty(exports, \"SimulateChangeType\", ({\n    enumerable: true,\n    get: function() {\n        return index.SimulateChangeType;\n    }\n}));\nObject.defineProperty(exports, \"SortingOrder\", ({\n    enumerable: true,\n    get: function() {\n        return index.SortingOrder;\n    }\n}));\nObject.defineProperty(exports, \"TokenBalanceType\", ({\n    enumerable: true,\n    get: function() {\n        return index.TokenBalanceType;\n    }\n}));\nexports.Wallet = index.Wallet;\nObject.defineProperty(exports, \"WebhookType\", ({\n    enumerable: true,\n    get: function() {\n        return index.WebhookType;\n    }\n}));\nObject.defineProperty(exports, \"WebhookVersion\", ({\n    enumerable: true,\n    get: function() {\n        return index.WebhookVersion;\n    }\n}));\nexports.fromHex = index.fromHex;\nexports.isHex = index.isHex;\nexports.setLogLevel = index.setLogLevel;\nexports.toHex = index.toHex;\nObject.defineProperty(exports, \"BigNumber\", ({\n    enumerable: true,\n    get: function() {\n        return bignumber.BigNumber;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsWUFBWUYsbUJBQU9BLENBQUM7QUFDeEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsU0FBU0csa0JBQWtCQyxDQUFDO0lBQzNCLElBQUlBLEtBQUtBLEVBQUVDLFVBQVUsRUFBRSxPQUFPRDtJQUM5QixJQUFJRSxJQUFJWCxPQUFPWSxNQUFNLENBQUM7SUFDdEIsSUFBSUgsR0FBRztRQUNOVCxPQUFPYSxJQUFJLENBQUNKLEdBQUdLLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1lBQ2pDLElBQUlBLE1BQU0sV0FBVztnQkFDcEIsSUFBSUMsSUFBSWhCLE9BQU9pQix3QkFBd0IsQ0FBQ1IsR0FBR007Z0JBQzNDZixPQUFPQyxjQUFjLENBQUNVLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtvQkFDdkNHLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1QsQ0FBQyxDQUFDTSxFQUFFO29CQUFFO2dCQUNqQztZQUNEO1FBQ0Q7SUFDRDtJQUNBSixDQUFDLENBQUMsVUFBVSxHQUFHRjtJQUNmLE9BQU9ULE9BQU9vQixNQUFNLENBQUNUO0FBQ3RCO0FBRUEsSUFBSVUsbUJBQW1CLFdBQVcsR0FBRWIsa0JBQWtCSjtBQUl0REYsYUFBYSxHQUFHbUI7QUFDaEJuQixlQUFlLEdBQUdJLE1BQU1pQixPQUFPO0FBQy9CdkIsdURBQXNEO0lBQ3JEbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTWtCLG1CQUFtQjtJQUFFO0FBQ3RELENBQUMsRUFBQztBQUNGeEIsMERBQXlEO0lBQ3hEbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTW1CLHNCQUFzQjtJQUFFO0FBQ3pELENBQUMsRUFBQztBQUNGekIsbURBQWtEO0lBQ2pEbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTW9CLGVBQWU7SUFBRTtBQUNsRCxDQUFDLEVBQUM7QUFDRnhCLGdCQUFnQixHQUFHSSxNQUFNcUIsUUFBUTtBQUNqQ3pCLHVCQUF1QixHQUFHSSxNQUFNc0IsZUFBZTtBQUMvQzVCLGlEQUFnRDtJQUMvQ21CLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9aLE1BQU11QixhQUFhO0lBQUU7QUFDaEQsQ0FBQyxFQUFDO0FBQ0Y3QixtREFBa0Q7SUFDakRtQixZQUFZO0lBQ1pELEtBQUs7UUFBYyxPQUFPWixNQUFNd0IsZUFBZTtJQUFFO0FBQ2xELENBQUMsRUFBQztBQUNGOUIscURBQW9EO0lBQ25EbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTXlCLGlCQUFpQjtJQUFFO0FBQ3BELENBQUMsRUFBQztBQUNGL0IsaUVBQWdFO0lBQy9EbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTTBCLDZCQUE2QjtJQUFFO0FBQ2hFLENBQUMsRUFBQztBQUNGaEMsb0VBQW1FO0lBQ2xFbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTTJCLGdDQUFnQztJQUFFO0FBQ25FLENBQUMsRUFBQztBQUNGakMsMkRBQTBEO0lBQ3pEbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTTRCLHVCQUF1QjtJQUFFO0FBQzFELENBQUMsRUFBQztBQUNGbEMsMkNBQTBDO0lBQ3pDbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTTZCLE9BQU87SUFBRTtBQUMxQyxDQUFDLEVBQUM7QUFDRm5DLDREQUEyRDtJQUMxRG1CLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9aLE1BQU04Qix3QkFBd0I7SUFBRTtBQUMzRCxDQUFDLEVBQUM7QUFDRnBDLDhDQUE2QztJQUM1Q21CLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9aLE1BQU0rQixVQUFVO0lBQUU7QUFDN0MsQ0FBQyxFQUFDO0FBQ0ZyQywrQ0FBOEM7SUFDN0NtQixZQUFZO0lBQ1pELEtBQUs7UUFBYyxPQUFPWixNQUFNZ0MsV0FBVztJQUFFO0FBQzlDLENBQUMsRUFBQztBQUNGdEMsbURBQWtEO0lBQ2pEbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTWlDLGVBQWU7SUFBRTtBQUNsRCxDQUFDLEVBQUM7QUFDRnZDLHNEQUFxRDtJQUNwRG1CLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9aLE1BQU1rQyxrQkFBa0I7SUFBRTtBQUNyRCxDQUFDLEVBQUM7QUFDRnhDLG9EQUFtRDtJQUNsRG1CLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9aLE1BQU1tQyxnQkFBZ0I7SUFBRTtBQUNuRCxDQUFDLEVBQUM7QUFDRnpDLHlEQUF3RDtJQUN2RG1CLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9aLE1BQU1vQyxxQkFBcUI7SUFBRTtBQUN4RCxDQUFDLEVBQUM7QUFDRjFDLGdEQUErQztJQUM5Q21CLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9aLE1BQU1xQyxZQUFZO0lBQUU7QUFDL0MsQ0FBQyxFQUFDO0FBQ0YzQyxnRUFBK0Q7SUFDOURtQixZQUFZO0lBQ1pELEtBQUs7UUFBYyxPQUFPWixNQUFNc0MsNEJBQTRCO0lBQUU7QUFDL0QsQ0FBQyxFQUFDO0FBQ0Y1QyxxREFBb0Q7SUFDbkRtQixZQUFZO0lBQ1pELEtBQUs7UUFBYyxPQUFPWixNQUFNdUMsaUJBQWlCO0lBQUU7QUFDcEQsQ0FBQyxFQUFDO0FBQ0Y3QyxzREFBcUQ7SUFDcERtQixZQUFZO0lBQ1pELEtBQUs7UUFBYyxPQUFPWixNQUFNd0Msa0JBQWtCO0lBQUU7QUFDckQsQ0FBQyxFQUFDO0FBQ0Y5QyxnREFBK0M7SUFDOUNtQixZQUFZO0lBQ1pELEtBQUs7UUFBYyxPQUFPWixNQUFNeUMsWUFBWTtJQUFFO0FBQy9DLENBQUMsRUFBQztBQUNGL0Msb0RBQW1EO0lBQ2xEbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTTBDLGdCQUFnQjtJQUFFO0FBQ25ELENBQUMsRUFBQztBQUNGOUMsY0FBYyxHQUFHSSxNQUFNMkMsTUFBTTtBQUM3QmpELCtDQUE4QztJQUM3Q21CLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9aLE1BQU00QyxXQUFXO0lBQUU7QUFDOUMsQ0FBQyxFQUFDO0FBQ0ZsRCxrREFBaUQ7SUFDaERtQixZQUFZO0lBQ1pELEtBQUs7UUFBYyxPQUFPWixNQUFNNkMsY0FBYztJQUFFO0FBQ2pELENBQUMsRUFBQztBQUNGakQsZUFBZSxHQUFHSSxNQUFNOEMsT0FBTztBQUMvQmxELGFBQWEsR0FBR0ksTUFBTStDLEtBQUs7QUFDM0JuRCxtQkFBbUIsR0FBR0ksTUFBTWdELFdBQVc7QUFDdkNwRCxhQUFhLEdBQUdJLE1BQU1pRCxLQUFLO0FBQzNCdkQsNkNBQTRDO0lBQzNDbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1gsVUFBVWlELFNBQVM7SUFBRTtBQUNoRCxDQUFDLEVBQUMsRUFDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taXNzaW9uLWxhdW5jaC1idXJuLW9yLWdsb3J5Ly4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvY2pzL2luZGV4LmpzP2NhMWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2FwaS91dGlscycpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnLi9pbmRleC0zODczZTdiOC5qcycpO1xudmFyIGJpZ251bWJlciA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcicpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYnl0ZXMnKTtcbnJlcXVpcmUoJ2F4aW9zJyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlcicpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3Qvd2FsbGV0Jyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9jb250cmFjdHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuXHRpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuXHR2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGlmIChlKSB7XG5cdFx0T2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdFx0aWYgKGsgIT09ICdkZWZhdWx0Jykge1xuXHRcdFx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblx0bltcImRlZmF1bHRcIl0gPSBlO1xuXHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIHV0aWxzX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UodXRpbHMpO1xuXG5cblxuZXhwb3J0cy5VdGlscyA9IHV0aWxzX19uYW1lc3BhY2U7XG5leHBvcnRzLkFsY2hlbXkgPSBpbmRleC5BbGNoZW15O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBbGNoZW15U3Vic2NyaXB0aW9uJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LkFsY2hlbXlTdWJzY3JpcHRpb247IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdBc3NldFRyYW5zZmVyc0NhdGVnb3J5Jywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnk7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDb21taXRtZW50TGV2ZWwnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguQ29tbWl0bWVudExldmVsOyB9XG59KTtcbmV4cG9ydHMuQ29udHJhY3QgPSBpbmRleC5Db250cmFjdDtcbmV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gaW5kZXguQ29udHJhY3RGYWN0b3J5O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEZWJ1Z0NhbGxUeXBlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LkRlYnVnQ2FsbFR5cGU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEZWJ1Z1RyYWNlclR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguRGVidWdUcmFjZXJUeXBlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRGVjb2RpbmdBdXRob3JpdHknLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguRGVjb2RpbmdBdXRob3JpdHk7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5HYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1czsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0dldFRyYW5zZmVyc0Zvck93bmVyVHJhbnNmZXJUeXBlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LkdldFRyYW5zZmVyc0Zvck93bmVyVHJhbnNmZXJUeXBlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnSGlzdG9yaWNhbFByaWNlSW50ZXJ2YWwnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguSGlzdG9yaWNhbFByaWNlSW50ZXJ2YWw7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOZXR3b3JrJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4Lk5ldHdvcms7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOZnRDb2xsZWN0aW9uTWFya2V0cGxhY2UnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmZ0RmlsdGVycycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5OZnRGaWx0ZXJzOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmZ0T3JkZXJpbmcnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0T3JkZXJpbmc7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOZnRSZWZyZXNoU3RhdGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0UmVmcmVzaFN0YXRlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmZ0U2FsZU1hcmtldHBsYWNlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4Lk5mdFNhbGVNYXJrZXRwbGFjZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ05mdFNhbGVUYWtlclR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0U2FsZVRha2VyVHlwZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ05mdFNwYW1DbGFzc2lmaWNhdGlvbicsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5OZnRTcGFtQ2xhc3NpZmljYXRpb247IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOZnRUb2tlblR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0VG9rZW5UeXBlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5PcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU2ltdWxhdGVBc3NldFR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguU2ltdWxhdGVBc3NldFR5cGU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTaW11bGF0ZUNoYW5nZVR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguU2ltdWxhdGVDaGFuZ2VUeXBlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU29ydGluZ09yZGVyJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LlNvcnRpbmdPcmRlcjsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1Rva2VuQmFsYW5jZVR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguVG9rZW5CYWxhbmNlVHlwZTsgfVxufSk7XG5leHBvcnRzLldhbGxldCA9IGluZGV4LldhbGxldDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnV2ViaG9va1R5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguV2ViaG9va1R5cGU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdXZWJob29rVmVyc2lvbicsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5XZWJob29rVmVyc2lvbjsgfVxufSk7XG5leHBvcnRzLmZyb21IZXggPSBpbmRleC5mcm9tSGV4O1xuZXhwb3J0cy5pc0hleCA9IGluZGV4LmlzSGV4O1xuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGluZGV4LnNldExvZ0xldmVsO1xuZXhwb3J0cy50b0hleCA9IGluZGV4LnRvSGV4O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdCaWdOdW1iZXInLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVyLkJpZ051bWJlcjsgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInV0aWxzIiwicmVxdWlyZSIsImluZGV4IiwiYmlnbnVtYmVyIiwiX2ludGVyb3BOYW1lc3BhY2UiLCJlIiwiX19lc01vZHVsZSIsIm4iLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsInV0aWxzX19uYW1lc3BhY2UiLCJVdGlscyIsIkFsY2hlbXkiLCJBbGNoZW15U3Vic2NyaXB0aW9uIiwiQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeSIsIkNvbW1pdG1lbnRMZXZlbCIsIkNvbnRyYWN0IiwiQ29udHJhY3RGYWN0b3J5IiwiRGVidWdDYWxsVHlwZSIsIkRlYnVnVHJhY2VyVHlwZSIsIkRlY29kaW5nQXV0aG9yaXR5IiwiR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMiLCJHZXRUcmFuc2ZlcnNGb3JPd25lclRyYW5zZmVyVHlwZSIsIkhpc3RvcmljYWxQcmljZUludGVydmFsIiwiTmV0d29yayIsIk5mdENvbGxlY3Rpb25NYXJrZXRwbGFjZSIsIk5mdEZpbHRlcnMiLCJOZnRPcmRlcmluZyIsIk5mdFJlZnJlc2hTdGF0ZSIsIk5mdFNhbGVNYXJrZXRwbGFjZSIsIk5mdFNhbGVUYWtlclR5cGUiLCJOZnRTcGFtQ2xhc3NpZmljYXRpb24iLCJOZnRUb2tlblR5cGUiLCJPcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzIiwiU2ltdWxhdGVBc3NldFR5cGUiLCJTaW11bGF0ZUNoYW5nZVR5cGUiLCJTb3J0aW5nT3JkZXIiLCJUb2tlbkJhbGFuY2VUeXBlIiwiV2FsbGV0IiwiV2ViaG9va1R5cGUiLCJXZWJob29rVmVyc2lvbiIsImZyb21IZXgiLCJpc0hleCIsInNldExvZ0xldmVsIiwidG9IZXgiLCJCaWdOdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/alchemy-sdk/dist/cjs/index.js\n");

/***/ })

};
;